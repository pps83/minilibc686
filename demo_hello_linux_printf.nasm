;
; demo_hello_linux_printf.nasm: Linux i386 32-bit ELF executable program with printf(3)
; by pts@fazekas.hu at Wed May 24 01:08:00 CEST 2023
;
; Total file size: 1008 bytes.
;
; This file matches the output of GCC 7.5.0:
;
;     minicc --gcc -W -Wall -Werror demo_c_hello.c
;
; Compile to Linux i386 32-bit ELF executable:
;
;     tools/nasm-0.98.39 -O0 -w+orphan-labels -f bin -o demo_hello_linux_printf.prog demo_hello_linux_printf.nasm &&
;     chmod +x demo_hello_linux_printf.prog
;
; With NASM optimizations enabled it generates the same program (bitwise
; identical):
;
;     tools/nasm-0.98.39 -O999999999 -w+orphan-labels -f bin -o demo_hello_linux_printf.prog demo_hello_linux_printf.nasm &&
;     chmod +x demo_hello_linux_printf.prog
;
; Compiling with Yasm (tested with 1.2.0 and 1.3.0) doesn't work, because
; smart.nasm uses some NASM features (labels in %if) which don't work in
; Yasm.
;
; Run it on Linux i386 or Linux amd64 systems:
;
;     ./demo_hello_linux_printf.prog
;
; Alternatively, compile the ELF-32 relocatable .o object file with NASM,
; and link it against minilibc686:
;
;     tools/nasm-0.98.39 -O0 -w+orphan-labels -f elf -o demo_hello_linux_printf.o demo_hello_linux_printf.nasm &&
;     minicc -o demo_hello_linux_printf.prog2 demo_hello_linux_printf.o
;
; These two compilation methods create bitwise identical executable program
; files, proving that `minicc' and its tools don't add extra overhead in
; this case. Verify it with:
;
;     cmp demo_hello_linux_printf.prog demo_hello_linux_printf.prog2
;     # (no output from cmp indicates exact match)
;

;%define CONFIG_ELF_OSABI OSABI.Linux  ; Default, good.
;%define CONFIG_ELF_OSABI OSABI.SYSV  ; Generic. This is to match an ELF executable created by GCC.
;%define CONFIG_NO_RW_SECTIONS
%define ALIGN_RODATA 1
%include "elf0.inc.nasm"

; Config options respected by src/smart.nasm and other minilibc686 src/*.nasm.
%define CONFIG_MAIN_NO_ENVP
%define CONFIG_VFPRINTF_NO_PLUS
%define CONFIG_VFPRINTF_NO_OCTAL

extern mini_printf
global main
main:  ; int main(int argc, char **argv, char **envp);  /* envp is optional to declare and/or use. */
; /* Assembly code generated by GCC 7.5.0. */
; #include <stdio.h>
; int main(int argc, char **argv) {
;   printf("Hello, %s!\n", argc < 2 ? "World" : argv[1]);
;   return 0;
; }
		push ebp
		mov eax, str_world
		mov ebp, esp
		cmp dword [ebp+8], byte 1
		jle .14
		mov eax, [ebp+0xc]
		mov eax, [eax+4]  ; argv[1].
.14:		push eax
		push strict dword str_hello
		call mini_printf
		xor eax, eax
		leave
		ret

section .rodata
str_world	db 'World', 0
str_hello	db 'Hello, %s!', 10, 0

%ifidn __OUTPUT_FORMAT__, bin
  extern mini__start  ; Needed by smart.nasm below.
  ; Include various libc functionality. mini_printf(...) is defined in
  ; printf_callvf.nasm, the others are dependencies.
  %include "src/smart.nasm"  ; Defines (among others) _start which calls main(...).
  ; These below are helpfully included by smart.nasm because of UNDEFSYMS.
  ;%include "src/printf_callvf.nasm"
  ;%include "src/stdio_medium_fputc_rp3.nasm"
  ;%include "src/stdio_medium_stdout.nasm"
  ;%include "src/stdio_medium_vfprintf.nasm"
  ;%include "src/stdio_medium_writebuf_relax.nasm"
  ;%include "src/isatty_linux.nasm"
  ;%include "src/stdio_medium_fflush.nasm"
  ;%include "src/stdio_medium_discard_buf.nasm"
%endif

_end  ; __END__
