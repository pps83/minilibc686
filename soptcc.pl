#!/bin/sh --
eval 'PERL_BADLANG=x;export PERL_BADLANG;exec perl -x "$0" "$@";exit 1'
#!perl  # Start marker used by perl -x.
+0 if 0;eval("\n\n\n\n".<<'__END__');die$@if$@;__END__

#
# soptcc.pl: size-optimizing C compiler frontend for i386
# by pts@fazekas.hu at Wed May 10 22:45:37 CEST 2023
#
# Runs multiple C compilers and picks the one which generates fewer (code)
# bytes. Emits a NASM source file (`nasm -f elf -O999999999'). Supports only
# i386 architecture (up to i686) with the SYSV calling convention
# (-mregparm=0).
#

BEGIN { $^W = 1 }
use integer;
use strict;

# ---

# Escapes filename as any shell command-line argument.
sub shargq($) {
  my $fnq = $_[0];
  if ($fnq !~ m@\A[-/+.,\w][-/+.,=\w]*\Z(?!\n)@) {
    $fnq =~ s@[\r\n]+@ @g;
    $fnq =~ s@'@'\\''@g;
    $fnq = "'$fnq'";
  }
  $fnq
}

# Escapes filename as non-flag shell command-line argument.
sub fnargq($) {
  my $fnq = $_[0];
  $fnq = "./$fnq" if $fnq =~ m@\A-@;
  return shargq($fnq);
}

sub argv_escape_fn($) {
  my $filename = $_[0];
  substr($filename, 0, 0) = "./" if $filename =~ m@-@;  # TODO(pts): Win32 compatibility.
  $filename
}

sub detect_binary_format($) {
  my $filename = $_[0];
  my $fh;
  die "fatal: open for reading: $filename: $!\n" if !open($fh, "<", $filename);
  my $hdr;
  die "fatal: read: $filename: $!\n" if !defined(sysread($fh, $hdr, 4));
  if ($hdr =~ m@\s*[.]@) {
    die "fatal: read more: $filename: $!\n" if !defined(sysread($fh, $hdr, 32, length($hdr)));
    close($fh);
    if ($hdr =~ m@\A\s*[.](?:model\s|38[67])@i) {
      return "wasm";
    #} elsif (m@\A\s*(?:bits\s|cpu\s|section\s|%)@i) {
    #  return "nasm";
    } else {
      return "as";
    }
  }
  close($fh);
  if (!length($hdr)) {
    return "empty";
  } elsif ($hdr =~ m@\A\x7fELF@) {
    return "elf";  # Can be program (executable), object (relocatable) etc.
  } elsif ($hdr =~ m@\AMZ@) {
    return "exe";
  } elsif ($hdr =~ m@\A\x80@) {  # OMF .obj object file generated by e.g. OpenWatcom.
    return "omf";
  } elsif ($hdr =~ m@\A\x4c\x01@) {  # COFF .obj obect file used on Win32.
    return "coff";
  } elsif ($hdr =~ m@\A(?:\xfe\xed\xfa[\xce|\xcf]|[\xce\xcf]\xfa\xed\xfe)@) {
    return "macho";  # Can  be executable, object etc.
  }
  undef  # die "fatal: unknown file format: $filename\n";
}

sub print_nasm_header($$$$$$) {
  my($nasmfh, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment) = @_;
  print $nasmfh "; .nasm source file generated by soptcc.pl\n; from $srcfn\n",
                "; Compile to i386 ELF .o object: nasm -O999999999 -w+orphan-labels -f elf -o " . fnargq("$basefn.o") . " " . fnargq($nasmfn) . "\n\n",
                "bits 32\n";
  # %ifidn __OUTPUT_FORMAT__, elf
  print $nasmfh "cpu $nasm_cpu\n" if $nasm_cpu;
  print $nasmfh "section .text align=1\n",
                "section .rodata align=$data_alignment\n",
                "section .data align=$data_alignment\n",
                "section .bss align=$data_alignment\n\n";
  #print $nasmfh "\nsection .text\n";  # asm2nasm(...) will print it.
}

# --- Merge C string literal by tail (e.g. merge "bar" and "foobar").

# Merge C string literal by tail (e.g. merge "bar" and "foobar").
#
# $outfh is the filehandle to write NASM assembly lines to.
#
# $rodata_strs is a reference to an array containing assembly source lines
# (`label:' and `db: ...') in `section .rodata', `section .rdata' and
# `section .rodata.str1.1' (GCC, GNU as; already
# converted to db) or `CONST SEGMENT' (OpenWatcom WASM). It will be cleared
# as a side effect.
#
# TODO(pts): Deduplicate strings in .nasm source as well.
sub print_merged_strings_in_strdata($$$) {
  my($outfh, $rodata_strs, $is_db_canonical_gnu_as) = @_;
  return if !$rodata_strs or !@$rodata_strs;
  # Test data: my $strdata_test = "foo:\ndb 'ello', 0\ndb 0\ndb 'oth'\nmer:\ndb 'er', 1\ndb 2\ndb 0\ndb 3\ndb 0\ndb 4\ndb 'hell'\nbar:\ndb 'o', 0\nbaz:\ndb 'lo', 0, 'ello', 0, 'hell', 0, 'foo', ', ', 0, 15, 3, 0\nlast:";  @$rodata_strs = split(/\n/, $strdata_test);
  my $ofs = 0;
  my @labels;
  my $strdata = "";
  for my $str (@$rodata_strs) {
    if ($str =~ m@\A\s*db\s@i) {
      pos($str) = 0;
      if ($is_db_canonical_gnu_as) {  # Shortcut.
        while ($str =~ m@\d+|'([^']*)'@g) { $ofs += defined($1) ? length($1) : 1 }
        $strdata .= $str;
        $strdata .= "\n";
      } else {
        die if $str !~ s@\A\s*db\s+@@i;
        my $str0 = $str;
        my $has_error = 0;
        # Parse and canonicalize the db string, so that we can transform it later.
        $str =~ s@(-?)0[xX]([0-9a-fA-F]+)|(-?)([0-9][0-9a-fA-F]*)[hH]|(-?)(0(?!\d)|[1-9][0-9]*)|('[^']*')|(\s*,\s*)|([^\s',]+)@
          my $v;
          if (defined($1) or defined($3) or defined($5)) {
            ++$ofs;
            $v = defined($1) ? ($1 ? -hex($2) : hex($2)) & 255 :
                 defined($3) ? ($3 ? -hex($4) : hex($4)) & 255 :
                 defined($5) ? ($5 ? -int($6) : int($6)) & 255 : undef;
            ($v >= 32 and $v <= 126 and $v != 0x27) ? "'" . chr($v) . "'" : $v
          } elsif (defined($7)) { $ofs += length($7) - 2; $7 }
          elsif (defined($8)) { ", " }
          else { $has_error = 1; "" }
        @ge;
        die "fatal: arg: syntax error in string literal db: $str0\n" if $has_error;
        #$str =~ s@', '@@g;  # This is incorrect, e.g. db 1, ', ', 2
        $strdata .= "db $str\n";
      }
    } elsif ($str =~ m@\s*([^\s:,]+)\s*:\s*\Z(?!\n)@) {
      push @labels, [$ofs, $1];
      #print STDERR ";;old: $1 equ strs+$ofs\n";
    } elsif ($str =~ m@\S@) {
      die "fatal: arg: unexpected string literal instruction: $str\n";
    }
  }
  # $strdata already has very strict syntax (because we have generated its
  # dbs), so we can do these regexp substitutions below safely.
  $strdata =~ s@([^:])\ndb @$1, @g;
  $strdata = "db " if !length($strdata);
  die "fatal: assert: missing db" if $strdata !~ m@\Adb@;
  die "fatal: assert: too many dbs" if $strdata =~ m@.db@s;
  $strdata =~ s@^db @db , @mg;
  $strdata =~ s@, 0(?=, )@, 0\ndb @g;  # Split lines on NUL.
  my $ss = 0;
  while (length($strdata) != $ss) {  # Join adjacent 'chars' arguments.
    $ss = length($strdata);
    $strdata =~ s@'([^']*)'(?:, '([^']*)')?@ my $x = defined($2) ? $2 : ""; "'$1$x'" @ge;
  }
  chomp($strdata);
  @$rodata_strs = split(/\n/, $strdata);
  my @sorteds;
  {
    my $i = 0;
    for my $str (@$rodata_strs) {
      my $rstr = reverse($str);
      substr($rstr, -3) = "";  # Remove "db ".
      substr($rstr, 0, 3) = "";  # Remove "0, ".
      $rstr =~ s@' ,\Z@@;
      push @sorteds, [$rstr, $i];
      ++$i;
    }
  }
  @sorteds = sort { $a->[0] cmp $b->[0] or $a->[1] <=> $b->[1] } @sorteds;
  my %mapi;
  for (my $i = 0; $i < $#sorteds; ++$i) {
    my $rstri = $sorteds[$i][0];
    my $rstri1 = $sorteds[$i + 1][0];
    if (length($rstri1) >= length($rstri) and substr($rstri1, 0, length($rstri)) eq $rstri) {
      $mapi{$sorteds[$i][1]} = $sorteds[$i + 1][1];
    }
  }
  my @ofss;
  my @oldofss;
  #%mapi = ();  # For debugging: don't merge anything.
  {
    my $i = 0;
    my $ofs = 0;
    my $oldofs = 0;
    my @sizes;
    for my $str (@$rodata_strs) {
      pos($str) = 0;
      my $size = 0;
      while ($str =~ m@\d+|'([^']*)'@g) { $size += defined($1) ? length($1) : 1 }
      push @sizes, $size;
      push @oldofss, $oldofs;
      $oldofs += $size;
      if (exists($mapi{$i})) {
        my $j = $mapi{$i};
        $j = $mapi{$j} while exists($mapi{$j});
        $mapi{$i} = $j;
        #print STDERR ";$i: ($str) -> ($rodata_strs->[$j]}\n";
        push @ofss, undef;
      } else {
        push @ofss, $ofs;
        $ofs += $size;
        #print STDERR "$str\n";
      }
      ++$i;
    }
    if (%mapi) {
      for ($i = 0; $i < @$rodata_strs; ++$i) {
        my $j = $mapi{$i};
        $ofss[$i] = $ofss[$j] + $sizes[$j] - $sizes[$i] if defined($j) and !defined($ofss[$i]);
      }
    }
    push @ofss, $ofs;
    push @oldofss, $oldofs;
  }
  {
    for my $str (@$rodata_strs) {
      die "fatal: assert: missing db-comma\n" if $str !~ s@\Adb , @db @;  # Modify in place.
      # !! if TODO(pts): length($str) > 500, then split to several `db's.
      $str .= "\n";
    }
    #print $outfh "section .rodata\n";  # Printed by the caller.
    print $outfh "__strs:\n";
    my $i = 0;
    my $pi = 0;
    for my $pair (@labels) {
      my($lofs, $label) = @$pair;
      ++$i while $i + 1 < @oldofss and $oldofss[$i + 1] <= $lofs;
      die "fatal: assert: bad oldoffs\n" if $i >= @oldofss;
      my $ofs = $lofs - $oldofss[$i] + $ofss[$i];
      for (; $pi < $i; ++$pi) {
        #print STDERR "$rodata_strs->[$pi]\n" if !exists($mapi{$pi});
        print $outfh "\t\t", $rodata_strs->[$pi] if !exists($mapi{$pi});
      }
      if ($lofs != $oldofss[$i] or exists($mapi{$i})) {
        if (exists($mapi{$i})) {
          # !! TODO(pts): Find a later (or earlier), closer label, report relative offset there.
          print $outfh "$label equ __strs+$ofs  ; old=$lofs\n";
        } else {
          my $dofs = $lofs - $oldofss[$i];
          #print STDERR "$label equ \$+$dofs\n";
          print $outfh "$label equ \$+$dofs\n";
        }
      } else {
        #print STDERR "$label:\n";
        print $outfh "$label:\n";
      }
    }
    for (; $pi < @$rodata_strs; ++$pi) {
      #print STDERR "$rodata_strs->[$pi]\n" if !exists($mapi{$pi});
      print $outfh "\t\t", $rodata_strs->[$pi] if !exists($mapi{$pi});
    }
  }
  @$rodata_strs = ();
}

# ---

sub print_commons($$$) {
  my($outfh, $common_by_label, $define_when_defined) = @_;
  return if !%$common_by_label;
  my @commons2;
  for my $label (sort(keys(%$common_by_label))) {
    die "fatal: assert: common value syntax\n" if $common_by_label->{$label} !~ m@\A(\d+):(\d+)\Z(?!\n)@;
    push @commons2, [$label, $1 + 0, $2 + 0];
  }
  # (alignment decreasing, size decreasing, name lexicographically increasing).
  @commons2 = sort { $b->[2] <=> $a->[2] or $b->[1] <=> $a->[1] or $a->[0] cmp $b->[0] } @commons2;
  print $outfh "\nsection .bss  ; common\n";
  # NASM 0.98.39 and 0.99.06 report phase errors with if the .nasm file
  # contains forward-referenced `common' directives, even without the equ
  # hack below. It works with NASM 2.13.02, but only without the `equ'
  # hack: with `equ' it's Segmentation fault when running.
  #
  # Thus we emit the .bss manually even for `nasm -f elf'. Thus, without
  # the `common', it's not possible for many .c source file to say `int
  # var;'. One of them must have `int var;', the others must have `extern
  # int var;'.
  if (0) {
    print $outfh "%ifidn __OUTPUT_FORMAT__, elf\n";
    for my $tuple (@commons2) {
      my($label, $size, $alignment) = @$tuple;
      #print $outfh "common $label $size:$alignment\n";
      #if (exists($define_when_defined{$label})) {
      #  my $label1 = $define_when_defined{$label};
      #  print $outfh "$label1 equ $label\n";
      #}
      if (exists($define_when_defined->{$label})) {
        my $label1 = $define_when_defined->{$label};
        #print $outfh "$label1 equ $label\n";
        print $outfh "common $label1 $size:$alignment\n";
      } else {
        print $outfh "common $label $size:$alignment\n";
      }
    }
    print $outfh "%else  ; ifidn __OUTPUT_FORMAT__, elf\n";
  }
  for my $tuple (@commons2) {
    my($label, $size, $alignment) = @$tuple;
    print $outfh "alignb $alignment\n" if $alignment > 1;
    print $outfh "$label: resb $size  ; align=$alignment\n";
    if (exists($define_when_defined->{$label})) {
      my $label1 = $define_when_defined->{$label};
      print $outfh "$label1 equ $label\n";
    }
  }
  if (0) {
    print $outfh "%endif ; ifidn __OUTPUT_FORMAT__, elf\n";
  }
}

# --- Assembly syntax onversion helpers.

my %gp_regs = map { $_ => 1 } qw(al cl dl bl ah ch dh bh ax cx dx bx sp bp si di eax ecx edx ebx esp ebp esi edi);

my %shift_instructions = map { $_ => 1 } qw (rcl rcr rol ror sal sar shl shr);

# --- convert_as_to_nasm(...)

sub convert_as_to_nasm($$$$$$) {
  my($asfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment) = @_;
  printf STDERR "info: converting as to NASM syntax to: $nasmfn\n";
  my $asfh;
  die "fatal: open for reading: $asfn: $!\n" if !open($asfh, "<", $asfn);  # TODO(pts): Unlink it on subsequent errors.
  my $nasmfh;
  die "fatal: open for writing: $nasmfn: $!\n" if !open($nasmfh, ">", $nasmfn);  # TODO(pts): Unlink it on subsequent errors.
  print_nasm_header($nasmfh, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
  my $line;
  while (defined($line = <$asfh>)) {
    print $nasmfh $line;  # !! TODO(pts): Do proper conversion.
  }
  # !! print_commons($nasmfh, $common_by_label, $define_when_defined);  # Aggregate from multiple source files.
  print $nasmfh "\n; __END__\n";
  die "fatal: error writing NASM-assembly output\n" if !close($nasmfh);
  close($asfh);  # TODO(pts): Fail on write error;
}

# --- convert_wasm_to_nasm(...)

# Converts WASM (OpenWatcom assembler) syntax to NASM 0.98.39 syntax,
# Supports only a very small subset of WASM syntax, mostly the one generated
# by `wdis' (the OpenWatcom disassembler), and most hand-written .wasm
# source files won't work.
#
# The input file come from `wdis -a' or `wdis -a -fi'.
sub wasm2nasm($$$$$$$) {
  my($srcfh, $outfh, $first_line, $lc, $rodata_strs, $is_win32, $is_start_found_ref) = @_;
  my $section = ".text";
  my $segment = "";
  my $bss_org = 0;
  my $is_end = 0;
  my %segment_to_section = qw(_TEXT .text  CONST .rodata  CONST2 .rodata  _DATA .data  _BSS .bss);
  my %directive_to_segment = qw(.code _TEXT  .const CONST2  .data _DATA  .data? _BSS);  # TODO(pts): Is there a way for CONST2?
  my $end_expr;
  my @abitest_insts;  # Label and list of instructions being buffered.
  my $do_hide_abitest = 0;
  while (defined($first_line) or defined($first_line = <$srcfh>)) {
    ++$lc;
    ($_, $first_line) = ($first_line, undef);
    y@\r\n@@d;
    die "fatal: line after end ($lc): $_\n" if $is_end;
    my $is_instr = s@^\t(?!\t)@@;  # Assembly instruction.
    s@\A\s+@@;
    if (s@^\s*db\s+@db @i) {
      die "fatal: comment in db line\n" if m@;@;  # TODO(pts): Parse db '?'.
      s@\s+\Z(?!\n)@@;
    } else {
      s@;.*@@s;
      s@\s+@ @g;
      s@ \Z(?!\n)@@;
      s@\s*,\s*@, @g;
    }
    if ($is_instr) {
      die "fatal: unsupported instruction in non-.text ($lc): $_\n" if $section ne ".text";
      die "fatal: unsupported quote in instruction ($lc): $_\n" if m@'@;  # Whitespace is already gone.
      s@([\s:\[\],+\-*/()<>`])(?:([0-9][0-9a-fA-F]*)[hH]|(0|[1-9]\d*))@ defined($3) ? sprintf("%s0x%x", $1, $3) : sprintf("%s0x%x", $1, hex($2)) @ge;
      if (s~^(jmp|call) near ptr (?:FLAT:)?~$1 \$~) {
        s@\$`([^\s:\[\],+\-*/()<>`]+)`@\$$1@g;
      } elsif (s@^(j[a-z]+|loop[a-z]*) ([^\[\],\s]+)$@$1 \$$2@) {   # Add $ in front of jump target label.
        if (!s@\$`([^\s:\[\],+\-*/()<>`]+)`@\$$1@g) {  # Remove backtick quotes.
          s@^(jmp|call) \$([a-z]{2,})$@ exists($gp_regs{$2}) ? "$1 $2" : "$1 \$$2" @e;  # Make `jmp cx' work.
        }
      } elsif ($is_win32 and m@^call dword ptr *(?:FLAT:)?`?__imp__([^\s:\[\],+\-*/()<>`]+?)((?:\@\d+)?)`?$@) {
        $_ = "kcall __imp__$1$2, '$1'";  # Example: kcall __imp__GetStdHandle@4, 'GetStdHandle'
      } elsif ($_ eq "????") {
        die "fatal: unknown instruction\n";  # WASM doesn't recognize e.g. `db 0xd6' == `salc'.
      } else {
        s@ ptr ([cdefgs]s:)([^\[\],\s:]*)\[@ ptr $2\[$1@g;
        s@^(frstor|fsave|fstenv|fldenv|lea \w+,) (?:FLAT:)?([^\[\],]+)$@$1 [$2]@;
        s`([\s,])(byte|word|dword|fword|qword) ptr (?:([^\[\],\s]*)\[(.*?)\]|(?:([cdefgs]s:)|(?:FLAT|DGROUP:))?([^,]+))`
            # Example: sgdt fword ptr [...] to sgdt [...].
            my $size = $2 eq "fword" ? "" : "$2 ";
            if (defined($3)) {
              my $p = "$1$size\[$4"; my $displacement = $3;
              if (length($displacement)) {
                $p .= "+" if $displacement !~ m@\A-(?:0[xX][0-9a-fA-F]+|[0-9][0-9a-fA-F]*[hH]|0|[1-9]\d*)\Z(?!\n)@;
                $p .= $displacement;
              }
              $p .= "]"
            } else { my $seg = defined($5) ? $5 : ""; "$1$size\[$seg\$$6]" } `ge;
        s@^(call|jmp) dword \[@$1 [@;
        s@([\s,])([^\[\],\s]+)\[(.*?)\]@${1}[$3+$2]@g;  # `cmp al, 42[esi]'   -->  `cmp al, [esi+42]'.
        s@([-+])FLAT:([^,]+)@$1\$$2@g;
        s@([\s:\[\],+\-*/()<>])offset (?:FLAT:)?([^\s,+\-\[\]*/()<>]+)@$1\$$2@g;
        s@\$`([^\s:\[\],+\-*/()<>`]+)`@\$$1@g;  # Remove backtick quotes in `call dword [$`__imp__GetStdHandle@4`]`.
        if (m@^([a-z0-9]+) (?:byte|word|dword) ([^,]+)(, *(?:byte |word |dword )?([^,]+))?$@) {
          if (exists($gp_regs{$2}) or (
              defined($4) and
              not ($4 eq "cl" and exists($shift_instructions{$1})) and
              exists($gp_regs{$4}) and
              $1 ne "movsx" and $1 ne "movzx")) {
            my $m3 = defined($3) ? $3 : "";
            $_ = "$1 $2$m3";  # Omit the byte|word|dword qualifier.
          }
        } elsif (m@^([a-z0-9]+) ([^,]+), *(?:byte|word|dword) ([^,]+)?$@) {
          if (exists($gp_regs{$3}) or ($1 ne "movsx" and $1 ne "movzx" and exists($gp_regs{$2}))) {
            $_ = "$1 $2, $3";  # Omit the byte|word|dword qualifier.
          }
        }
        # !! TODO(pts): Some `fwait' (`db 0x9b') instructions are removed by
        #    wdis (e.g. in front `fld st'), which NASM won't add back. Add
        #    them back manually.
        s@([\s,])st\((\d)\)(?=[\s,]|\Z)@${1}st$2@g;  # st(0) --> st0.
        s@([\s,])st(?=[\s,]|\Z)@${1}st0@g;  # st --> st0.
      }
      if ($rodata_strs and $segment eq "CONST") {  # C string literals.
        push @$rodata_strs, $_;
      } else {
        print $outfh "\t\t$_\n" if !$do_hide_abitest;
        if (@abitest_insts) {
          if ($_ eq "ret") {
            my $abitest_name = shift(@abitest_insts);
            # The emitted `_abi cc, watcall' or `_abi cc, rp0' may not be
            # the before all labels and code, becase the OpenWatcom C
            # compiler sometimes merges function body tails, and it may get
            # merged to a later one.
            die "fatal: abitest not implemented\n";
            #exit(1) if process_abitest($outfh, $abitest_name, \@abitest_insts, $lc);
            @abitest_insts = ();
            $do_hide_abitest = 0;
          } else {
            push @abitest_insts, "\t\t$_\n";
          }
        }
      }
    } elsif (m@^[.]@) {
      die "fatal: incomplete abitest ($lc): $_\n" if @abitest_insts;
      if ($_ eq ".387" or $_ eq ".model flat") {  # Ignore.
      } elsif (m@^[.]386@) {
        #print $outfh "cpu 386\n";
      } elsif (exists($directive_to_segment{$_})) {
        $segment = $directive_to_segment{$_};
        $section = $segment_to_section{$segment};
        print $outfh "\nsection $section  ; $segment\n";
      } else {
        die "fatal: unsupported WASM directive: $_\n" ;
      }
    } elsif (m@^(?:`([^\s:\[\],+\-*/()<>`]+)`|([^\s:\[\],+\-*/()<>`]+)):$@) {  # Label.
      $_ = (defined($1) ? $1 : $2) . ":";
      if ($rodata_strs and $segment eq "CONST") {
        push @$rodata_strs, "\$$_";
      } elsif (m@^__abitest_(.*?)_?:$@) {
        die "fatal: overlapping abitest ($lc): $_\n" if @abitest_insts;
        @abitest_insts = ($1);
        $do_hide_abitest = 1;
      } else {
        if ($do_hide_abitest) {  # It overlaps with code of another function.
          for (my $i = 1; $i < @abitest_insts; ++$i) {
            print $outfh "$abitest_insts[$i]\n";
          }
          $do_hide_abitest = 0;
        }
        if ($_ eq "_start_:" or $_ eq "_mainCRTStartup:") {  # Add extra start label for entry point.
          print $outfh "_start:\n";
          $$is_start_found_ref = 1;
        } elsif ($_ eq "_start:") {
          $$is_start_found_ref = 1;
        }
        print $outfh "\$$_\n";
      }
    } elsif (@abitest_insts) {
      die "fatal: incomplete abitest ($lc): $_\n" if @abitest_insts;
    } elsif (s@^(d[bwd])(?= )@@i) {
      my $cmd = lc($1);
      s@\boffset (?:FLAT:|DGROUP:)?@\$@g if !m@'@;
      my $count = 1;
      # Example: ` 0fH DUP(0,0,0,0,0,0,0,0)'.
      $count = (defined($1) ? ($1 + 0) : hex($2)) if
          s@^ (?:([0-9])|([0-9][0-9a-fA-F]*)[hH]) DUP\((.*)\)$@ $3@;
      while ($count--) {
        if (0 and $rodata_strs and $segment eq "CONST") {  # C string literals.
          push @$rodata_strs, $cmd . $_;
        } else {
          s@([\s:\[\],+\-*/()<>`])(?:([0-9][0-9a-fA-F]*)[hH]|(0|[1-9]\d*))@ defined($3) ? sprintf("%s0x%02x", $1, $3) : sprintf("%s0x%02x", $1, hex($2)) @ge;
          print $outfh "\t\t$cmd$_\n";
        }
      }
    } elsif (m@^(_TEXT|CONST2?|_DATA|_BSS) SEGMENT @) {
      $segment = $1;
      $section = $segment_to_section{$segment};
      print $outfh "\nsection $section  ; $segment\n";
      die "fatal: non-32-bit segment found: $_\n" if !m@ USE32 @;
    } elsif (m@^(\S+) ENDS$@) {
      die "fatal: unexpected segment end: $1\n" if $1 ne $segment;
    } elsif (m@^ORG @) {
      die "fatal: bad org instruction ($lc): $_\n" if
          !m@^ORG (?:([0-9])|([0-9][0-9a-fA-F]*)[hH])$@ or $section ne ".bss";
      my $delta_bss_org = (defined($1) ? ($1 + 0) : hex($2)) - $bss_org;
      die "fatal: .bss org decreasing ($lc): $_\n" if $delta_bss_org < 0;
      if ($delta_bss_org != 0) {
        print $outfh "\t\tresb $delta_bss_org\n";
      }
      $bss_org += $delta_bss_org;
    } elsif (m@^(?:`([^\s:\[\],+\-*/()<>`]+)`|([^\s:\[\],+\-*/()<>`]+)) LABEL BYTE$@ and $section eq ".bss") {
      my $label = defined($1) ? $1 : $2;
      print $outfh "\$$label:\n";
    } elsif (m@^end(?: ([^\s:\[\],+\-*/()<>`]+))?$@i) {
      $end_expr = $1;
      $is_end = 1;
    } elsif (m@^public (?:`([^\s:\[\],+\-*/()<>`]+)`|([^\s:\[\],+\-*/()<>`]+))$@i) {
      my $label = defined($1) ? $1 : $2;
      print $outfh "global \$$label\n";
    } elsif (m@^extrn (?:`([^\s:\[\],+\-*/()<>`]+)`|([^\s:\[\],+\-*/()<>`]+))(?::byte)?$@i) {
      # Example with backtick: EXTRN `__imp__GetStdHandle@4`:BYTE
      my $label = defined($1) ? $1 : $2;
      print $outfh "extern \$$label\n" if !$is_win32 or $label !~ m@\A__imp__@;
    } elsif (!length($_) or m@^DGROUP GROUP@ or m@^ASSUME @) {  # Ignore.
    } else {
      die "fatal: unsupported WASM instruction ($lc): $_\n" ;
    }
  }
  die "fatal: incomplete abitest ($lc): $_\n" if @abitest_insts;
  if (defined $end_expr) {
    print $outfh "\$_start equ $end_expr\n" if $end_expr ne "_start";
  }
}

sub convert_wasm_to_nasm($$$$$$) {
  my($wasmfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment) = @_;
  printf STDERR "info: converting WASM to NASM syntax to: $nasmfn\n";
  my $wasmfh;
  die "fatal: open for reading: $wasmfn: $!\n" if !open($wasmfh, "<", $wasmfn);  # TODO(pts): Unlink it on subsequent errors.
  my $nasmfh;
  die "fatal: open for writing: $nasmfn: $!\n" if !open($nasmfh, ">", $nasmfn);  # TODO(pts): Unlink it on subsequent errors.
  print_nasm_header($nasmfh, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
  my $is_win32 = 0;
  my $is_start_found = 0;
  my $lc = 0;
  my $first_line;
  my $do_merge_tail_strings = 1;  # TODO(pts): Make it configurable.
  my $rodata_strs = $do_merge_tail_strings ? [] : undef;
  wasm2nasm($wasmfh, $nasmfh, $first_line, $lc, $rodata_strs, $is_win32, \$is_start_found);
  print $nasmfh "\nsection .rodata\n" if $rodata_strs and @$rodata_strs;
  print_merged_strings_in_strdata($nasmfh, $rodata_strs, 0);
  print $nasmfh "\n; __END__\n";
  die "fatal: error writing NASM-assembly output\n" if !close($nasmfh);
  close($wasmfh);  # TODO(pts): Fail on write error;
}

# ---

sub convert_to_nasm($$$$$$) {
  my($cmd_arg, $srcfn, $basefn, $objfn, $nasmfn, $data_alignment) = @_;
  my $format = (detect_binary_format($objfn) or "unknown");
  die "fatal: unsupported object file format: $format\n" if $format ne "elf" and $format ne "omf";
  # May be kept undefined if no -march=... was found in @$cmd_arg.
  # `cpu prescott' would also work in NASM for $cpulevel > 6.
  my $nasm_cpu;
  for my $arg (@$cmd_arg) {
    $nasm_cpu = $1 if $arg =~ m@\A-march=i([3456]86)\Z(?!\n)@;
  }
  if ($format eq "elf") {
    my @cmdcs = @$cmd_arg;
    my $asfn = "$basefn.tmp.s";  # GNU as AT&T syntax. TODO(pts): Remove temporary file as part of cleanup (@unlink_fns).
    push @cmdcs, "-S", "-o", $asfn, $srcfn;  # TODO(pts): Don't run again, but do it before, as a temporary step, when generating $objfn.
    print STDERR "info: running compiler-to-as: ", join(" ", map { shargq($_) } @cmdcs), "\n";
    my $status = system(@cmdcs);
    die "fatal: error running compiler-to-as\n" if $status;
    my $format = (detect_binary_format($asfn) or "unknown");
    die "fatal: expeected as file format, got: $format\n" if $format ne "as";
    convert_as_to_nasm($asfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
    unlink($asfn);
  } else {
    my $wasmfn = "$objfn.tmp.wasm";  # TODO(pts): Remove temporary file as part of cleanup (@unlink_fns).
    my @wasmdis_cmd = ("wdis", "-a", argv_escape_fn($objfn));
    print STDERR "info: running wasmdis_cmd: @wasmdis_cmd >$wasmfn\n";
    {
      my $saveout;
      die if !open($saveout, ">&", \*STDOUT);
      die "fatal: open: $wasmfn: $!\n" if !open(STDOUT, ">", $wasmfn);
      die "fatal: wasmdis_cmd failed: @wasmdis_cmd\n" if system(@wasmdis_cmd);
      die if !open(STDOUT, ">&", $saveout);
      close($saveout);
    }
    convert_wasm_to_nasm($wasmfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
    unlink($wasmfn);
  }
}

# ---

my @oflags;
my @cflags;
my $srcfn;
my $is_owcc_enabled = 1;
my $data_alignment = 4;
{
  my $i = 0;
  while ($i < @ARGV) {
    my $arg = $ARGV[$i++];
    if ($arg eq "--") {
      last
    } elsif ($arg eq "-" or substr($arg, 0, 1) ne "-") {
      --$i;
      last
    } elsif ($arg eq "-mowcc") {
      $is_owcc_enabled = 1;
    } elsif ($arg eq "-mno-owcc") {
      $is_owcc_enabled = 0;
    } elsif ($arg =~ m@-malign=(.*)\Z(?!\n)@) {  # Data section alignment.
      my $value = $1;
      # Allowed values: 0, 1, 2, 4, 8, 16, 32.
      # Values larger than 32 are not supported by elf.inc.nasm.
      die "fatal: bad data alignment: $arg\n" if
          $value !~ m@\A(?:0|[1-9]\d{0,8})\Z(?!\n)@ or
          ($value = int($value)) > 32 or
          ($value & ($value - 1));
      $data_alignment = $value > 1 ? $value : 1;
    } elsif ($arg =~ m@\A-[DU][_A-Za-z]\w*\Z(?!\n)@) {
      push @cflags, $arg;
    } elsif ($arg =~ m@\A-O@) {
      push @oflags, $arg;
    } else {
      die "fatal: unknown flag: $arg\n";
    }
  }
  die "fatal: missing C source file\n" if $i >= @ARGV;
  die "fatal: too many source files, only one allowed\n" if $i > @ARGV + 1;
  $srcfn = $ARGV[$i];
}
my $basefn = $srcfn;
die "fatal: source file must be C source (*.c): $srcfn\n" if $basefn !~ s@[.]c\Z(?!\n)@@;

# ---

sub get_code_size_using_objdump($) {
  my $objfn = $_[0];
  my $objdumphwfn = "$objfn.tmp.objdumphw";  # TODO(pts): Remove temporary file as part of cleanup (@unlink_fns).
  my @objdumphw_cmd = ("objdump", "-h", "-w", argv_escape_fn($objfn));
  print STDERR "info: running objdumphw_cmd: @objdumphw_cmd >$objdumphwfn\n";
  {
    my $saveout;
    die if !open($saveout, ">&", \*STDOUT);
    die "fatal: open: $objdumphwfn: $!\n" if !open(STDOUT, ">", $objdumphwfn);
    die "fatal: objdumphw_cmd failed: @objdumphw_cmd\n" if system(@objdumphw_cmd);
    die if !open(STDOUT, ">&", $saveout);
    close($saveout);
  }
  my $fh;
  die "fatal: open for reading: $objdumphwfn: $!\n" if !open($fh, "<", $objdumphwfn);
  my $line;
  my $code_size = 0;
  while (defined($line = <$fh>)) {
    # Example $line: 0 .text           00000303  00000000  00000000  00000034  2**2  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
    if ($line =~ m@ *\d+ [.]text\S*[ \t]+([0-9a-fA-F]{8,})[ \t]@) {
      $code_size += hex($1);
    }
  }
  close($fh);
  die "fatal: code not found in object file: $objdumphwfn\n" if $code_size <= 0;
  unlink($objdumphwfn);
  $code_size
}

sub get_code_size_using_wdis($) {
  my $objfn = $_[0];
  my $wdisfn = "$objfn.tmp.wdis";  # TODO(pts): Remove temporary file as part of cleanup (@unlink_fns).
  my @wdis_cmd = ("wdis", argv_escape_fn($objfn));
  print STDERR "info: running wdis_cmd: @wdis_cmd >$wdisfn\n";
  {
    my $saveout;
    die if !open($saveout, ">&", \*STDOUT);
    die "fatal: open: $wdisfn: $!\n" if !open(STDOUT, ">", $wdisfn);
    die "fatal: wdis_cmd failed: @wdis_cmd\n" if system(@wdis_cmd);
    die if !open(STDOUT, ">&", $saveout);
    close($saveout);
  }
  my $fh;
  die "fatal: open for reading: $wdisfn: $!\n" if !open($fh, "<", $wdisfn);
  my $line;
  my $code_size = 0;
  while (defined($line = <$fh>)) {
    $line =~ s@\r?\n\Z(?!\n)@@;
    last if $line =~ m@^Segment: (\S+)@ and $1 ne "_TEXT";
    if ($line =~ m@\A([0-9A-F]+) ((?: [0-9A-F]{2})+)@) {  # Get size from hex dump line.
      my $code_size2 = hex($1) + int(length($2) / 3);
      die "fatal: size is unexpectedly decreasing\n" if $code_size2 <= $code_size;
      $code_size = $code_size2;
    }
  }
  close($fh);
  die "fatal: code not found in object file: $wdisfn\n" if $code_size <= 0;
  unlink($wdisfn);
  $code_size
}

my($best_code_size, $best_cmd_ary, $best_cmd_type, $best_objfn);

# Uses global variables: @oflags, @clflags, $srcfn, $basefn, $best_code_size, $best_cmd_ary, $best_cmd_type.
sub run_cmd($$) {
  my($cmd_ary, $cmd_type) = @_;  # TODO(pts): Do we even use $cmd_type here?
  die "fatal: unknown compiler command type: $cmd_type\n" if $cmd_type ne "gcc" and $cmd_type ne "owcc";
  my @cmd = @$cmd_ary;
  if (@oflags) {
    @cmd = grep { !m@\A-O@ } @cmd;
    push @cmd, @oflags;
  }
  push @cmd, @cflags;
  my @cmdco = @cmd;  # Command to generate object file from .c file.
  my $objfn = ($cmd_type eq "owcc") ? "$basefn.try.obj" : "$basefn.try.o";  # TODO(pts): Remove temporary file as part of cleanup.
  push @cmdco, "-c", "-o", $objfn, $srcfn;
  print STDERR "info: running compiler: ", join(" ", map { shargq($_) } @cmdco), "\n";
  my $status = system(@cmdco);
  die "fatal: error running compiler\n" if $status;
  my $format = (detect_binary_format($objfn) or "unknown");
  my $code_size = ($format eq "elf") ? get_code_size_using_objdump($objfn) :
      ($format eq "omf") ? get_code_size_using_wdis($objfn) : undef;
  die "fatal: unsupported object file format: $format\n" if !defined($code_size);
  printf STDERR "info: code size: 0x%x\n", $code_size;
  my $prev_best_objfn = $best_objfn;
  if (!defined($best_code_size) or $code_size < $best_code_size) {
    $best_code_size = $code_size;
    $best_cmd_ary = \@cmd;
    $best_cmd_type = $cmd_type;
    $best_objfn = $objfn;
    unlink($prev_best_objfn) if defined($prev_best_objfn) and $prev_best_objfn ne $objfn;
  }
}

# ---

# Most of these flags instruct GCC and other compilers to generate shorter (smaller) code.
my @gcc_flags = qw(-m32 -fno-pic -Os -march=i686 -W -Wall -Werror -U_FORTIFY_SOURCE -fno-stack-protector -fno-unwind-tables -fno-asynchronous-unwind-tables -falign-functions=1 -falign-jumps=1 -falign-loops=1 -mpreferred-stack-boundary=2 -fno-builtin -fno-ident);
my @clang_flags = qw(-m32 -fno-pic -Os -march=i686 -W -Wall -Werror -U_FORTIFY_SOURCE -fno-stack-protector -fno-unwind-tables -fno-asynchronous-unwind-tables -mstack-alignment=2 -fno-builtin -fno-ident);
my @gcc_cmds = (  # GCC and Clang C compilers.
    ["gcc", "-march=i386", "-fno-omit-frame-pointer", @gcc_flags],
    ["gcc", "-march=i686", "-fno-omit-frame-pointer", @gcc_flags],
    ["gcc", "-march=i386", "-fomit-frame-pointer", @gcc_flags],
    ["gcc", "-march=i686", "-fomit-frame-pointer", @gcc_flags],
    ["qq", "gcc-4.8", "-march=i386", "-fno-omit-frame-pointer", @gcc_flags],  # `gcc-4.8' generates shorter code than newer GCCs.
    ["qq", "gcc-4.8", "-march=i686", "-fno-omit-frame-pointer", @gcc_flags],
    ["qq", "gcc-4.8", "-march=i386", "-fomit-frame-pointer", @gcc_flags],
    ["qq", "gcc-4.8", "-march=i686", "-fomit-frame-pointer", @gcc_flags],
    ["clang", "-march=i386", "-fno-omit-frame-pointer", @clang_flags],
    ["clang", "-march=i686", "-fno-omit-frame-pointer", @clang_flags],
    ["clang", "-march=i386", "-fomit-frame-pointer", @clang_flags],
    ["clang", "-march=i686", "-fomit-frame-pointer", @clang_flags],
);
my @owcc_flags = qw(-blinux -fno-stack-check -march=i386 -mregparm=0 -W -Wall -Wextra -Werror);
my @owcc_cmds = (  # OpenWatcom C compiler. Good or optimizing for size.
    ["owcc", @owcc_flags],
    ["owcc", "-frerun-optimizer", @owcc_flags],
    ["owcc", "-floop-optimize", @owcc_flags],
    ["owcc", "-floop-optimize", "-frerun-optimizer", @owcc_flags],
);

$best_code_size = $best_cmd_ary = $best_cmd_type = undef;
print STDERR "info: running compilers to find best for: $srcfn\n";
for my $cmd_ary (@gcc_cmds) {
  run_cmd($cmd_ary, "gcc");
}
if ($is_owcc_enabled) {
  for my $cmd_ary (@owcc_cmds) {
    run_cmd($cmd_ary, "owcc");
  }
}
die "fatal: no compilers have been run\n" if !defined($best_code_size);
printf STDERR "info: found best code size is 0x%x bytes with %s command: %s\n",
    $best_code_size, $best_cmd_type, join(" ", map { shargq($_) } @$best_cmd_ary);
my $nasmfn = "$basefn.nasm";
convert_to_nasm($best_cmd_ary, $srcfn, $basefn, $best_objfn, $nasmfn, $data_alignment);
unlink($best_objfn);

__END__
