#!/bin/sh --
eval 'PERL_BADLANG=x;export PERL_BADLANG;exec perl -x "$0" "$@";exit 1'
#!perl  # Start marker used by perl -x.
+0 if 0;eval("\n\n\n\n".<<'__END__');die$@if$@;__END__

#
# soptcc.pl: size-optimizing C compiler frontend for i386
# by pts@fazekas.hu at Wed May 10 22:45:37 CEST 2023
#
# Runs multiple C compilers and picks the one which generates fewer (code)
# bytes. Emits a NASM source file (`nasm -f elf -O999999999'). Supports only
# i386 architecture (up to i686) with the cdecl calling convention
# (`gcc -mregparm=0' (default) and `owcc -mabi=cdecl').
#

BEGIN { $^W = 1 }
use integer;
use strict;

# ---

# Escapes filename as any shell command-line argument.
sub shargq($) {
  my $fnq = $_[0];
  if ($fnq !~ m@\A[-/+.,\w][-/+.,=\w]*\Z(?!\n)@) {
    $fnq =~ s@[\r\n]+@ @g;
    $fnq =~ s@'@'\\''@g;
    $fnq = "'$fnq'";
  }
  $fnq
}

# Escapes filename as non-flag shell command-line argument.
sub fnargq($) {
  my $fnq = $_[0];
  $fnq = "./$fnq" if $fnq =~ m@\A-@;
  return shargq($fnq);
}

sub argv_escape_fn($) {
  my $filename = $_[0];
  substr($filename, 0, 0) = "./" if $filename =~ m@-@;  # TODO(pts): Win32 compatibility.
  $filename
}

sub detect_binary_format($) {
  my $filename = $_[0];
  my $fh;
  die "fatal: open for reading: $filename: $!\n" if !open($fh, "<", $filename);
  my $hdr;
  die "fatal: read: $filename: $!\n" if !defined(sysread($fh, $hdr, 4));
  if ($hdr =~ m@\s*[.]@) {
    die "fatal: read more: $filename: $!\n" if !defined(sysread($fh, $hdr, 32, length($hdr)));
    close($fh);
    if ($hdr =~ m@\A\s*[.](?:model\s|38[67])@i) {
      return "wasm";
    #} elsif (m@\A\s*(?:bits\s|cpu\s|section\s|%)@i) {
    #  return "nasm";
    } else {
      return "as";
    }
  }
  close($fh);
  if (!length($hdr)) {
    return "empty";
  } elsif ($hdr =~ m@\A\x7fELF@) {
    return "elf";  # Can be program (executable), object (relocatable) etc.
  } elsif ($hdr =~ m@\AMZ@) {
    return "exe";
  } elsif ($hdr =~ m@\A\x80@) {  # OMF .obj object file generated by e.g. OpenWatcom.
    return "omf";
  } elsif ($hdr =~ m@\A\x4c\x01@) {  # COFF .obj obect file used on Win32.
    return "coff";
  } elsif ($hdr =~ m@\A(?:\xfe\xed\xfa[\xce|\xcf]|[\xce\xcf]\xfa\xed\xfe)@) {
    return "macho";  # Can  be executable, object etc.
  }
  undef  # die "fatal: unknown file format: $filename\n";
}

sub print_nasm_header($$$$$$) {
  my($nasmfh, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment) = @_;
  print $nasmfh "; .nasm source file generated by soptcc.pl\n; from $srcfn\n",
                "; Compile to i386 ELF .o object: nasm -O999999999 -w+orphan-labels -f elf -o " . fnargq("$basefn.o") . " " . fnargq($nasmfn) . "\n\n",
                "bits 32\n";
  # %ifidn __OUTPUT_FORMAT__, elf
  print $nasmfh "cpu $nasm_cpu\n" if $nasm_cpu;
  print $nasmfh "section .text align=1\n",
                "section .rodata align=$data_alignment\n",
                "section .data align=$data_alignment\n",
                "section .bss align=$data_alignment\n\n";
  #print $nasmfh "\nsection .text\n";  # asm2nasm(...) will print it.
}

# --- Merge C string literal by tail (e.g. merge "bar" and "foobar").

# Merge C string literal by tail (e.g. merge "bar" and "foobar").
#
# $outfh is the filehandle to write NASM assembly lines to.
#
# $rodata_strs is a reference to an array containing assembly source lines
# (`label:' and `db: ...') in `section .rodata', `section .rdata' and
# `section .rodata.str1.1' (GCC, GNU as; already
# converted to db) or `CONST SEGMENT' (OpenWatcom WASM). It will be cleared
# as a side effect.
#
# TODO(pts): Deduplicate strings in .nasm source as well.
sub print_merged_strings_in_strdata($$$) {
  my($outfh, $rodata_strs, $is_db_canonical_gnu_as) = @_;
  return if !$rodata_strs or !@$rodata_strs;
  # Test data: my $strdata_test = "foo:\ndb 'ello', 0\ndb 0\ndb 'oth'\nmer:\ndb 'er', 1\ndb 2\ndb 0\ndb 3\ndb 0\ndb 4\ndb 'hell'\nbar:\ndb 'o', 0\nbaz:\ndb 'lo', 0, 'ello', 0, 'hell', 0, 'foo', ', ', 0, 15, 3, 0\nlast:";  @$rodata_strs = split(/\n/, $strdata_test);
  my $ofs = 0;
  my @labels;
  my $strdata = "";
  for my $str (@$rodata_strs) {
    if ($str =~ m@\A\s*db\s@i) {
      pos($str) = 0;
      if ($is_db_canonical_gnu_as) {  # Shortcut.
        while ($str =~ m@\d+|'([^']*)'@g) { $ofs += defined($1) ? length($1) : 1 }
        $strdata .= $str;
        $strdata .= "\n";
      } else {
        die if $str !~ s@\A\s*db\s+@@i;
        my $str0 = $str;
        my $has_error = 0;
        # Parse and canonicalize the db string, so that we can transform it later.
        $str =~ s@(-?)0[xX]([0-9a-fA-F]+)|(-?)([0-9][0-9a-fA-F]*)[hH]|(-?)(0(?!\d)|[1-9][0-9]*)|('[^']*')|(\s*,\s*)|([^\s',]+)@
          my $v;
          if (defined($1) or defined($3) or defined($5)) {
            ++$ofs;
            $v = defined($1) ? ($1 ? -hex($2) : hex($2)) & 255 :
                 defined($3) ? ($3 ? -hex($4) : hex($4)) & 255 :
                 defined($5) ? ($5 ? -int($6) : int($6)) & 255 : undef;
            ($v >= 32 and $v <= 126 and $v != 0x27) ? "'" . chr($v) . "'" : $v
          } elsif (defined($7)) { $ofs += length($7) - 2; $7 }
          elsif (defined($8)) { ", " }
          else { $has_error = 1; "" }
        @ge;
        die "fatal: arg: syntax error in string literal db: $str0\n" if $has_error;
        #$str =~ s@', '@@g;  # This is incorrect, e.g. db 1, ', ', 2
        $strdata .= "db $str\n";
      }
    } elsif ($str =~ m@\s*([^\s:,]+)\s*:\s*\Z(?!\n)@) {
      push @labels, [$ofs, $1];
      #print STDERR ";;old: $1 equ strs+$ofs\n";
    } elsif ($str =~ m@\S@) {
      die "fatal: arg: unexpected string literal instruction: $str\n";
    }
  }
  # $strdata already has very strict syntax (because we have generated its
  # dbs), so we can do these regexp substitutions below safely.
  $strdata =~ s@([^:])\ndb @$1, @g;
  $strdata = "db " if !length($strdata);
  die "fatal: assert: missing db" if $strdata !~ m@\Adb@;
  die "fatal: assert: too many dbs" if $strdata =~ m@.db@s;
  $strdata =~ s@^db @db , @mg;
  $strdata =~ s@, 0(?=, )@, 0\ndb @g;  # Split lines on NUL.
  my $ss = 0;
  while (length($strdata) != $ss) {  # Join adjacent 'chars' arguments.
    $ss = length($strdata);
    $strdata =~ s@'([^']*)'(?:, '([^']*)')?@ my $x = defined($2) ? $2 : ""; "'$1$x'" @ge;
  }
  chomp($strdata);
  @$rodata_strs = split(/\n/, $strdata);
  my @sorteds;
  {
    my $i = 0;
    for my $str (@$rodata_strs) {
      my $rstr = reverse($str);
      substr($rstr, -3) = "";  # Remove "db ".
      substr($rstr, 0, 3) = "";  # Remove "0, ".
      $rstr =~ s@' ,\Z@@;
      push @sorteds, [$rstr, $i];
      ++$i;
    }
  }
  @sorteds = sort { $a->[0] cmp $b->[0] or $a->[1] <=> $b->[1] } @sorteds;
  my %mapi;
  for (my $i = 0; $i < $#sorteds; ++$i) {
    my $rstri = $sorteds[$i][0];
    my $rstri1 = $sorteds[$i + 1][0];
    if (length($rstri1) >= length($rstri) and substr($rstri1, 0, length($rstri)) eq $rstri) {
      $mapi{$sorteds[$i][1]} = $sorteds[$i + 1][1];
    }
  }
  my @ofss;
  my @oldofss;
  #%mapi = ();  # For debugging: don't merge anything.
  {
    my $i = 0;
    my $ofs = 0;
    my $oldofs = 0;
    my @sizes;
    for my $str (@$rodata_strs) {
      pos($str) = 0;
      my $size = 0;
      while ($str =~ m@\d+|'([^']*)'@g) { $size += defined($1) ? length($1) : 1 }
      push @sizes, $size;
      push @oldofss, $oldofs;
      $oldofs += $size;
      if (exists($mapi{$i})) {
        my $j = $mapi{$i};
        $j = $mapi{$j} while exists($mapi{$j});
        $mapi{$i} = $j;
        #print STDERR ";$i: ($str) -> ($rodata_strs->[$j]}\n";
        push @ofss, undef;
      } else {
        push @ofss, $ofs;
        $ofs += $size;
        #print STDERR "$str\n";
      }
      ++$i;
    }
    if (%mapi) {
      for ($i = 0; $i < @$rodata_strs; ++$i) {
        my $j = $mapi{$i};
        $ofss[$i] = $ofss[$j] + $sizes[$j] - $sizes[$i] if defined($j) and !defined($ofss[$i]);
      }
    }
    push @ofss, $ofs;
    push @oldofss, $oldofs;
  }
  {
    for my $str (@$rodata_strs) {
      die "fatal: assert: missing db-comma\n" if $str !~ s@\Adb , @db @;  # Modify in place.
      # !! if TODO(pts): length($str) > 500, then split to several `db's.
      $str .= "\n";
    }
    #print $outfh "section .rodata\n";  # Printed by the caller.
    print $outfh "__strs:\n";
    my $i = 0;
    my $pi = 0;
    for my $pair (@labels) {
      my($lofs, $label) = @$pair;
      ++$i while $i + 1 < @oldofss and $oldofss[$i + 1] <= $lofs;
      die "fatal: assert: bad oldoffs\n" if $i >= @oldofss;
      my $ofs = $lofs - $oldofss[$i] + $ofss[$i];
      for (; $pi < $i; ++$pi) {
        #print STDERR "$rodata_strs->[$pi]\n" if !exists($mapi{$pi});
        print $outfh "\t\t", $rodata_strs->[$pi] if !exists($mapi{$pi});
      }
      if ($lofs != $oldofss[$i] or exists($mapi{$i})) {
        if (exists($mapi{$i})) {
          # !! TODO(pts): Find a later (or earlier), closer label, report relative offset there.
          print $outfh "$label equ __strs+$ofs  ; old=$lofs\n";
        } else {
          my $dofs = $lofs - $oldofss[$i];
          #print STDERR "$label equ \$+$dofs\n";
          print $outfh "$label equ \$+$dofs\n";
        }
      } else {
        #print STDERR "$label:\n";
        print $outfh "$label:\n";
      }
    }
    for (; $pi < @$rodata_strs; ++$pi) {
      #print STDERR "$rodata_strs->[$pi]\n" if !exists($mapi{$pi});
      print $outfh "\t\t", $rodata_strs->[$pi] if !exists($mapi{$pi});
    }
  }
  @$rodata_strs = ();
}

# ---

sub print_commons($$$) {
  my($outfh, $common_by_label, $define_when_defined) = @_;
  return if !%$common_by_label;
  my @commons2;
  for my $label (sort(keys(%$common_by_label))) {
    die "fatal: assert: common value syntax\n" if $common_by_label->{$label} !~ m@\A(\d+):(\d+)\Z(?!\n)@;
    push @commons2, [$label, $1 + 0, $2 + 0];
  }
  # (alignment decreasing, size decreasing, name lexicographically increasing).
  @commons2 = sort { $b->[2] <=> $a->[2] or $b->[1] <=> $a->[1] or $a->[0] cmp $b->[0] } @commons2;
  print $outfh "\nsection .bss  ; common\n";
  # NASM 0.98.39 and 0.99.06 report phase errors with if the .nasm file
  # contains forward-referenced `common' directives, even without the equ
  # hack below. It works with NASM 2.13.02, but only without the `equ'
  # hack: with `equ' it's Segmentation fault when running.
  #
  # Thus we emit the .bss manually even for `nasm -f elf'. Thus, without
  # the `common', it's not possible for many .c source file to say `int
  # var;'. One of them must have `int var;', the others must have `extern
  # int var;'.
  if (0) {
    print $outfh "%ifidn __OUTPUT_FORMAT__, elf\n";
    for my $tuple (@commons2) {
      my($label, $size, $alignment) = @$tuple;
      #print $outfh "common $label $size:$alignment\n";
      #if (exists($define_when_defined{$label})) {
      #  my $label1 = $define_when_defined{$label};
      #  print $outfh "$label1 equ $label\n";
      #}
      if (exists($define_when_defined->{$label})) {
        my $label1 = $define_when_defined->{$label};
        #print $outfh "$label1 equ $label\n";
        print $outfh "common $label1 $size:$alignment\n";
      } else {
        print $outfh "common $label $size:$alignment\n";
      }
    }
    print $outfh "%else  ; ifidn __OUTPUT_FORMAT__, elf\n";
  }
  for my $tuple (@commons2) {
    my($label, $size, $alignment) = @$tuple;
    print $outfh "alignb $alignment\n" if $alignment > 1;
    my $sizex = sprintf("0x%x", $size);
    print $outfh "$label: resb $sizex  ; align=$alignment\n";
    if (exists($define_when_defined->{$label})) {
      my $label1 = $define_when_defined->{$label};
      print $outfh "$label1 equ $label\n";
    }
  }
  if (0) {
    print $outfh "%endif ; ifidn __OUTPUT_FORMAT__, elf\n";
  }
}

# --- Assembly syntax onversion helpers.

my %gp_regs = map { $_ => 1 } qw(al cl dl bl ah ch dh bh ax cx dx bx sp bp si di eax ecx edx ebx esp ebp esi edi);

my %shift_instructions = map { $_ => 1 } qw (rcl rcr rol ror sal sar shl shr);

# --- Convert from GNU as (AT&T) syntax to NASM.

# !! Was fuzz2.pl complete? Why not jb, jl, cmpxchg8b, fcmovl, prefetchw?
my %force_nosize_insts = map { $_ => 1 } qw(
    arpl call cmovb cmovnb cmovl cmovnl fldcw fnstcw fnstsw fstcw fstsw imul
    lmsw lsl mul rcl rol sbb setb setl shl smsw sub verw jb jnb jl jnl
    cmpxchg8b lcall fcmovb fcmovnb prefetchw syscall cbw iretw popaw popfw
    pushaw pushfw fisttpll fmul fsub setl setnl setb setnb);

# All floating point instructions with memory argument (m32fp, m64fp, m80fp).
my %fp_memarg_insts = ("fldt" => 1, "fstpt" => 1, map { $_ . "s" => 1, $_ . "l" => 1 } qw(fld fst fstp fmul fdiv fdivr fadd fsub fsubr fcom fcomp));

my %nosize_arg_insts = map { $_ => 1 } qw(lea lds les lfs lgs lss lgdt lidt sgdt sidt fmul);

my %prefix_insts = map { $_ => 1 } qw(cs ds es fs gs lock rep repe repne repnz repz ss wait);

my %str_arg_insts = map { $_ => 1 } qw(ins outs lods stos movs cmps scas);

# fdivp--fdivrp and fsubp--fsubrp instructions are swapped depending on
# their arguments, so we handle that separately.
#
# * NASM 0.98.39 == NASM 2.13.02 == FASM 1.73.30 == https://www.felixcloutier.com/x86/fsub:fsubp:fisub
# * GNU as 2.30 == GNU binutils 2.30 == GCC 7.5.0 == GCC 12.2.
my %inst_map = qw(fiadds fiaddw ficoms ficomw ficomps ficompw fidivs fidivw
    fidivrs fidivrw filds fildw fimuls fimulw fists fistw fistps fistpw
    fisttps fisttpw  fisubs fisubw  fisubrs fisubrw
    cbtw cbw  cltd cdq  cwtd cwd  cwtl cwde);

my %mov_extend_insts = map { $_ => 1 } qw(movsb movsw movzb movzw);

my %shift_insts = map { $_ => 1 } qw(rcl rcr rol ror shl sar shl shr);

my %special_arg_insts = (map { $_ => 1 } qw(bound enter lcall ljmp in out nop
    lar lsl monitor mwait movzx movsx fisttpll fisttp),
    keys(%str_arg_insts), keys(%shift_insts));

my %reg32_to_index = ('eax' => 0, 'ecx' => 1, 'edx' => 2, 'ebx' => 3, 'esp' => 4, 'ebp' => 5, 'esi' => 6, 'edi' => 7);

my %as_string_escape1 = ("b" => "\x08", "f" => "\x0c", "n" => "\x0a", "r" => "\x0d", "t" => "\x09", "v" => "\x0b");

my %divdi3_labels = map { $_ => 1 } qw(F___divdi3 F___udivdi3 F___moddi3 F___umoddi3);

sub fix_label($$$$;$) {
  my($label, $bad_labels, $used_labels, $local_labels, $skip_mark_as_used) = @_;
  if ($label =~ m@\A[.]L(\w+)\Z(?!\n)@) {  # Typically: .L1 and .LC0
    $label = "L_$1";
  } elsif ($label =~ m@\A__imp__[a-zA-Z_\@?][\w.\@?\$~#]*\Z(?!\n)@) {  # DLL import function pointer. Must always be global.
    # Keep it.
  } elsif ($label =~ m@\A([a-zA-Z_\@?][\w.\@?\$~#]*)\Z(?!\n)@) {  # Match NASM label.
    my $label2 = "S_$1";
    $label = exists($local_labels->{$label2}) ? $label2 : "F_$1";
  } else {
    push @$bad_labels, $label;
    return "?";
  }
  $used_labels->{$label} = 1 if !$skip_mark_as_used;
  $label
}

sub fix_labels($$$$) {
  my($s, $bad_labels, $used_labels, $local_labels) = @_;
  die if !defined($s);
  $s =~ s~([0-9][0-9a-zA-Z]*)|([.a-zA-Z_\@?][\w.\@?\$\~#]*)~ my $s2 = $2; my $label; defined($1) ? $1 : fix_label($2, $bad_labels, $used_labels, $local_labels) ~ge;
  $s
}

sub fix_ea($$$$$$) {
  my ($segreg, $displacement, $regs, $bad_labels, $used_labels, $local_labels) = @_;
  # We could remove whitespace from $displacement and $regs, but we don't care.
  $regs =~ y@% @@d;
  $regs =~ s@,@+@;  # Only the first ','.
  $regs =~ s@,@*@;  # Only the second ','.
  # We could do more syntax checks here.
  if ($displacement =~ m@[^ ]@) {
    $displacement = "+" . $displacement if length($regs) and $displacement !~ m@\A-(?:0[xX][0-9a-fA-F]+|0|[1-9]\d*)\Z(?!\n)@;
    $displacement = fix_labels($displacement, $bad_labels, $used_labels, $local_labels);
  }
  $segreg = (defined($segreg) and length($segreg)) ? "$segreg:" : "";
  $segreg = "" if ($segreg eq "ss:" and $regs =~ m@bp@) or ($segreg eq "ds:" and $regs !~ m@bp@);  # Remove superfluous segment prefix. GNU as does it by default, NASM 0.98.39 doesn't.
  "[$segreg$regs$displacement]"
}

sub fix_reg($) {
  my $reg = $_[0];
  return "st0" if $reg eq "st";
  $reg =~ s@\Ast\((\d+)\)\Z(?!\n)@st$1@;
  $reg
}

# Converts GNU as syntax to NASM 0.98.39 syntax, Supports only a small
# subset of GNU as syntax, mostly the one generated by GCC, but some
# hand-written .as files also work.
#
# !! Rename local labels (L_* and also non-.globl F_) by file: L1_* F2_*.
# !! fildq  ->  fild qword [...]
sub as2nasm($$$$$$$$$$) {
  my($srcfh, $outfh, $first_line, $lc, $rodata_strs, $is_win32, $undefineds, $define_when_defined, $common_by_label, $is_start_found_ref) = @_;
  my %unknown_directives;
  my $errc = 0;
  my $is_comment = 0;
  my $do_omit_call_to___main = 0;
  my $section = ".text";
  my @abitest_insts;  # Label and list of instructions being buffered.
  my $used_labels = {};
  my %defined_labels;
  my %externs;
  my %local_labels;
  my %global_labels;
  print $outfh "\nsection $section\n";
  while (defined($first_line) or defined($first_line = <$srcfh>)) {
    ++$lc;
    ($_, $first_line) = ($first_line, undef);
    if ($is_comment) {
      next if !s@\A.*[*]/@@s;  # End of multiline comment.
      $is_comment = 0;
    }
    y@[\r\n]@@;
    if (m@/[*]@) {
      if (m@"@) {
        s@/[*].*?[*]/|("(?:[^\\"]+|\\.)*")@ defined($1) ? $1 : " " @sge;
        s@/[*].*|("(?:[^\\"]+|\\.)*")@ $is_comment = 1 if !defined($1); defined($1) ? $1 : "" @sge;
      } else {  # Easier.
        s@/[*].*?[*]/@ @sg;
        $is_comment = 1 if s@/[*].*@@s;  # Start of multiline comment.
      }
    } elsif (m@"@) {
    } else {
      s@#.*@@;
    }
    s@\A[\s;]+@@;
    s@[\s;]+\Z(?!\n)@@;
    if (!m@"@) {
      s@\s+@ @g;
    } else {
      s@\s+|("(?:[^\\"]+|\\.)*")@ defined($1) ? $1 : " " @ge;  # Keep quoted spaces intact.
    }
    if (m@;@) {
      if (m@\A[.]def ([^\s:,;]+) *; *[.]scl (?:(\d+)[; ])?@) {
        # Example from MinGW: .def	_mainCRTStartup;	.scl	2;	.type	32;	.endef
        if (defined($2) and $2 eq "2") {
          $_ = "";  # Global or extern symbol $1, keep it.
          $do_omit_call_to___main = 1 if $1 eq "___main";  # MinGW GCC 4.8.2.
        } else {
          $_ = ".type $1," if !defined($2) or $2 ne "2";  # Will make it implicitly local below.
        }
      } else {
        my $has_err = 0;
        if (m@"@) {
          s@;.*|("(?:[^\\"]+|\\.)*")@ $has_err = 1 if !defined($1); defined($1) ? $1 : "" @sge;
        } else {
          s@;.*@@s;
          $has_err = 1;
        }
        if ($has_err) {
          ++$errc;
          # TODO(pts): Support multiple instructions per line.
          print STDERR "error: multiple instructions per line, all but the first ignored ($lc): $_\n";
        }
      }
    }
    next if !length($_);
    my @bad_labels;
    if (s@\A([^\s:,]+): *@@) {
      if (!length($section)) {
        ++$errc;
        print STDERR "error: label outside section ($lc): $_\n";
      }
      my $label = $1;
      # GCC 7.5.0 without `-fno-unwind-tables -fno-asynchronous-unwind-tables' emits .LFB0: ... .LFE0: for functions. We don't need these labels.
      next if $label =~ m@\A[.]LF[BE]@;
      $label = fix_label($label, \@bad_labels, $used_labels, \%local_labels);
      if (length($section) == 1) {
        if ($label =~ m@\A(?:L_C|F_LC)@) {  # Label for string literal, e.g. .LC0 (GCC 7.5 on Linux) or LC0 (MinGW GCC 4.8.2).
          push @$rodata_strs, "$label:";
        } else {
          $section = ".rodata";
          print $outfh "$label:\n";
        }
      } elsif ($label =~ m@\A[SF]___+abitest_(.*)\Z@ and $section eq ".text") {  # Emitted by libc.h. Typically it's S_ because of static.
        @abitest_insts = ($1);
        $defined_labels{$label} = 1;
      } else {
        print $outfh "$label:\n";
        if ($label eq "F__start" or $label eq "F__mainCRTStartup") {  # !! TODO(pts): Indicate the entry point smarter.
          print $outfh "_start:\n";
          $$is_start_found_ref = 1;
        }
      }
      $defined_labels{$label} = 1;
      if (exists($define_when_defined->{$label})) {
        my $label1 = $define_when_defined->{$label};
        print $outfh "$label1 equ $label\n";
        $defined_labels{$label1} = 1;
      }
    }
    if (m@\A[.]@) {
      if (@abitest_insts) {
        if (!m@[.]cfi_@) {
          ++$errc;
          print STDERR "error: incomplete abitest ($lc): $_\n";
          @abitest_insts = ();
        }
      }
      if (m@\A[.](?:file "|size |loc |cfi_|ident ")@) {
        # Ignore this directive (.file, .size, .type).
      } elsif (m@\A([.](?:text|data|rodata))\Z@) {
        $section = $1;
        print $outfh "section $section\n";
      } elsif (m@\A[.]type ([^\s:,]+),.*\Z@) {  # Example: .type main, @function
        # If there is a .def or .type before a .globl for that label, then
        # declare it as local.
        my $label = fix_label($1, \@bad_labels, $used_labels, \%local_labels, 1);
        if (exists($defined_labels{$label})) {
          ++$errc;
          print STDERR "error: label defined before implicit local ($lc): $label\n";
        }
        if ($label =~ m@\AL_@) {
          ++$errc;
          print STDERR "error: local-prefix label cannot be declared implicit local ($lc): $label\n";
        } elsif ($label =~ m@\A__imp__@) {
          ++$errc;
          print STDERR "error: __imp__-prefix label cannot be declared implicit local ($lc): $label\n";
        } elsif (exists($global_labels{$label}) or exists($externs{$label})) {  # Must start with F_ or __imp__.
          # No-op.
        } elsif ($label =~ m@\AF_@ and exists($used_labels->{$label})) {
          my $label2 = $label;
          die if $label2 !~ s@\AF_@S_@;
          $define_when_defined->{$label2} = $label;
          if (exists($defined_labels{$label2})) {
            print $outfh "$label equ $label2\n";
            $defined_labels{$label} = 1;
          } else {
            # TODO(pts): Do an initial scanning pass to avoid this workaround. The workaround won't work for multiple input files with conflicting local labels.
            $define_when_defined->{$label2} = $label;
          }
          $local_labels{$label2} = 1;
          $used_labels->{$label2} = 1;
        } else {
          die "fatal: assert: bad implicit local label: $label\n" if $label !~ s@\A[FS]_@S_@;
          $local_labels{$label} = 1;
        }
      } elsif (m@\A[.]globa?l ([^\s:,]+)\Z@) {
        # GCC 7.5.0 emits `.globl __udivdi3', but no `.globl' for other
        # extern functions. So in the NASM output we end up with both
        # `global __udivdi3' and `extern __udivdi3'. That's fine, even for
        # `nasm -f elf'.
        my $label = fix_label($1, \@bad_labels, $used_labels, \%local_labels, 1);
        print $outfh "global $label\n" if !exists($divdi3_labels{$label});
        print $outfh "global _start\n" if $label eq "F__start" or $label eq "F__mainCRTStartup";  # !! TODO(pts): Indicate the entry point smarter.
        if (exists($defined_labels{$label})) {
          ++$errc;
          print STDERR "error: label defined before .global ($lc): $label\n";
        }
        if ($label =~ m@\AL_@) {
          ++$errc;
          print STDERR "error: local-prefix label cannot be declared .global ($lc): $label\n";
        } elsif ($label =~ m@\AS_@ and exists($used_labels->{$label}) and ($local_labels{$label} or 0) == 1) {
          # Clang 6.0.0 defines label as .local after referring to it.
          my $label2 = $label;
          die if $label2 !~ s@\AS_@F_@;
          $define_when_defined->{$label2} = $label;
          if (exists($defined_labels{$label2})) {
            print $outfh "$label equ $label2\n";
            $defined_labels{$label} = 1;
          } else {
            # TODO(pts): Do an initial scanning pass to avoid this workaround. The workaround won't work for multiple input files with conflicting local labels.
            $define_when_defined->{$label2} = $label;
          }
          delete $local_labels{$label2};
          $used_labels->{$label2} = 1;
        } elsif ($label =~ m@\AS_@) {
          ++$errc;
          print STDERR "error: label already .local before .global ($lc): $label\n";
        } else {
          $global_labels{$label} = 1;
        }
      } elsif (m@\A[.]local ([^\s:,]+)\Z@) {
        my $label = fix_label($1, \@bad_labels, $used_labels, \%local_labels, 1);
        if (exists($defined_labels{$label})) {
          ++$errc;
          print STDERR "error: label defined before .local ($lc): $label\n";
        }
        if ($label =~ m@\AL_@) {
          ++$errc;
          print STDERR "error: local-prefix label cannot be declared .local ($lc): $label\n";
        } elsif ($label =~ m@\A__imp__@) {
          ++$errc;
          print STDERR "error: __imp__-prefix label cannot be declared .local ($lc): $label\n";
        } elsif (exists($global_labels{$label})) {  # Must start with F_ or __imp__.
          ++$errc;
          print STDERR "error: label already .global before .local ($lc): $label\n";
        } elsif (exists($externs{$label})) {
          ++$errc;
          print STDERR "error: label already .extern before .local ($lc): $label\n";
        } elsif ($label =~ m@\AF_@ and exists($used_labels->{$label})) {
          #++$errc;
          #print STDERR "error: label already used as non-.local before .local ($lc): $label\n";
          my $label2 = $label;
          die if $label2 !~ s@\AF_@S_@;
          $define_when_defined->{$label2} = $label;
          if (exists($defined_labels{$label2})) {
            print $outfh "$label equ $label2\n";
            $defined_labels{$label} = 1;
          } else {
            # TODO(pts): Do an initial scanning pass to avoid this workaround. The workaround won't work for multiple input files with conflicting local labels.
            $define_when_defined->{$label2} = $label;
          }
          $local_labels{$label2} = 1;
          $used_labels->{$label2} = 1;
        } else {
          die "fatal: assert: bad .local label: $label\n" if $label !~ s@\A[FS]_@S_@;
          $local_labels{$label} = 2;
        }
        print $outfh ";local $label\n";  # NASM doesn't need it.
      } elsif (m@\A[.]section [.]text[.](?:unlikely|startup) *(?:,|\Z)@) {
        # GCC puts main to .text.startup.
        # !! What is .text.unlikely?
        $section = ".text";  # !! Any better?
        print $outfh "section $section\n";
      } elsif (m@\A[.]section [.]ro?data(?:[.]str[.a-z0-9]*|[.]cst4|[.]cst8)?(?:\Z|\s*,)@) {
        # Example $_ for MinGW: .section .rdata,"dr"
        # Example $_: .section .rodata.cst4,"aM",@progbits,4  Floating-point constants.
        # Example $_: .section .rodata.cst8,"aM",@progbits,8  64-bit floating-point constants.
        # Example $_: .section .rodata.str1.1,...
        if ($rodata_strs) {
          $section = "S";
          print $outfh "section .rodata\n";
        } else {
          $section = ".rodata";
          print $outfh "section $section\n";
        }
      } elsif (m@\A[.]section \"?[.]note[.]GNU-stack\"?[,]@) {
        # Non-executable stack marker: .section .note.GNU-stack,"",@progbits
        # Example: .section ".note.GNU-stack","",@progbits
        # !! respect it.
        $section = "";
      } elsif (m@\A[.]extern ([^\s:,]+)\Z@) {  # GCC doesn't write these.
        my $label = fix_label($1, \@bad_labels, $used_labels, \%local_labels, 1);
        if ($label =~ m@\AL_@) {
          ++$errc;
          print STDERR "error: local-prefix label cannot be declared .extern ($lc): $label\n";
        } elsif ($label =~ m@\AS_@) {
          ++$errc;
          print STDERR "error: label already .local before .extern ($lc): $label\n";
        } else {
          die "fatal: assert: bad .extern label: $label\n" if $label !~ m@\AF_@;
          $externs{$label} = 1;
        }
      } elsif (m@\A[.]comm ([^\s:,]+), *(0|[1-9]\d*), *(0|[1-9]\d*)\Z@) {
        if (!length($section)) {
          ++$errc;
          print STDERR "error: .comm outside section ($lc): $_\n";
        } else {
          # !! TODO(pts): Do a proper rearrangement of .comm within .bss based on alignment.
          my ($size, $alignment) = ($2 + 0, $3 + 0);
          if ($alignment & ($alignment - 1)) {
            ++$errc;
            print STDERR "error: alignment value not a power of 2 ($lc): $_\n";
            $alignment = 1;
          } elsif ($alignment < 2) {
            $alignment = 1;
          } elsif ($alignment > 4) {
            # See the comments at .align why.
            print STDERR "warning: alignment value larger than 4 capped to 4 ($lc): $_\n" if $alignment > 4;
            $alignment = 4;
          }
          my $label = fix_label($1, \@bad_labels, $used_labels, \%local_labels, 1);
          $defined_labels{$label} = 1;
          my $value = "$size:$alignment";
          if (!exists($common_by_label->{$label})) {
            $common_by_label->{$label} = $value;
          } elsif ($common_by_label->{$label} ne $value) {
            ++$errc;
            print STDERR "error: common mismatch for $label, latter ignored: $common_by_label->{$label} vs $value\n";
          }
        }
      } elsif (m@\A[.](p2)?align (0|[1-9]\d*)\Z@ ) {
        if (!length($section)) {
          ++$errc;
          print STDERR "error: .align outside section ($lc): $_\n";
        } elsif ($section eq ".bss") {
          # We'd need `alignb'. Does it make sense? We don't even support .bss directly.
          print STDERR "error: .align in .bss ignored ($lc): $_\n" if !exists($unknown_directives{".align/bss"});
          $unknown_directives{".align/bss"} = 1;
        } elsif ($1 and $2 > 16) {
          ++$errc;
          print STDERR "error: .p2align too large ($lc): $_\n";
        } else {
          my $alignment = $1 ? (1 << $2) : $2 + 0;
          $section = ".rodata" if length($section) == 1;  # Not a string literal.
          if ($alignment & ($alignment - 1)) {
            ++$errc;
            print STDERR "error: alignment value not a power of 2 ($lc): $_\n";
          } elsif ($alignment > 1) {
            # For some global variables (especially char arrays), GCC
            # generates `.align 32'. It doesn't make sense, the user should
            # add __attribute__((aligned(4))) to the declaration.
            print STDERR "warning: alignment value larger than 4 capped to 4 ($lc): $_\n" if $alignment > 4;
            # Also we'd need to increase $data_alignment for elf.inc.nasm
            # for $alignment > 4 to make any sense, and it's too late for
            # that.
            #
            # !! TODO(pts): Do an initial scan for .align and .comm, and
            # then set $data_alignment to 4, 8, 16 or 32. elf.inc.nasm
            # supports up to 32 for ELF-32.
            $alignment = 4 if $alignment > 4;
            my $inst = ($section eq ".text") ? "nop" : "db 0";
            print $outfh "align $alignment, $inst\n";
            #print STDERR "warning: align ignored ($lc): $_\n" if !exists($unknown_directives{".align"});  # !!
            #$unknown_directives{".align"} = 1;
          }
        }
      } elsif (m@\A[.](byte|value|long|quad) (\S.*)\Z@) {  # floating-point data?
        my $inst1 = $1;
        my $expr = fix_labels($2, \@bad_labels, $used_labels, \%local_labels);
        $expr = " $expr";
        die "fatal: 32-bit Perl not supported for .quad\n" if $inst1 eq "quad" and (1<<16<<16) == 0;
        $expr =~ s@([\s:\[\],+\-*/()<>`])(?:0x([0-9a-fA-F]+)|(0|[1-9]\d*))@ defined($3) ? sprintf("%s0x%x", $1, $3) : sprintf("%s0x%x", $1, hex($2)) @ge;
        $expr =~ s@\A +@@;
        if (length($section) > 1) {
          if ($inst1 eq "quad" and $expr =~ m@\A(?:0x([0-9a-fA-F]+)|(0|[1-9]\d*))\Z@) {
            my $value;
            {
              BEGIN { $^W = 0 }  # Silence hex warning.
              $value = defined($1) ? hex($1) : $2 + 0;
            }
            # Make it work in old NASM 0.98.39, which doesn't have `dq'.
            $inst1 = "long"; $expr = sprintf("0x%x, 0x%x", $value & 0xffffffff, ($value >> 32) & 0xffffffff);
          }
        } elsif (length($section) != 0) {  # "S", @$rodata_strs.
          # It doesn't look like a string. Pop and print preceding labels as well.
          # TODO(pts): Don't pop end-line labels (ending the previous string in hand-written assembly).
          my $i = @$rodata_strs;
          --$i while $i > 0 and substr($rodata_strs->[$i - 1], -1) eq ":";
          for (my $j = $i; $j < @$rodata_strs; ++$j) {
            print $outfh "$rodata_strs->[$j]\n";
          }
          splice @$rodata_strs, $i;
        } else {
          ++$errc;
          print STDERR "error: .$inst1 outside section ($lc): $_\n";
        }
        my $inst = $inst1 eq "byte" ? "db" : $inst1 eq "value" ? "dw" : $inst1 eq "long" ? "dd" : $inst1 eq "quad" ? "dq" : "d?";
        print $outfh "\t\t$inst $expr\n";
      } elsif (m@\A[.]((string|asciz)|ascii)(?=\Z|\s)(?:\s+"((?:[^\\"]+|\\.)*)"\s*\Z)?@s) {
        if (!defined($3)) {
          ++$errc;
          print STDERR "error: bad $1 argument ($lc): $_\n";
        } else {
          my($inst1, $inst2, $data) = ($1, $2, $3);
          if (!length($section)) {
            ++$errc;
            print STDERR "error: .$inst1 outside section ($lc): $_\n";
          }
          # GNU as 2.30 does the escaping like this.
          $data =~ s@\\(?:([0-3][0-7]{2}|[0-7][0-7]?)|[xX]([0-9a-fA-F]{1,})|([bfnrtv])|(.))@
              defined($1) ? chr(oct($1) & 255) :
              defined($2) ? chr(hex(substr($2, -2)) & 255) :
              defined($3) ? $as_string_escape1{$3} :
              $4 @ges;
          $data .= "\0" if defined($inst2);
          if (length($data)) {
            $data =~ s@([\x00-\x1f\\'\x7f-\xff])@ sprintf("', %d, '", ord($1)) @ges;
            $data = "'$data'";
            $data =~ s@, ''(?=, )@@g;  # Optimization.
            $data =~ s@\A'', @@;  # Optimization.
            $data =~ s@, ''\Z@@;  # Optimization.
            if (length($section) == 1) {
              push @$rodata_strs, "db $data";
            } else {
              print $outfh "\t\tdb $data\n";
            }
          }
        }
      } else {
        die "assert: missing directive: $_\n" if !m@\A([.][^ ]+)@;
        my $d = $1;
        ++$errc;
        if (!exists($unknown_directives{$d})) {
          print STDERR "error: unknown directive $d ignored ($lc): $_\n";
          $unknown_directives{$d} = 1;
        }
      }
    } elsif (s@\A([a-z][a-z0-9]*)(?: +|\Z)@@) {
      if (length($section) <= 1) {
        ++$errc;
        print STDERR "error: instruction outside section ($lc): $_\n";
      }
      my $inst = $1;
      #print STDERR "INST($inst $_)\n";
      $inst = "wait" if $inst eq "fwait";
      while (exists($prefix_insts{$inst})) {
        my $suffix = ($inst eq "wait" or !length($_)) ? "\n" : " ";
        print $outfh $inst, $suffix;
        $inst = s@\A([a-z][a-z0-9]*) *@@ ? $1 : "";
        $inst = "wait" if $inst eq "fwait";
      }
      if (!length($inst)) {
        goto check_labels if !length($_);
        $inst = "?";
        ++$errc;
        print STDERR "error: no instruction after prefix ($lc): $_\n";
      }
      #print STDERR "INSA $inst $_\n";
      $inst = $inst_map{$inst} if exists($inst_map{$inst});
      my $arg1_prefix;
      my $instwd = "";
      if (exists($fp_memarg_insts{$inst})) {
        die "fatal: assert: bad fp-memory instruction: $inst\n" if $inst !~ s@([slt])\Z@@;
        die "fatal: assert: missing arg for fp-memory instruction: $inst\n" if !length($_);
        $instwd = ($1 eq "s") ? " dword" : ($1 eq "l") ? " qword" : " tword";
      } elsif (!exists($force_nosize_insts{$inst}) and $inst =~ s@([bwl])\Z@@) {
        if (exists($nosize_arg_insts{$inst})) {
        } elsif (exists($str_arg_insts{$inst})) {
          my $suffix = ($1 eq "l") ? "d" : $1;
          $inst .= $suffix;
          $_ = "";  # Remove arguments without checking them.
        } elsif (exists($mov_extend_insts{$inst})) {
          my $suffix = $1 eq "b" ? " byte" : $1 eq "w" ? " word"  : $1 eq "l" ? " dword" : "";
          die "fatal: assert: mov_extend: $inst\n" if $inst !~ s@([bw])\Z@x@;
          $arg1_prefix = $1 eq "b" ? "byte " : $1 eq "w" ? "word " : "";
          $instwd = $suffix;
        } elsif (!length($_)) {  # E.g. "cbtw" to "cbt".
        } elsif ($1 eq "b") {
          $instwd = " byte"
        } elsif ($1 eq "w") {
          $instwd = " word"
        } elsif ($1 eq "l") {
          $instwd = " dword"
        }
      }
      my $is_args_special = exists($special_arg_insts{$inst});
      substr($inst, 0, 1) = "" if ($inst eq "lcall" or $inst eq "ljmp");
      if  ($inst =~ m@\A(?:call\Z|j[a-z]{1,3}|loop)@) {  # Includes jmp.
        if (s@\A[*]@@) {
           if ($is_win32 and $inst eq "call" and m@\A__imp__([^\s:\[\],+\-*/()<>`]+?)((?:\@\d+)?)\Z@) {
             print $outfh "\t\tkcall __imp__$1$2, '$1'\n";  # Example: kcall __imp__GetStdHandle@4, 'GetStdHandle'
             next;
           }
        } elsif ($do_omit_call_to___main and $inst eq "call" and $_ eq "___main") {
          next;  # Just omit it, argc and argv re already fine.
        } elsif (@abitest_insts and $inst eq "call") {
          push @abitest_insts, "\t\tcall $_\n";
          next;  # Don't do $used_labels{$label} = 1.
        } elsif (!m@\A[\$]@) { s@\A@\$@ }  # Relative immediate syntax for `jmp short' or `jmp near'.
      } elsif ($inst =~ m@\A(?:fadd|fmul|fsubr?|fdivr?)\Z(?!n)@ and m@\A%st(?:\(0\))?, *%st(?:\(0\))?\Z@) {
        # These are special instruction encodings of GNU as(1) 2.24--2.30 if
        # both arguments are ST(0). In that case as(1) generates the NASM
        # `$inst st0' variant rather than the `$inst st0, st0' ==
        # `$inst to st0' variant. The effect of these instructions are the
        # same.
        #
        # It's important to have this condition checked earlier than the
        # $inst2 one below.
        $_ = "%st";  # Will be converted to `st0'.
      } elsif ($inst =~ m@\A(fdiv|fsub)(r?)(p?)\Z(?!n)@) {
        if (index($_, ",") >= 0) {  # > 1 arguments (actually, 2).
          # * Input is either in the B form: `INST %st,%st(B)'
          #   or in the A form: `INST %st(A),%st'.
          #   Actually, we don't check here for the unsupported C form:
          #   `INST %st(C1),%st(C2)' with either C1 or C2 being 0.
          # * Replace %st with st0. This will be done by calling fix_reg below.
          # * Replace %st(I) with stI for I matching /\d+/. This will be
          #   done by calling fix_reg below.
          # * Swap the two arguments. This will be done by `reverse(@args)' below.
          # * Either flip the `r' in INST or not, e.g. fdivrp <-> fdivp:
          #   * For fadd, fmul, faddp, fmulp, keep it. (There isn't an `r' variant.)
          #   * For fdivrp, fdivp, fsubp, fsubrp: flip it.
          #   * For fdivr, fdiv, fsub, fsubr: flip it iff it was in the B form.
          # The flipping is important, otherwise an instruction with a
          # different meaning would be generated. (Checked it.)
          my $nr = length($2) ? "" : "r";
          my $inst2 = "$1$nr$3";  # Swap the r and non-r variants.
          $inst = $inst2 if length($3) or substr($_, 0, 4) eq "%st,";
        }
      }
      pos($_) = 0;
      my @args;
      my $tmp_arg;
      while (pos($_) < length($_)) {
        if (m@\G%(\w+|st\(\d+\))(?:, *|\Z)@gc) { push @args, ((substr($1, 0, 2) eq "st") ? fix_reg($1) : $1) }  # Register.
        elsif (m@\G\$([^(),]+)(?:, *|\Z)@gc) { push @args, fix_labels($1, \@bad_labels, $used_labels, \%local_labels) }  # Immediate.
        elsif (m@\G(?:%([a-z]s) *: *)?(?:([^%(),]+)|([^%(),]*)\(([^()]+)\))(?:, *|\Z)@gc) { push @args, fix_ea($1, defined($2) ? $2 : $3, defined($2) ? "" : $4, \@bad_labels, $used_labels, \%local_labels) }  # Effective address.
        elsif (m@\G([^,]*)(?:, *|\Z)@gc) {
          ++$errc;
          print STDERR "error: bad instruction argument ($lc): $1\n";
          push @args, "?";
        } else {
          my $rest = substr($_, pos($_));
          die "fatal: assert: bad instruction argument ($lc): $rest\n";
        }
      }
      @args = reverse(@args);
      if (!(@args and $is_args_special)) {  # This is the hot path, most instructions don't need special processing.
      } elsif (defined($arg1_prefix)) {  # $inst in ("movzx", "movsx").
        $args[1] = $arg1_prefix . $args[1] if @args == 2 and !exists($gp_regs{$args[1]});
      } elsif (($inst eq "call" or $inst eq "jmp") and @args == 2) {  # "lcall" and "ljmp".
        @args = "$args[1]:$args[0]";
      } elsif ($inst eq "in" or $inst eq "out") {
        @args = map { $_ eq "[dx]" ? "dx" : $_ } @args;
      } elsif ($inst eq "nop" and @args) {
        my $a0 = $args[0];
        if (@args == 1 and exists($reg32_to_index{$args[0]})) {
          print $outfh sprintf("db 0x0f, 0x1f, 0x%02x  ; nop %s\n", 0xc0 | $reg32_to_index{$args[0]}, $args[0]);
          goto check_labels
        } elsif (@args == 1 and exists($reg32_to_index{"e$args[0]"})) {
          print $outfh sprintf("db 0x66, 0x0f, 0x1f, 0x%02x  ; nop %s\n", 0xc0 | $reg32_to_index{"e$args[0]"}, $args[0]);
          goto check_labels
        } else {
          $inst .= "?";
          @args = reverse(@args);
          ++$errc;
          print STDERR "error: nop argument too complex for NASM 0.98.39 ($lc): $inst $_\n";
        }
      } elsif (exists($str_arg_insts{$inst})) {
        my $suffix = ((grep { $_ eq "al" } @args) ? "b" : "") . ((grep { $_ eq "ax" } @args) ? "w" : "") . ((grep { $_ eq "eax" } @args) ? "d" : "");
        if (length($suffix) != 1) {
          ++$errc;
          print STDERR "error: unrecognized string instruction size $suffix ($lc): $inst $_\n";
          $suffix = "?";
        }
        $inst .= $suffix;
        @args = ();
      } elsif (exists($shift_insts{$inst})) {
        push @args, "1" if @args == 1;
      } elsif ($inst eq "bound" or $inst eq "enter") {
        @args = reverse(@args);
      } elsif ($inst eq "lar" or $inst eq "lsl") {
        substr($args[1], 0, 0) = "e" if exists($reg32_to_index{"e$args[1]"});  # NASM 0.98.39 accepts only 32-bit register. So upgrade it from 16 bits.
      } elsif ($inst eq "fisttpll" or $inst eq "fisttp") {
        ($inst, $instwd) = ("fisttp", " qword") if $inst eq "fisttpll";
        if (@args == 1 and $args[0] eq "[ebx]") {  # Just a quick hack for testing. Proper 32-bit effective address encoding would be needed, also for `nop'.
          print $outfh sprintf("db 0x%02x, 0x0b  ; $inst$instwd $args[0]\n", $instwd eq " word" ? 0xdf : $instwd eq " dword" ? 0xdb : 0xdd);
          goto check_labels
        }
        # NASM 0.98.39 generates the machine bytes of the wrokg size (qword,
        # dword and word mixed). This one has been fixed in NASM 2.13.02 (or
        # earlier).
        ++$errc;
        print STDERR "error: fisttpll args too complex for buggy NASM 0.98.39 ($lc): $inst $_\n";
      } elsif ($inst eq "monitor") {
        @args = () if @args == 3 and "@args" eq "edx ecx eax";
      } elsif ($inst eq "mwait") {
        @args = () if @args == 2 and "@args" eq "ecx eax";
      }
      my $args = @args ? " " . join(", ", @args) : "";
      # Remove unnecessary size specifier if there is a general-purpose
      # register argument, e.g. convert `mov word ax, 1' to `mov ax, 1'.
      $instwd = "" if @args and length($instwd) and @args <= 2 and (
          exists($gp_regs{$args[0]}) or (@args == 2 and !defined($arg1_prefix) and exists($gp_regs{$args[1]})));
      $_ = "\t\t$inst$instwd$args\n";
      s@([\s:\[\],+\-*/()<>`])(?:0x([0-9a-fA-F]+)|(0|[1-9]\d*))@ defined($3) ? sprintf("%s0x%x", $1, $3) : sprintf("%s0x%x", $1, hex($2)) @ge;
      if (@abitest_insts) {
        if ($inst eq "ret") {
          my $abitest_name = shift(@abitest_insts);
          die "fatal: abitest not implemented\n";
          $errc += process_abitest($outfh, $abitest_name, \@abitest_insts, $lc);
          @abitest_insts = ();
        } else {
          push @abitest_insts, $_;
        }
      } else {
        print $outfh $_;
      }
    } elsif (!length($_)) {
    } elsif ($_ eq "#APP" or $_ eq "#NO_APP") {  # Ignore, preprocessor enable/disabled.
      # https://stackoverflow.com/a/73317832
    } elsif (m@^# (\d+) @) {  # Ignore, line number information.
    } else {
      ++$errc;
      print STDERR "error: instruction or directive expected ($lc): $_\n";
    }
   check_labels:
    for my $label (@bad_labels) {
      ++$errc;
      print STDERR "error: bad label syntax ($lc): $label\n";
    }
  }
  if (@abitest_insts) {
    ++$errc;
    print STDERR "error: incomplete abitest ($lc): $_\n";
  }
  if (0 and $rodata_strs and @$rodata_strs) {  # For debugging: don't merge (optimize) anything.
    $section = ".rodata";
    print $outfh "\nsection $section\n";
    for my $str (@$rodata_strs) {
      $str .= "\n";
      print $outfh $str;
    }
    @$rodata_strs = ();
  }
  for my $label (sort(keys(%$common_by_label))) {
    my $label1 = $define_when_defined->{$label};
    $defined_labels{$label1} = 1 if defined($label1);
  }
  for my $label (keys(%$used_labels)) {
    $undefineds->{$label} = 1 if !exists($defined_labels{$label});
  }
  for my $label (keys(%externs)) {
    $undefineds->{$label} = 1 if !exists($defined_labels{$label});
  }
  $errc
}

sub convert_as_to_nasm($$$$$$) {
  my($asfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment) = @_;
  printf STDERR "info: converting as to NASM syntax to: $nasmfn\n";
  my $asfh;
  die "fatal: open for reading: $asfn: $!\n" if !open($asfh, "<", $asfn);  # TODO(pts): Unlink it on subsequent errors.
  my $nasmfh;
  die "fatal: open for writing: $nasmfn: $!\n" if !open($nasmfh, ">", $nasmfn);  # TODO(pts): Unlink it on subsequent errors.
  print_nasm_header($nasmfh, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
  my $undefineds = {};
  my $is_win32 = 0;
  my $is_start_found = 0;
  my $lc = 0;
  my $first_line;
  my $do_merge_tail_strings = 1;  # TODO(pts): Make it configurable.
  my $rodata_strs = $do_merge_tail_strings ? [] : undef;
  my $define_when_defined = {};  # This won't work for multiple source files.
  my $common_by_label = {};
  my $errc = as2nasm($asfh, $nasmfh, $first_line, $lc, $rodata_strs, $is_win32, $undefineds, $define_when_defined, $common_by_label, \$is_start_found);
  print $nasmfh "\nsection .rodata\n" if $rodata_strs and @$rodata_strs;
  print_merged_strings_in_strdata($nasmfh, $rodata_strs, 1);
  if (%$undefineds) {
    print $nasmfh "\n";
    for my $label (sort(keys(%$undefineds))) {
      print $nasmfh "extern $label\n";
    }
  }
  print_commons($nasmfh, $common_by_label, $define_when_defined);  # Aggregate from multiple source files.
  die "fatal: $errc error@{[qq(s)x($errc!=1)]} during as2nasm translation\n" if $errc;
  print $nasmfh "\n; __END__\n";
  die "fatal: error writing NASM-assembly output\n" if !close($nasmfh);
  close($asfh);  # TODO(pts): Fail on write error;
}

# --- convert_wasm_to_nasm(...)

# Converts WASM (OpenWatcom assembler) syntax to NASM 0.98.39 syntax,
# Supports only a very small subset of WASM syntax, mostly the one generated
# by `wdis' (the OpenWatcom disassembler), and most hand-written .wasm
# source files won't work.
#
# The input file come from `wdis -a' or `wdis -a -fi'.
sub wasm2nasm($$$$$$$) {
  my($srcfh, $outfh, $first_line, $lc, $rodata_strs, $is_win32, $is_start_found_ref) = @_;
  my $section = ".text";
  my $segment = "";
  my $bss_org = 0;
  my $is_end = 0;
  my %segment_to_section = qw(_TEXT .text  CONST .rodata  CONST2 .rodata  _DATA .data  _BSS .bss);
  my %directive_to_segment = qw(.code _TEXT  .const CONST2  .data _DATA  .data? _BSS);  # TODO(pts): Is there a way for CONST2?
  my $end_expr;
  my @abitest_insts;  # Label and list of instructions being buffered.
  my $do_hide_abitest = 0;
  while (defined($first_line) or defined($first_line = <$srcfh>)) {
    ++$lc;
    ($_, $first_line) = ($first_line, undef);
    y@\r\n@@d;
    die "fatal: line after end ($lc): $_\n" if $is_end;
    my $is_instr = s@^\t(?!\t)@@;  # Assembly instruction.
    s@\A\s+@@;
    if (s@^\s*db\s+@db @i) {
      die "fatal: comment in db line\n" if m@;@;  # TODO(pts): Parse db '?'.
      s@\s+\Z(?!\n)@@;
    } else {
      s@;.*@@s;
      s@\s+@ @g;
      s@ \Z(?!\n)@@;
      s@\s*,\s*@, @g;
    }
    if ($is_instr) {
      die "fatal: unsupported instruction in non-.text ($lc): $_\n" if $section ne ".text";
      die "fatal: unsupported quote in instruction ($lc): $_\n" if m@'@;  # Whitespace is already gone.
      s@([\s:\[\],+\-*/()<>`])(?:([0-9][0-9a-fA-F]*)[hH]|(0|[1-9]\d*))@ defined($3) ? sprintf("%s0x%x", $1, $3) : sprintf("%s0x%x", $1, hex($2)) @ge;
      if (s~^(jmp|call) near ptr (?:FLAT:)?~$1 \$~) {
        s@\$`([^\s:\[\],+\-*/()<>`]+)`@\$$1@g;
      } elsif (s@^(j[a-z]+|loop[a-z]*) ([^\[\],\s]+)$@$1 \$$2@) {   # Add $ in front of jump target label.
        if (!s@\$`([^\s:\[\],+\-*/()<>`]+)`@\$$1@g) {  # Remove backtick quotes.
          s@^(jmp|call) \$([a-z]{2,})$@ exists($gp_regs{$2}) ? "$1 $2" : "$1 \$$2" @e;  # Make `jmp cx' work.
        }
      } elsif ($is_win32 and m@^call dword ptr *(?:FLAT:)?`?__imp__([^\s:\[\],+\-*/()<>`]+?)((?:\@\d+)?)`?$@) {
        $_ = "kcall __imp__$1$2, '$1'";  # Example: kcall __imp__GetStdHandle@4, 'GetStdHandle'
      } elsif ($_ eq "????") {
        die "fatal: unknown instruction\n";  # WASM doesn't recognize e.g. `db 0xd6' == `salc'.
      } else {
        s@ ptr ([cdefgs]s:)([^\[\],\s:]*)\[@ ptr $2\[$1@g;
        s@^(frstor|fsave|fstenv|fldenv|lea \w+,) (?:FLAT:)?([^\[\],]+)$@$1 [$2]@;
        s`([\s,])(byte|word|dword|fword|qword) ptr (?:([^\[\],\s]*)\[(.*?)\]|(?:([cdefgs]s:)|(?:FLAT|DGROUP:))?([^,]+))`
            # Example: sgdt fword ptr [...] to sgdt [...].
            my $size = $2 eq "fword" ? "" : "$2 ";
            if (defined($3)) {
              my $p = "$1$size\[$4"; my $displacement = $3;
              if (length($displacement)) {
                $p .= "+" if $displacement !~ m@\A-(?:0[xX][0-9a-fA-F]+|[0-9][0-9a-fA-F]*[hH]|0|[1-9]\d*)\Z(?!\n)@;
                $p .= $displacement;
              }
              $p .= "]"
            } else { my $seg = defined($5) ? $5 : ""; "$1$size\[$seg\$$6]" } `ge;
        s@^(call|jmp) dword \[@$1 [@;
        s@([\s,])([^\[\],\s]+)\[(.*?)\]@${1}[$3+$2]@g;  # `cmp al, 42[esi]'   -->  `cmp al, [esi+42]'.
        s@([-+])FLAT:([^,]+)@$1\$$2@g;
        s@([\s:\[\],+\-*/()<>])offset (?:FLAT:)?([^\s,+\-\[\]*/()<>]+)@$1\$$2@g;
        s@\$`([^\s:\[\],+\-*/()<>`]+)`@\$$1@g;  # Remove backtick quotes in `call dword [$`__imp__GetStdHandle@4`]`.
        if (m@^([a-z0-9]+) (?:byte|word|dword) ([^,]+)(, *(?:byte |word |dword )?([^,]+))?$@) {
          if (exists($gp_regs{$2}) or (
              defined($4) and
              not ($4 eq "cl" and exists($shift_instructions{$1})) and
              exists($gp_regs{$4}) and
              $1 ne "movsx" and $1 ne "movzx")) {
            my $m3 = defined($3) ? $3 : "";
            $_ = "$1 $2$m3";  # Omit the byte|word|dword qualifier.
          }
        } elsif (m@^([a-z0-9]+) ([^,]+), *(?:byte|word|dword) ([^,]+)?$@) {
          if (exists($gp_regs{$3}) or ($1 ne "movsx" and $1 ne "movzx" and exists($gp_regs{$2}))) {
            $_ = "$1 $2, $3";  # Omit the byte|word|dword qualifier.
          }
        }
        # !! TODO(pts): Some `fwait' (`db 0x9b') instructions are removed by
        #    wdis (e.g. in front `fld st'), which NASM won't add back. Add
        #    them back manually.
        s@([\s,])st\((\d)\)(?=[\s,]|\Z)@${1}st$2@g;  # st(0) --> st0.
        s@([\s,])st(?=[\s,]|\Z)@${1}st0@g;  # st --> st0.
      }
      if ($rodata_strs and $segment eq "CONST") {  # C string literals.
        push @$rodata_strs, $_;
      } else {
        print $outfh "\t\t$_\n" if !$do_hide_abitest;
        if (@abitest_insts) {
          if ($_ eq "ret") {
            my $abitest_name = shift(@abitest_insts);
            # The emitted `_abi cc, watcall' or `_abi cc, rp0' may not be
            # the before all labels and code, becase the OpenWatcom C
            # compiler sometimes merges function body tails, and it may get
            # merged to a later one.
            die "fatal: abitest not implemented\n";
            exit(1) if process_abitest($outfh, $abitest_name, \@abitest_insts, $lc);
            @abitest_insts = ();
            $do_hide_abitest = 0;
          } else {
            push @abitest_insts, "\t\t$_\n";
          }
        }
      }
    } elsif (m@^[.]@) {
      die "fatal: incomplete abitest ($lc): $_\n" if @abitest_insts;
      if ($_ eq ".387" or $_ eq ".model flat") {  # Ignore.
      } elsif (m@^[.]386@) {
        #print $outfh "cpu 386\n";
      } elsif (exists($directive_to_segment{$_})) {
        $segment = $directive_to_segment{$_};
        $section = $segment_to_section{$segment};
        print $outfh "\nsection $section  ; $segment\n";
      } else {
        die "fatal: unsupported WASM directive: $_\n" ;
      }
    } elsif (m@^(?:`([^\s:\[\],+\-*/()<>`]+)`|([^\s:\[\],+\-*/()<>`]+)):$@) {  # Label.
      $_ = (defined($1) ? $1 : $2) . ":";
      if ($rodata_strs and $segment eq "CONST") {
        push @$rodata_strs, "\$$_";
      } elsif (m@^__abitest_(.*?)_?:$@) {
        die "fatal: overlapping abitest ($lc): $_\n" if @abitest_insts;
        @abitest_insts = ($1);
        $do_hide_abitest = 1;
      } else {
        if ($do_hide_abitest) {  # It overlaps with code of another function.
          for (my $i = 1; $i < @abitest_insts; ++$i) {
            print $outfh "$abitest_insts[$i]\n";
          }
          $do_hide_abitest = 0;
        }
        if ($_ eq "_start_:" or $_ eq "_mainCRTStartup:") {  # Add extra start label for entry point.
          print $outfh "_start:\n";
          $$is_start_found_ref = 1;
        } elsif ($_ eq "_start:") {
          $$is_start_found_ref = 1;
        }
        print $outfh "\$$_\n";
      }
    } elsif (@abitest_insts) {
      die "fatal: incomplete abitest ($lc): $_\n" if @abitest_insts;
    } elsif (s@^(d[bwd])(?= )@@i) {
      my $cmd = lc($1);
      s@\boffset (?:FLAT:|DGROUP:)?@\$@g if !m@'@;
      my $count = 1;
      # Example: ` 0fH DUP(0,0,0,0,0,0,0,0)'.
      $count = (defined($1) ? ($1 + 0) : hex($2)) if
          s@^ (?:([0-9])|([0-9][0-9a-fA-F]*)[hH]) DUP\((.*)\)$@ $3@;
      while ($count--) {
        if ($rodata_strs and $segment eq "CONST") {  # C string literals.
          push @$rodata_strs, $cmd . $_;
        } else {
          s@([\s:\[\],+\-*/()<>`])(?:([0-9][0-9a-fA-F]*)[hH]|(0|[1-9]\d*))@ defined($3) ? sprintf("%s0x%02x", $1, $3) : sprintf("%s0x%02x", $1, hex($2)) @ge;
          print $outfh "\t\t$cmd$_\n";
        }
      }
    } elsif (m@^(_TEXT|CONST2?|_DATA|_BSS) SEGMENT @) {
      $segment = $1;
      $section = $segment_to_section{$segment};
      print $outfh "\nsection $section  ; $segment\n";
      die "fatal: non-32-bit segment found: $_\n" if !m@ USE32 @;
    } elsif (m@^(\S+) ENDS$@) {
      die "fatal: unexpected segment end: $1\n" if $1 ne $segment;
    } elsif (m@^ORG @) {
      die "fatal: bad org instruction ($lc): $_\n" if
          !m@^ORG (?:([0-9])|([0-9][0-9a-fA-F]*)[hH])$@ or $section ne ".bss";
      my $delta_bss_org = (defined($1) ? ($1 + 0) : hex($2)) - $bss_org;
      die "fatal: .bss org decreasing ($lc): $_\n" if $delta_bss_org < 0;
      if ($delta_bss_org != 0) {
        my $sizex = sprintf("0x%x", $delta_bss_org);
        print $outfh "\t\tresb $sizex\n";
      }
      $bss_org += $delta_bss_org;
    } elsif (m@^(?:`([^\s:\[\],+\-*/()<>`]+)`|([^\s:\[\],+\-*/()<>`]+)) LABEL BYTE$@ and $section eq ".bss") {
      my $label = defined($1) ? $1 : $2;
      print $outfh "\$$label:\n";
    } elsif (m@^end(?: ([^\s:\[\],+\-*/()<>`]+))?$@i) {
      $end_expr = $1;
      $is_end = 1;
    } elsif (m@^public (?:`([^\s:\[\],+\-*/()<>`]+)`|([^\s:\[\],+\-*/()<>`]+))$@i) {
      my $label = defined($1) ? $1 : $2;
      print $outfh "global \$$label\n";
    } elsif (m@^extrn (?:`([^\s:\[\],+\-*/()<>`]+)`|([^\s:\[\],+\-*/()<>`]+))(?::byte)?$@i) {
      # Example with backtick: EXTRN `__imp__GetStdHandle@4`:BYTE
      my $label = defined($1) ? $1 : $2;
      print $outfh "extern \$$label\n" if !$is_win32 or $label !~ m@\A__imp__@;
    } elsif (!length($_) or m@^DGROUP GROUP@ or m@^ASSUME @) {  # Ignore.
    } else {
      die "fatal: unsupported WASM instruction ($lc): $_\n" ;
    }
  }
  die "fatal: incomplete abitest ($lc): $_\n" if @abitest_insts;
  if (defined $end_expr) {
    print $outfh "\$_start equ $end_expr\n" if $end_expr ne "_start";
  }
}

sub convert_wasm_to_nasm($$$$$$) {
  my($wasmfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment) = @_;
  printf STDERR "info: converting WASM to NASM syntax to: $nasmfn\n";
  my $wasmfh;
  die "fatal: open for reading: $wasmfn: $!\n" if !open($wasmfh, "<", $wasmfn);  # TODO(pts): Unlink it on subsequent errors.
  my $nasmfh;
  die "fatal: open for writing: $nasmfn: $!\n" if !open($nasmfh, ">", $nasmfn);  # TODO(pts): Unlink it on subsequent errors.
  print_nasm_header($nasmfh, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
  my $is_win32 = 0;
  my $is_start_found = 0;
  my $lc = 0;
  my $first_line;
  my $do_merge_tail_strings = 1;  # TODO(pts): Make it configurable.
  my $rodata_strs = $do_merge_tail_strings ? [] : undef;
  wasm2nasm($wasmfh, $nasmfh, $first_line, $lc, $rodata_strs, $is_win32, \$is_start_found);
  print $nasmfh "\nsection .rodata\n" if $rodata_strs and @$rodata_strs;
  print_merged_strings_in_strdata($nasmfh, $rodata_strs, 0);
  print $nasmfh "\n; __END__\n";
  die "fatal: error writing NASM-assembly output\n" if !close($nasmfh);
  close($wasmfh);  # TODO(pts): Fail on write error;
}

# ---

sub convert_to_nasm($$$$$$$) {
  my($cmd_type, $cmd_arg, $srcfn, $basefn, $objfn, $nasmfn, $data_alignment) = @_;
  # May be kept undefined if no -march=... was found in @$cmd_arg.
  # `cpu prescott' would also work in NASM for $cpulevel > 6.
  my $nasm_cpu;
  for my $arg (@$cmd_arg) {
    $nasm_cpu = $1 if $arg =~ m@\A-march=i([3456]86)\Z(?!\n)@;
  }
  if ($cmd_type eq "gcc") {
    my $asfn = "$basefn.tmp.s";  # GNU as AT&T syntax. TODO(pts): Remove temporary file as part of cleanup (@unlink_fns).
    my @cmdcs = @$cmd_arg;
    push @cmdcs, "-S", "-o", $asfn, $srcfn;
    print STDERR "info: running compiler-to-as: ", join(" ", map { shargq($_) } @cmdcs), "\n";
    my $status = system(@cmdcs);
    die "fatal: error running compiler-to-as\n" if $status;
    my $format = (detect_binary_format($asfn) or "unknown");
    die "fatal: expeected as file format, got: $format\n" if $format ne "as";
    convert_as_to_nasm($asfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
    unlink($asfn);
  } elsif ($cmd_type eq "owcc") {
    my @cmdco = @$cmd_arg;
    push @cmdco, "-c", "-o", $objfn, $srcfn;
    print STDERR "info: running compiler-again: ", join(" ", map { shargq($_) } @cmdco), "\n";
    my $status = system(@cmdco);
    die "fatal: error running compiler-to-as\n" if $status;
    my $format = (detect_binary_format($objfn) or "unknown");
    die "fatal: expeected omf file format, got: $format\n" if $format ne "omf";
    my $wasmfn = "$objfn.tmp.wasm";  # TODO(pts): Remove temporary file as part of cleanup (@unlink_fns).
    my @wasmdis_cmd = ("wdis", "-a", argv_escape_fn($objfn));
    print STDERR "info: running wasmdis_cmd: @wasmdis_cmd >$wasmfn\n";
    {
      my $saveout;
      die if !open($saveout, ">&", \*STDOUT);
      die "fatal: open: $wasmfn: $!\n" if !open(STDOUT, ">", $wasmfn);
      die "fatal: wasmdis_cmd failed: @wasmdis_cmd\n" if system(@wasmdis_cmd);
      die if !open(STDOUT, ">&", $saveout);
      close($saveout);
    }
    convert_wasm_to_nasm($wasmfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
    unlink($wasmfn);
  } else {
    die "fatal: unknown compiler command type: $cmd_type\n";
  }
}

# ---

my @oflags;
my @cflags;
my $srcfn;
my $is_i686_enabled = 1;
my $is_owcc_enabled = 1;
my $is_gcc_enabled = 1;
my $data_alignment = 4;
{
  my $i = 0;
  while ($i < @ARGV) {
    my $arg = $ARGV[$i++];
    if ($arg eq "--") {
      last
    } elsif ($arg eq "-" or substr($arg, 0, 1) ne "-") {
      --$i;
      last
    } elsif ($arg eq "-mowcc") {
      $is_owcc_enabled = 1;
    } elsif ($arg eq "-mno-owcc") {
      $is_owcc_enabled = 0;
    } elsif ($arg eq "-mgcc") {
      $is_gcc_enabled = 1;
    } elsif ($arg eq "-mno-gcc") {
      $is_gcc_enabled = 0;
    } elsif ($arg eq "-march=i386") {
      $is_i686_enabled = 0;
    } elsif ($arg =~ m@-malign=(.*)\Z(?!\n)@) {  # Data section alignment.
      my $value = $1;
      # Allowed values: 0, 1, 2, 4, 8, 16, 32.
      # Values larger than 32 are not supported by elf.inc.nasm.
      die "fatal: bad data alignment: $arg\n" if
          $value !~ m@\A(?:0|[1-9]\d{0,8})\Z(?!\n)@ or
          ($value = int($value)) > 32 or
          ($value & ($value - 1));
      $data_alignment = $value > 1 ? $value : 1;
    } elsif ($arg =~ m@\A-[DU][_A-Za-z]\w*\Z(?!\n)@) {
      push @cflags, $arg;
    } elsif ($arg =~ m@\A-[OW]@) {
      push @oflags, $arg;
    } else {
      die "fatal: unknown flag: $arg\n";
    }
  }
  die "fatal: missing C source file\n" if $i >= @ARGV;
  die "fatal: too many source files, only one allowed\n" if $i > @ARGV + 1;
  $srcfn = $ARGV[$i];
}
my $basefn = $srcfn;
die "fatal: source file must have an extension: $srcfn\n" if $basefn !~ s@[.](\w+)\Z(?!\n)@@;
my $ext = $1;

if ($ext eq "s") {
  my $asfn = $srcfn;
  my $nasmfn = "$basefn.nasm";
  my $nasm_cpu = "";  # We don't know, it would be specified in the as(1) command line.
  convert_as_to_nasm($asfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
  exit();
} elsif ($ext eq "c") {
  # Continue below.
} else {
  die "fatal: source file must be C source (*.c) or GNU as(1) source (*.s): $srcfn\n";
}

# ---

sub get_code_size_using_objdump($) {
  my $objfn = $_[0];
  my $objdumphwfn = "$objfn.tmp.objdumphw";  # TODO(pts): Remove temporary file as part of cleanup (@unlink_fns).
  my @objdumphw_cmd = ("objdump", "-h", "-w", argv_escape_fn($objfn));
  print STDERR "info: running objdumphw_cmd: @objdumphw_cmd >$objdumphwfn\n";
  {
    my $saveout;
    die if !open($saveout, ">&", \*STDOUT);
    die "fatal: open: $objdumphwfn: $!\n" if !open(STDOUT, ">", $objdumphwfn);
    die "fatal: objdumphw_cmd failed: @objdumphw_cmd\n" if system(@objdumphw_cmd);
    die if !open(STDOUT, ">&", $saveout);
    close($saveout);
  }
  my $fh;
  die "fatal: open for reading: $objdumphwfn: $!\n" if !open($fh, "<", $objdumphwfn);
  my $line;
  my $code_size = 0;
  while (defined($line = <$fh>)) {
    # Example $line: 0 .text           00000303  00000000  00000000  00000034  2**2  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
    if ($line =~ m@ *\d+ [.]text\S*[ \t]+([0-9a-fA-F]{8,})[ \t]@) {
      $code_size += hex($1);
    }
  }
  close($fh);
  die "fatal: code not found in object file: $objdumphwfn\n" if $code_size <= 0;
  unlink($objdumphwfn);
  $code_size
}

sub get_code_size_using_wdis($) {
  my $objfn = $_[0];
  my $wdisfn = "$objfn.tmp.wdis";  # TODO(pts): Remove temporary file as part of cleanup (@unlink_fns).
  my @wdis_cmd = ("wdis", argv_escape_fn($objfn));
  print STDERR "info: running wdis_cmd: @wdis_cmd >$wdisfn\n";
  {
    my $saveout;
    die if !open($saveout, ">&", \*STDOUT);
    die "fatal: open: $wdisfn: $!\n" if !open(STDOUT, ">", $wdisfn);
    die "fatal: wdis_cmd failed: @wdis_cmd\n" if system(@wdis_cmd);
    die if !open(STDOUT, ">&", $saveout);
    close($saveout);
  }
  my $fh;
  die "fatal: open for reading: $wdisfn: $!\n" if !open($fh, "<", $wdisfn);
  my $line;
  my $code_size = 0;
  while (defined($line = <$fh>)) {
    $line =~ s@\r?\n\Z(?!\n)@@;
    last if $line =~ m@^Segment: (\S+)@ and $1 ne "_TEXT";
    if ($line =~ m@\A([0-9A-F]+) ((?: [0-9A-F]{2})+)@) {  # Get size from hex dump line.
      my $code_size2 = hex($1) + int(length($2) / 3);
      die "fatal: size is unexpectedly decreasing\n" if $code_size2 <= $code_size;
      $code_size = $code_size2;
    }
  }
  close($fh);
  die "fatal: code not found in object file: $wdisfn\n" if $code_size <= 0;
  unlink($wdisfn);
  $code_size
}

my($best_code_size, $best_cmd_ary, $best_cmd_type, $best_objfn);

# Uses global variables: @oflags, @clflags, $srcfn, $basefn, $best_code_size, $best_cmd_ary, $best_cmd_type.
sub run_cmd($$) {
  my($cmd_ary, $cmd_type) = @_;  # TODO(pts): Do we even use $cmd_type here?
  die "fatal: unknown compiler command type: $cmd_type\n" if $cmd_type ne "gcc" and $cmd_type ne "owcc";
  my @cmd = @$cmd_ary;
  if (@oflags) {
    @cmd = grep { !m@\A-O@ } @cmd;
    push @cmd, @oflags;
  }
  push @cmd, @cflags;
  my @cmdco = @cmd;  # Command to generate object file from .c file.
  my $objfn = ($cmd_type eq "owcc") ? "$basefn.try.obj" : "$basefn.try.o";  # TODO(pts): Remove temporary file as part of cleanup.
  push @cmdco, "-c", "-o", $objfn, $srcfn;
  print STDERR "info: running compiler: ", join(" ", map { shargq($_) } @cmdco), "\n";
  my $status = system(@cmdco);
  die "fatal: error running compiler\n" if $status;
  my $format = (detect_binary_format($objfn) or "unknown");
  my $code_size = ($format eq "elf") ? get_code_size_using_objdump($objfn) :
      ($format eq "omf") ? get_code_size_using_wdis($objfn) : undef;
  die "fatal: unsupported object file format: $format\n" if !defined($code_size);
  printf STDERR "info: code size: 0x%x\n", $code_size;
  my $prev_best_objfn = $best_objfn;
  if (!defined($best_code_size) or $code_size < $best_code_size) {
    $best_code_size = $code_size;
    $best_cmd_ary = \@cmd;
    $best_cmd_type = $cmd_type;
    $best_objfn = $objfn;
    unlink($prev_best_objfn) if defined($prev_best_objfn) and $prev_best_objfn ne $objfn;
  }
}

# ---

# Most of these flags instruct GCC and other compilers to generate shorter (smaller) code.
# -fsigned-char is the default for gcc, but not for owcc. We make it explicit for both.
my @cflags = qw(-D__SOPTCC__);
my @gcc_flags = qw(-m32 -fno-pic -Os -W -Wall -Werror -U_FORTIFY_SOURCE -fno-stack-protector -fno-unwind-tables -fno-asynchronous-unwind-tables -falign-functions=1 -falign-jumps=1 -falign-loops=1 -mpreferred-stack-boundary=2 -fno-builtin -fno-ident -fsigned-char -ffreestanding);
my @clang_flags = qw(-m32 -fno-pic -Os -W -Wall -Werror -U_FORTIFY_SOURCE -fno-stack-protector -fno-unwind-tables -fno-asynchronous-unwind-tables -mstack-alignment=4 -fno-builtin -fno-ident -fsigned-char -ffreestanding);
my @gcc_cmds = (  # GCC and Clang C compilers.
    ["gcc", "-march=i386", "-fno-omit-frame-pointer", @gcc_flags, @cflags],
    ["gcc", "-march=i686", "-fno-omit-frame-pointer", @gcc_flags, @cflags],
    ["gcc", "-march=i386", "-fomit-frame-pointer", @gcc_flags, @cflags],
    ["gcc", "-march=i686", "-fomit-frame-pointer", @gcc_flags, @cflags],
    ["qq", "gcc-4.8", "-march=i386", "-fno-omit-frame-pointer", @gcc_flags, @cflags],  # `gcc-4.8' generates shorter code than newer GCCs.
    ["qq", "gcc-4.8", "-march=i686", "-fno-omit-frame-pointer", @gcc_flags, @cflags],
    ["qq", "gcc-4.8", "-march=i386", "-fomit-frame-pointer", @gcc_flags, @cflags],
    ["qq", "gcc-4.8", "-march=i686", "-fomit-frame-pointer", @gcc_flags, @cflags],
    ["clang", "-march=i386", "-fno-omit-frame-pointer", @clang_flags, @cflags],
    ["clang", "-march=i686", "-fno-omit-frame-pointer", @clang_flags, @cflags],
    ["clang", "-march=i386", "-fomit-frame-pointer", @clang_flags, @cflags],
    ["clang", "-march=i686", "-fomit-frame-pointer", @clang_flags, @cflags],
);
@gcc_cmds = grep { !grep { $_ eq "-march=i686" } @$_ } @gcc_cmds if !$is_i686_enabled;
my @owcc_flags = qw(-blinux -Os -fno-stack-check -fsigned-char -fno-short-enum -march=i386 -mabi=cdecl -W -Wall -Wextra -Werror);
my @owcc_cmds = (  # OpenWatcom C compiler. Good or optimizing for size.
    ["owcc", @owcc_flags, @cflags],
    ["owcc", "-frerun-optimizer", @owcc_flags, @cflags],
    ["owcc", "-floop-optimize", @owcc_flags, @cflags],
    ["owcc", "-floop-optimize", "-frerun-optimizer", @owcc_flags, @cflags],
);

$best_code_size = $best_cmd_ary = $best_cmd_type = undef;
print STDERR "info: running compilers to find best for: $srcfn\n";
if ($is_gcc_enabled) {
  for my $cmd_ary (@gcc_cmds) {
    run_cmd($cmd_ary, "gcc");
  }
}
if ($is_owcc_enabled) {
  for my $cmd_ary (@owcc_cmds) {
    run_cmd($cmd_ary, "owcc");
  }
}
die "fatal: no compilers have been run\n" if !defined($best_code_size);
printf STDERR "info: found best code size is 0x%x bytes with %s command: %s\n",
    $best_code_size, $best_cmd_type, join(" ", map { shargq($_) } @$best_cmd_ary);
my $nasmfn = "$basefn.nasm";
convert_to_nasm($best_cmd_type, $best_cmd_ary, $srcfn, $basefn, $best_objfn, $nasmfn, $data_alignment);
unlink($best_objfn);

__END__
