#!/bin/sh --
eval 'PERL_BADLANG=x;export PERL_BADLANG;exec perl -x "$0" "$@";exit 1'
#!perl  # Start marker used by perl -x.
+0 if 0;eval("\n\n\n\n".<<'__END__');die$@if$@;__END__

#
# soptcc.pl: size-optimizing C compiler frontend for i386
# by pts@fazekas.hu at Wed May 10 22:45:37 CEST 2023
#
# Runs multiple C compilers and picks the one which generates fewer (code)
# bytes. Emits a NASM source file (`nasm -f elf -O999999999'). Supports only
# i386 architecture (up to i686) with the SYSV calling convention
# (-mregparm=0).
#

BEGIN { $^W = 1 }
use integer;
use strict;

# ---

# Escapes filename as any shell command-line argument.
sub shargq($) {
  my $fnq = $_[0];
  if ($fnq !~ m@\A[-/+.,\w][-/+.,=\w]*\Z(?!\n)@) {
    $fnq =~ s@[\r\n]+@ @g;
    $fnq =~ s@'@'\\''@g;
    $fnq = "'$fnq'";
  }
  $fnq
}

# Escapes filename as non-flag shell command-line argument.
sub fnargq($) {
  my $fnq = $_[0];
  $fnq = "./$fnq" if $fnq =~ m@\A-@;
  return shargq($fnq);
}

sub argv_escape_fn($) {
  my $filename = $_[0];
  substr($filename, 0, 0) = "./" if $filename =~ m@-@;  # TODO(pts): Win32 compatibility.
  $filename
}

sub detect_binary_format($) {
  my $filename = $_[0];
  my $fh;
  die "fatal: open for reading: $filename: $!\n" if !open($fh, "<", $filename);
  my $hdr;
  die "fatal: read: $filename: $!\n" if !defined(sysread($fh, $hdr, 4));
  if ($hdr =~ m@\s*[.]@) {
    die "fatal: read more: $filename: $!\n" if !defined(sysread($fh, $hdr, 32, length($hdr)));
    close($fh);
    if ($hdr =~ m@\A\s*[.](?:model\s|38[67])@i) {
      return "wasm";
    #} elsif (m@\A\s*(?:bits\s|cpu\s|section\s|%)@i) {
    #  return "nasm";
    } else {
      return "as";
    }
  }
  close($fh);
  if (!length($hdr)) {
    return "empty";
  } elsif ($hdr =~ m@\A\x7fELF@) {
    return "elf";  # Can be program (executable), object (relocatable) etc.
  } elsif ($hdr =~ m@\AMZ@) {
    return "exe";
  } elsif ($hdr =~ m@\A\x80@) {  # OMF .obj object file generated by e.g. OpenWatcom.
    return "omf";
  } elsif ($hdr =~ m@\A\x4c\x01@) {  # COFF .obj obect file used on Win32.
    return "coff";
  } elsif ($hdr =~ m@\A(?:\xfe\xed\xfa[\xce|\xcf]|[\xce\xcf]\xfa\xed\xfe)@) {
    return "macho";  # Can  be executable, object etc.
  }
  undef  # die "fatal: unknown file format: $filename\n";
}

sub print_nasm_header($$$$$$) {
  my($nasmfh, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment) = @_;
  print $nasmfh "; .nasm source file generated by soptcc.pl\n; from $srcfn\n",
                "; Compile to i386 ELF .o object: nasm -O999999999 -w+orphan-labels -f elf -o " . fnargq("$basefn.o") . " " . fnargq($nasmfn) . "\n\n",
                "bits 32\n";
  # %ifidn __OUTPUT_FORMAT__, elf
  print $nasmfh "cpu $nasm_cpu\n" if $nasm_cpu;
  print $nasmfh "section .text align=1\n",
                "section .rodata align=$data_alignment\n",
                "section .data align=$data_alignment\n",
                "section .bss align=$data_alignment\n\n";
  #print $nasmfh "\nsection .text\n";  # asm2nasm(...) will print it.
}

# --- convert_as_to_nasm(...)

sub convert_as_to_nasm($$$$$$) {
  my($asfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment) = @_;
  printf STDERR "info: converting as to NASM syntax to: $nasmfn\n";
  my $asfh;
  die "fatal: open for reading: $asfn: $!\n" if !open($asfh, "<", $asfn);  # TODO(pts): Unlink it on subsequent errors.
  my $nasmfh;
  die "fatal: open for writing: $nasmfn: $!\n" if !open($nasmfh, ">", $nasmfn);  # TODO(pts): Unlink it on subsequent errors.
  print_nasm_header($nasmfh, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
  my $line;
  while (defined($line = <$asfh>)) {
    print $nasmfh $line;  # !! TODO(pts): Do proper conversion.
  }
  close($nasmfh);  # TODO(pts): Fail on read error.
  close($asfh);  # TODO(pts): Fail on write error;
}

# --- convert_wasm_to_nasm(...)

sub convert_wasm_to_nasm($$$$$$) {
  my($wasmfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment) = @_;
  printf STDERR "info: converting WASM to NASM syntax to: $nasmfn\n";
  my $wasmfh;
  die "fatal: open for reading: $wasmfn: $!\n" if !open($wasmfh, "<", $wasmfn);  # TODO(pts): Unlink it on subsequent errors.
  my $nasmfh;
  die "fatal: open for writing: $nasmfn: $!\n" if !open($nasmfh, ">", $nasmfn);  # TODO(pts): Unlink it on subsequent errors.
  print_nasm_header($nasmfh, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
  my $line;
  while (defined($line = <$wasmfh>)) {
    print $nasmfh $line;  # !! TODO(pts): Do proper conversion.
  }
  close($nasmfh);  # TODO(pts): Fail on read error.
  close($wasmfh);  # TODO(pts): Fail on write error;
}

# ---

sub convert_to_nasm($$$$$$) {
  my($cmd_arg, $srcfn, $basefn, $objfn, $nasmfn, $data_alignment) = @_;
  my $format = (detect_binary_format($objfn) or "unknown");
  die "fatal: unsupported object file format: $format\n" if $format ne "elf" and $format ne "omf";
  # May be kept undefined if no -march=... was found in @$cmd_arg.
  # `cpu prescott' would also work in NASM for $cpulevel > 6.
  my $nasm_cpu;
  for my $arg (@$cmd_arg) {
    $nasm_cpu = $1 if $arg =~ m@\A-march=i([3456]86)\Z(?!\n)@;
  }
  if ($format eq "elf") {
    my @cmdcs = @$cmd_arg;
    my $asfn = "$basefn.tmp.s";  # GNU as AT&T syntax. TODO(pts): Remove temporary file as part of cleanup (@unlink_fns).
    push @cmdcs, "-S", "-o", $asfn, $srcfn;  # TODO(pts): Don't run again, but do it before, as a temporary step, when generating $objfn.
    print STDERR "info: running compiler-to-as: ", join(" ", map { shargq($_) } @cmdcs), "\n";
    my $status = system(@cmdcs);
    die "fatal: error running compiler-to-as\n" if $status;
    my $format = (detect_binary_format($asfn) or "unknown");
    die "fatal: expeected as file format, got: $format\n" if $format ne "as";
    convert_as_to_nasm($asfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
    unlink($asfn);
  } else {
    my $wasmfn = "$objfn.tmp.wasm";  # TODO(pts): Remove temporary file as part of cleanup (@unlink_fns).
    my @wasmdis_cmd = ("wdis", "-a", argv_escape_fn($objfn));
    print STDERR "info: running wasmdis_cmd: @wasmdis_cmd >$wasmfn\n";
    {
      my $saveout;
      die if !open($saveout, ">&", \*STDOUT);
      die "fatal: open: $wasmfn: $!\n" if !open(STDOUT, ">", $wasmfn);
      die "fatal: wasmdis_cmd failed: @wasmdis_cmd\n" if system(@wasmdis_cmd);
      die if !open(STDOUT, ">&", $saveout);
      close($saveout);
    }
    convert_wasm_to_nasm($wasmfn, $nasmfn, $basefn, $srcfn, $nasm_cpu, $data_alignment);
    unlink($wasmfn);
  }
}

# ---

my @oflags;
my @cflags;
my $srcfn;
my $is_owcc_enabled = 1;
my $data_alignment = 4;
{
  my $i = 0;
  while ($i < @ARGV) {
    my $arg = $ARGV[$i++];
    if ($arg eq "--") {
      last
    } elsif ($arg eq "-" or substr($arg, 0, 1) ne "-") {
      --$i;
      last
    } elsif ($arg eq "-mowcc") {
      $is_owcc_enabled = 1;
    } elsif ($arg eq "-mno-owcc") {
      $is_owcc_enabled = 0;
    } elsif ($arg =~ m@-malign=(.*)\Z(?!\n)@) {  # Data section alignment.
      my $value = $1;
      # Allowed values: 0, 1, 2, 4, 8, 16, 32.
      # Values larger than 32 are not supported by elf.inc.nasm.
      die "fatal: bad data alignment: $arg\n" if
          $value !~ m@\A(?:0|[1-9]\d{0,8})\Z(?!\n)@ or
          ($value = int($value)) > 32 or
          ($value & ($value - 1));
      $data_alignment = $value > 1 ? $value : 1;
    } elsif ($arg =~ m@\A-[DU][_A-Za-z]\w*\Z(?!\n)@) {
      push @cflags, $arg;
    } elsif ($arg =~ m@\A-O@) {
      push @oflags, $arg;
    } else {
      die "fatal: unknown flag: $arg\n";
    }
  }
  die "fatal: missing C source file\n" if $i >= @ARGV;
  die "fatal: too many source files, only one allowed\n" if $i > @ARGV + 1;
  $srcfn = $ARGV[$i];
}
my $basefn = $srcfn;
die "fatal: source file must be C source (*.c): $srcfn\n" if $basefn !~ s@[.]c\Z(?!\n)@@;

# ---

sub get_code_size_using_objdump($) {
  my $objfn = $_[0];
  my $objdumphwfn = "$objfn.tmp.objdumphw";  # TODO(pts): Remove temporary file as part of cleanup (@unlink_fns).
  my @objdumphw_cmd = ("objdump", "-h", "-w", argv_escape_fn($objfn));
  print STDERR "info: running objdumphw_cmd: @objdumphw_cmd >$objdumphwfn\n";
  {
    my $saveout;
    die if !open($saveout, ">&", \*STDOUT);
    die "fatal: open: $objdumphwfn: $!\n" if !open(STDOUT, ">", $objdumphwfn);
    die "fatal: objdumphw_cmd failed: @objdumphw_cmd\n" if system(@objdumphw_cmd);
    die if !open(STDOUT, ">&", $saveout);
    close($saveout);
  }
  my $fh;
  die "fatal: open for reading: $objdumphwfn: $!\n" if !open($fh, "<", $objdumphwfn);
  my $line;
  my $code_size = 0;
  while (defined($line = <$fh>)) {
    # Example $line: 0 .text           00000303  00000000  00000000  00000034  2**2  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
    if ($line =~ m@ *\d+ [.]text\S*[ \t]+([0-9a-fA-F]{8,})[ \t]@) {
      $code_size += hex($1);
    }
  }
  close($fh);
  die "fatal: code not found in object file: $objdumphwfn\n" if $code_size <= 0;
  unlink($objdumphwfn);
  $code_size
}

sub get_code_size_using_wdis($) {
  my $objfn = $_[0];
  my $wdisfn = "$objfn.tmp.wdis";  # TODO(pts): Remove temporary file as part of cleanup (@unlink_fns).
  my @wdis_cmd = ("wdis", argv_escape_fn($objfn));
  print STDERR "info: running wdis_cmd: @wdis_cmd >$wdisfn\n";
  {
    my $saveout;
    die if !open($saveout, ">&", \*STDOUT);
    die "fatal: open: $wdisfn: $!\n" if !open(STDOUT, ">", $wdisfn);
    die "fatal: wdis_cmd failed: @wdis_cmd\n" if system(@wdis_cmd);
    die if !open(STDOUT, ">&", $saveout);
    close($saveout);
  }
  my $fh;
  die "fatal: open for reading: $wdisfn: $!\n" if !open($fh, "<", $wdisfn);
  my $line;
  my $code_size = 0;
  while (defined($line = <$fh>)) {
    $line =~ s@\r?\n\Z(?!\n)@@;
    last if $line =~ m@^Segment: (\S+)@ and $1 ne "_TEXT";
    if ($line =~ m@\A([0-9A-F]+) ((?: [0-9A-F]{2})+)@) {  # Get size from hex dump line.
      my $code_size2 = hex($1) + int(length($2) / 3);
      die "fatal: size is unexpectedly decreasing\n" if $code_size2 <= $code_size;
      $code_size = $code_size2;
    }
  }
  close($fh);
  die "fatal: code not found in object file: $wdisfn\n" if $code_size <= 0;
  unlink($wdisfn);
  $code_size
}

my($best_code_size, $best_cmd_ary, $best_cmd_type, $best_objfn);

# Uses global variables: @oflags, @clflags, $srcfn, $basefn, $best_code_size, $best_cmd_ary, $best_cmd_type.
sub run_cmd($$) {
  my($cmd_ary, $cmd_type) = @_;  # TODO(pts): Do we even use $cmd_type here?
  die "fatal: unknown compiler command type: $cmd_type\n" if $cmd_type ne "gcc" and $cmd_type ne "owcc";
  my @cmd = @$cmd_ary;
  if (@oflags) {
    @cmd = grep { !m@\A-O@ } @cmd;
    push @cmd, @oflags;
  }
  push @cmd, @cflags;
  my @cmdco = @cmd;  # Command to generate object file from .c file.
  my $objfn = ($cmd_type eq "owcc") ? "$basefn.try.obj" : "$basefn.try.o";  # TODO(pts): Remove temporary file as part of cleanup.
  push @cmdco, "-c", "-o", $objfn, $srcfn;
  print STDERR "info: running compiler: ", join(" ", map { shargq($_) } @cmdco), "\n";
  my $status = system(@cmdco);
  die "fatal: error running compiler\n" if $status;
  my $format = (detect_binary_format($objfn) or "unknown");
  my $code_size = ($format eq "elf") ? get_code_size_using_objdump($objfn) :
      ($format eq "omf") ? get_code_size_using_wdis($objfn) : undef;
  die "fatal: unsupported object file format: $format\n" if !defined($code_size);
  printf STDERR "info: code size: 0x%x\n", $code_size;
  my $prev_best_objfn = $best_objfn;
  if (!defined($best_code_size) or $code_size < $best_code_size) {
    $best_code_size = $code_size;
    $best_cmd_ary = \@cmd;
    $best_cmd_type = $cmd_type;
    $best_objfn = $objfn;
    unlink($prev_best_objfn) if defined($prev_best_objfn) and $prev_best_objfn ne $objfn;
  }
}

# ---

# Most of these flags instruct GCC and other compilers to generate shorter (smaller) code.
my @gcc_flags = qw(-m32 -fno-pic -Os -march=i686 -W -Wall -Werror -U_FORTIFY_SOURCE -fno-stack-protector -fno-unwind-tables -fno-asynchronous-unwind-tables -falign-functions=1 -falign-jumps=1 -falign-loops=1 -mpreferred-stack-boundary=2 -fno-builtin -fno-ident);
my @clang_flags = qw(-m32 -fno-pic -Os -march=i686 -W -Wall -Werror -U_FORTIFY_SOURCE -fno-stack-protector -fno-unwind-tables -fno-asynchronous-unwind-tables -mstack-alignment=2 -fno-builtin -fno-ident);
my @gcc_cmds = (  # GCC and Clang C compilers.
    ["gcc", "-march=i386", "-fno-omit-frame-pointer", @gcc_flags],
    ["gcc", "-march=i686", "-fno-omit-frame-pointer", @gcc_flags],
    ["gcc", "-march=i386", "-fomit-frame-pointer", @gcc_flags],
    ["gcc", "-march=i686", "-fomit-frame-pointer", @gcc_flags],
    ["qq", "gcc-4.8", "-march=i386", "-fno-omit-frame-pointer", @gcc_flags],  # `gcc-4.8' generates shorter code than newer GCCs.
    ["qq", "gcc-4.8", "-march=i686", "-fno-omit-frame-pointer", @gcc_flags],
    ["qq", "gcc-4.8", "-march=i386", "-fomit-frame-pointer", @gcc_flags],
    ["qq", "gcc-4.8", "-march=i686", "-fomit-frame-pointer", @gcc_flags],
    ["clang", "-march=i386", "-fno-omit-frame-pointer", @clang_flags],
    ["clang", "-march=i686", "-fno-omit-frame-pointer", @clang_flags],
    ["clang", "-march=i386", "-fomit-frame-pointer", @clang_flags],
    ["clang", "-march=i686", "-fomit-frame-pointer", @clang_flags],
);
my @owcc_flags = qw(-blinux -fno-stack-check -march=i386 -mregparm=0 -W -Wall -Wextra -Werror);
my @owcc_cmds = (  # OpenWatcom C compiler. Good or optimizing for size.
    ["owcc", @owcc_flags],
    ["owcc", "-frerun-optimizer", @owcc_flags],
    ["owcc", "-floop-optimize", @owcc_flags],
    ["owcc", "-floop-optimize", "-frerun-optimizer", @owcc_flags],
);

$best_code_size = $best_cmd_ary = $best_cmd_type = undef;
print STDERR "info: running compilers to find best for: $srcfn\n";
for my $cmd_ary (@gcc_cmds) {
  run_cmd($cmd_ary, "gcc");
}
if ($is_owcc_enabled) {
  for my $cmd_ary (@owcc_cmds) {
    run_cmd($cmd_ary, "owcc");
  }
}
die "fatal: no compilers have been run\n" if !defined($best_code_size);
printf STDERR "info: found best code size is 0x%x bytes with %s command: %s\n",
    $best_code_size, $best_cmd_type, join(" ", map { shargq($_) } @$best_cmd_ary);
my $nasmfn = "$basefn.nasm";
convert_to_nasm($best_cmd_ary, $srcfn, $basefn, $best_objfn, $nasmfn, $data_alignment);
unlink($best_objfn);

__END__
