#! /bin/sh --
# by pts@fazekas.hu at Sun May 21 02:05:37 CEST 2023

# Reexec the BusyBox sh, $PATH is already set up by minicc.
test "$BUSYBOX_SH_SCRIPT" = 1 && export BUSYBOX_SH_SCRIPT=2 && exec sh -- "$0" "$@"

NL="
"
if test "$MINICC_TCCLD"; then
  # TCC accepts all these flags (and ignores -m elf_i386).
  ARGS="${MINICC_TCCLD:-ld}$NL-nostdlib$NL-m${NL}elf_i386$NL-static"
else
  # `-e _start' is needed, because without it GNU gold(1) wouldn't fail to link if _start is not defined.
  # `--fatal-warnings' is needed, because without it GNU ld(1) would happily create an executable without _start.
  ARGS="${MINICC_LD:-ld}$NL-nostdlib$NL-m${NL}elf_i386$NL-static$NL-z${NL}norelro$NL-e${NL}_start$NL--fatal-warnings"
fi
test "$MINICC_LDV" && ARGS="$ARGS$NL-v" && MINICC_LDV=-v

LDTMPOARGS=
SKIPARG=
APPENDARG=
DO_STRIP=
OUTFILE=a.out
SMART_ARCH=
SMART_LIBCD=

for ARG in "$@"; do
  if test "$SKIPARG"; then
    SKIPARG=
    continue
  elif test "$APPENDARG"; then
    test "$APPENDARG" = -o && OUTFILE="$ARG"
    ARGS="$ARGS$NL$APPENDARG$NL$ARG"
    APPENDARG=
    continue
  fi
  case "$ARG" in
   *"$NL"*) echo "fatal: unexpected newline in hooked ld arg" >&2; exit 1 ;;
   -fno-lto) ;;
   --build-id | --build-id=*) ;;
   --hash-style=*) ;;  # --hash-style=gnu
   --sysroot=*) ;;  # --sysroot=/
   --as-needed) ;;
   --smart-arch=?*) SMART_ARCH="${ARG#*=}" ;;
   --smart-libcd=?*) SMART_LIBCD="${ARG#*=}" ;;
   -static) ;;
   -sss) DO_STRIP=1 ;;  # Strip all symbols and even more (tools/elfxfix). `-s' is already added to args.
   -s) ARGS="$ARGS$NL$ARG" ;;  # Strip all symbols.
   -Map=*) ARGS="$ARGS$NL$ARG" ;;  # Pass it.
   -L*) ;;  # Many.
   -l*) echo "fatal: unsupported hooked ld library flag: $ARG" >&2; exit 1 ;;
   -z) SKIPARG=1 ;;  # -z relro. TODO(pts): Make `-z execstack' and `-z noexecstack' go through.
   -m) SKIPARG=1 ;;  # -m elf_i386.
   -o) APPENDARG="$ARG" ;;
   #-e) APPENDARG="$ARG" ;;  # -e _start (implicit).  With smart linking, we don't support overriding it.
   -[Nv]) ARGS="$ARGS$NL$ARG" ;;
   -*) echo "fatal: unsupported hooked ld flag: $ARG" >&2; exit 1 ;;
   *.a | *.o)
    if ! test -f "$ARG"; then
      if test "$MINICC_TCCLD" && test "$ARG" = ///tmp///LIBTCC1.a; then :; else
        echo "fatal: missing hooked ld source file: $ARG" >&2; exit 1
      fi
    fi
    case "$ARG" in
     //////*.o | .//////*.o) LDTMPOARGS="$LDTMPOARGS$NL$ARG"
    esac
    ARGS="$ARGS$NL$ARG"
    ;;
   *) echo "fatal: unsupported hooked ld input file extension: $ARG" >&2; exit 1 ;;
  esac
done

IFS="$NL"  # Argument splitting will happen over newlines only.

# GCC adds the .note.GNU-stack ELF section header to the .o file, adding
# 0x20 bytes unnecessary. We remove it, so ld(1) won't generate the
# PT_GNU_STACK program header in the executable. To get it, specify
# -Wl,-z,execstack or -Wl,-z,noexecstack.
for ARG in $LDTMPOARGS; do
  test "$MINICC_LDV" && echo "info: removing .note.GNU-stack from: $ARG" >&2
  "$MINICC_TOOLS/elfnostack" "$ARG" || exit "$?"
done

test "$MINICC_LDV" && echo "info: running linker:" $ARGS >&2
if test "$SMART_ARCH" && test "$SMART_LIBCD"; then
  HAD_V="$MINICC_LDV"
  SMART_TOOLS="$MINICC_TOOLS"
  DO_SMART=1
  # This code contains duplication with the $TCC $DO_SMART code in minicc.
  test "${OUTFILE#-}" = "$OUTFILE" || OUTFILE="./$OUTFILE"
  $ARGS 2>"$OUTFILE.err" >&2; EC="$?"
  if test "$EC" = 0; then
    cat "$OUTFILE.err"
    rm -f "$OUTFILE.err"
    exit
  fi
  # The regexps below work for $TCCLD, ld of $GCC, ld of $GCC (Binutils), gold of $GCC (Binutils). TODO(pts): Make it work with lld (Clang).
  # Examples for GNU ld(1) and GNU gold(1):
  # : warning: cannot find entry symbol '_start'
  # : warning: cannot find entry symbol _start; defaulting to 0000000008048074
  # : warning: entry symbol '_start' exists but is not defined
  UNDEFSYMS="$(awk '{if((((/: undefined reference to [`'\''].+'\''$/&&sub(/^.*?: undefined reference to [`'\'']/, "")||sub(/^tcc: error: undefined symbol '\''/,""))&&sub(/'\''$/,""))||(/: warning: /&&sub(/^.*: warning: (cannot find )?entry symbol '\''?/,"")&&sub(/['\'';].*/,"")&&!/ /))&&!h[$0]){h[$0]=1;printf"%s%s",c,$0;c=","}}' <"$OUTFILE.err")"
  if test -z "$UNDEFSYMS"; then
    cat "$OUTFILE.err"
    rm -f "$OUTFILE.err"
    exit "$EC"  # No undefined symbols found, this means there is another reason for the $TCC failure.
  fi
  rm -f "$OUTFILE.err" "$OUTFILE.smart.o"
  NASMARCHARG=
  test "$SMART_ARCH" = i686 || NASMARCHARG=-DCONFIG_I386
  DEF_ARG=
  for F in $(cat "$SMART_LIBCD/libc.defs"); do  # Split on any whitespace, $IFS hasn't been set yet.
    DEF_ARG="$DEF_ARG$NL$F"
  done
  NASMCMD="$SMART_TOOLS/nasm-0.98.39$NL-O0$NL-w+orphan-labels$NL-f${NL}elf$NL$NASMARCHARG$NL-DUNDEFSYMS=$UNDEFSYMS$NL$DEF_ARG$NL-o$NL$OUTFILE.smart.o$NL$SMART_LIBCD/smart.nasm"; EC="$?"
  test "$HAD_V" && echo "info: running smart nasm:" $NASMCMD >&2
  $NASMCMD; EC="$?"
  if test "$EC" = 0 && test -f "$OUTFILE.smart.o"; then :; else
    rm -f "$OUTFILE.smart.o"
    test "$EC" = 0 && EC=1
    exit "$EC"
  fi
  # /usr/bin/objdump -d "$OUTFILE.smart.o"
  ARGS="$ARGS$NL$OUTFILE.smart.o$NL$SMART_LIBCD/libc.$SMART_ARCH.a"
  test "$HAD_V" && echo "info: running linker:" $ARGS >&2  # GCC also writes to stderr.
  if test -z "$DO_STRIP"; then
    $ARGS >&2; EC="$?"
    rm -f "$OUTFILE.smart.o"
    exit "$EC"
  fi
fi
if test "$DO_STRIP"; then
  $ARGS >&2 || exit "$?"
  FIX_O_FN=
  if ! test "$MINICC_TCCLD"; then
    # TODO(pts): Choose a random one in TMPDIR?
    FIX_O_FN="$OUTFILE.bssfix.o"  # TODO(pts): Use $TMPDIR with a random filename.
    rm -f -- "$FIX_O_FN"
  fi
  PARGS=
  test "$FIX_O_FN" && PARGS="-p$NL$FIX_O_FN"
  EFARGS="$MINICC_TOOLS/elfxfix$NL-l$NL-a$NL-s$NL$PARGS$NL$MINICC_LDV$NL--$NL$OUTFILE"
  test "$MINICC_LDV" && echo "info: running extra strip:" $EFARGS >&2
  if test "$FIX_O_FN"; then
    $EFARGS >&2; EC="$?"
    if test "$EC" != 0; then
      rm -f -- "$FIX_O_FN"
      test "$DO_SMART" && rm -f "$OUTFILE.smart.o"
      exit "$EC"
    fi
    if test -f "$FIX_O_FN"; then  # elfxfix has created it.
      ARGS="$ARGS$NL$FIX_O_FN"  # Make .bss larger by the size recommended by tools/elfxfix.
      test "$MINICC_LDV" && echo "info: running linker again:" $ARGS >&2
      $ARGS >&2; EC="$?"
      if test "$EC" = 0; then
        PARGS="-r$NL$FIX_O_FN"
        EFARGS="$MINICC_TOOLS/elfxfix$NL-l$NL-a$NL-s$NL$PARGS$NL$MINICC_LDV$NL--$NL$OUTFILE"
        test "$MINICC_LDV" && echo "info: running extra strip again:" $EFARGS >&2
        $EFARGS >&2; EC="$?"
      fi
    fi
    rm -f -- "$FIX_O_FN"
    test "$DO_SMART" && rm -f "$OUTFILE.smart.o"
    exit "$EC"
  fi
  test "$DO_SMART" && rm -f "$OUTFILE.smart.o"
  ARGS="$EFARGS"
fi
exec $ARGS >&2  # We need 2 to redirect stdout to stderr of GNU `ld -v'.
