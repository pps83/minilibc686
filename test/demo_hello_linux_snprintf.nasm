;
; demo_hello_linux_snprintf.nasm: Linux i386 32-bit ELF executable program with snprintf(3) + write(2)
; by pts@fazekas.hu at Tue Jun 20 09:09:05 CEST 2023
;
; Total file size: 832 bytes.
;
; This file matches the output of GCC 7.5.0:
;
;     minicc --gcc -W -Wall -Werror test/demo_c_hello_snprintf.c
;
; Compile to Linux i386 32-bit ELF executable:
;
;     nasm -O0 -w+orphan-labels -f bin -o demo_hello_linux_snprintf.prog demo_hello_linux_snprintf.nasm &&
;     chmod +x demo_hello_linux_snprintf.prog
;
; With NASM optimizations enabled it generates the same program (bitwise
; identical):
;
;     nasm -O999999999 -w+orphan-labels -f bin -o demo_hello_linux_snprintf.prog demo_hello_linux_snprintf.nasm &&
;     chmod +x demo_hello_linux_snprintf.prog
;
; Compiling with Yasm (tested with 1.2.0 and 1.3.0) doesn't work, because
; smart.nasm uses some NASM features (labels in %if) which don't work in
; Yasm.
;
; Run it on Linux i386 or Linux amd64 systems:
;
;     ./demo_hello_linux_snprintf.prog
;
; Alternatively, compile the ELF-32 relocatable .o object file with NASM,
; and link it against minilibc686:
;
;     tools/nasm-0.98.39 -O0 -w+orphan-labels -f elf -o demo_hello_linux_snprintf.o demo_hello_linux_snprintf.nasm &&
;     minicc -o demo_hello_linux_snprintf.prog2 demo_hello_linux_snprintf.o
;
; These two compilation methods create bitwise identical executable program
; files, proving that `minicc' and its tools don't add extra overhead in
; this case. Verify it with:
;
;     cmp demo_hello_linux_snprintf.prog demo_hello_linux_snprintf.prog2
;     # (no output from cmp indicates exact match)
;

;%define CONFIG_ELF_OSABI OSABI.Linux  ; Default, good.
;%define CONFIG_ELF_OSABI OSABI.SYSV  ; Generic. This is to match an ELF executable created by GCC.
;%define CONFIG_NO_RW_SECTIONS
%define ALIGN_RODATA 1
%include "elf0.inc.nasm"

extern mini_snprintf
extern mini_write
global main
main:  ; int main(int argc, char **argv, char **envp);  /* envp is optional to declare and/or use. */
; /* Assembly code generated by GCC 7.5.0. */
; #include <stdio.h>
; #include <unistd.h>
; int main(int argc, char **argv) {
;   char buf[32];
;   int n;
;   for (;;) {
;     n = snprintf(buf, sizeof(buf) - 1, "Hello, %s!\n", argc < 2 ? "World" : argv[1]);
;     if (n + 0U < sizeof(buf)) break;
;     argc = 0;  /* Fall back to default "World" on buffer overflow. */
;   }
;   (void)!write(1, buf, n);
;   return 0;
; }
		push ebp
		mov edx, str_world
		mov ebp, esp
		push ebx  ; Save EBX.
		sub esp, byte 0x20
		cmp dword [ebp+8], byte 1  ; argc == 1?
		jle .3
		mov eax, [ebp+0xc] ; argv.
		mov edx, [eax+4]  ; argv[1].
.3:		push edx
		push str_hello
		push byte 0x1f
		lea ebx, [ebp-0x24]
		push ebx
		call mini_snprintf
		add esp, byte 0x10
		mov edx, str_world
		cmp eax, byte 0x1f
		ja .3
		push eax
		push ebx
		push byte 1
		call mini_write
		xor eax,eax
		mov ebx, [ebp-4]  ; Restore EBX.
		leave
		ret

section .rodata
str_world	db 'World', 0
str_hello	db 'Hello, %s!', 10, 0

%ifidn __OUTPUT_FORMAT__, bin
  extern mini__start  ; Needed by smart.nasm below.
  ; Include various libc functionality. mini_snprintf(...) is defined in
  ; stdio_medium_snprintf.nasm, the others are dependencies.
  %include "src/smart.nasm"  ; Defines (among others) _start which calls main(...).
  ; These below are helpfully included by smart.nasm because of UNDEFSYMS.
  ;%include "src/stdio_medium_snprintf.nasm"  ; Reimplemented by src/smart.nasm to call mini___M_vfsprintf(...) instead of mini_vfprintf(...).
  ;%include "src/stdio_medium_vfsprintf.nasm"
  ;...
%endif

_end  ; __END__
