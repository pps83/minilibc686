#! /bin/sh --
#
# minicc: compiler frontend for building with minilib686
# by pts@fazekas.hu at Sun May 21 02:21:27 CEST 2023
#

export LC_ALL=C  # To avoid surprises.

unset MYDIR
MYDIR="$(readlink "$0" 2>/dev/null)"
if test "$MYDIR"; then
  test "${MYDIR#/}" = "$MYDIR" && MYDIR="${0%/*}/$MYDIR"
else
  MYDIR="$0"
fi
MYDIR="${MYDIR%/*}"

if ! test -f "$MYDIR/gcctooldir/collect2"; then
  echo "fatal: missing tool: $MYDIR/gcctooldir/collect2" >&2
  exit 1
fi
if ! test -x "$MYDIR/gcctooldir/collect2"; then
  echo "fatal: tool not executable: $MYDIR/gcctooldir/collect2" >&2
  exit 1
fi

ARCH=i686
GCC=gcc
TCC=
TCCLD=
DO_ADD_LIB=1
DO_ADD_INCLUDEDIR=1
DO_LINK=1
SFLAG=-s
HAD_OFLAG=
HAD_V=
ARCH=i686
USE_UCLIBC=

SKIPARG=
APPENDARG=
NL="
"
ARGS=""
for ARG in "$@"; do
  if test "$SKIPARG"; then
    SKIPARG=
    continue
  elif test "$APPENDARG"; then
    ARGS="$ARGS$NL$APPENDARG$NL$ARG"
    APPENDARG=
    continue
  fi
  case "$ARG" in
   *"$NL"*) echo "fatal: unexpected newline in arg" >&2; exit 1 ;;
   --gcc) TCC=; GCC=gcc ;;
   --gcc=*) TCC=; GCC="${ARG#*=}" ;;
   --tcc) GCC=; TCC="$MYDIR"/tools/pts-tcc ;;
   --tcc=*) GCC=; TCC="${ARG#*=}" ;;
   --utcc) GCC=; TCC="$MYDIR"/tools/pts-tcc; USE_UCLIBC=1 ;;
   --utcc=*) GCC=; TCC="${ARG#*=}"; USE_UCLIBC=1 ;;
   --tccld) TCCLD="$MYDIR"/tools/pts-tcc ;;
   --tccld=*) TCCLD="${ARG#*=}" ;;
   -static | -m32 | -fno-pic | -fpic | -fno-pie | -pie | -no-pie | -flto | -fno-lto | -nostartfiles) ;;
   -march=i[36]86) ARCH="${ARG#*=}" ;;
   -march=*) echo "fatal: unsupported minicc arch flag: $ARG" >&2; exit 1 ;;
   -[Wfm]*) ARGS="$ARGS$NL$ARG" ;;
   -[DUI]*?) ARGS="$ARGS$NL$ARG" ;;
   -O*) ARGS="$ARGS$NL$ARG"; HAD_OFLAG=1 ;;
   -g*) ARGS="$ARGS$NL$ARG"; SFLAG= ;;
   -nostdlib | -nodefaultlibs) DO_ADD_LIB= ;;
   -nostdinc) DO_ADD_INCLUDEDIR= ;;
   -[cSE]) ARGS="$ARGS$NL$ARG"; DO_ADD_LIB=; DO_LINK= ;;
   -s) ARGS="$ARGS$NL$ARG" ;;
   -v) HAD_V=1; ARGS="$ARGS$NL$ARG" ;;
   -o) APPENDARG="$ARG" ;;
   -L*) echo "fatal: unsupported minicc library path flag: $ARG" >&2; exit 1 ;;
   -l*) echo "fatal: unsupported minicc library flag: $ARG" >&2; exit 1 ;;
   -*) echo "fatal: unsupported minicc flag: $ARG" >&2; exit 1 ;;
   *//////*)
    echo "fatal: too many slashes in input file name: $ARG" >&2; exit 1 ;;  # We use this to detect TMPDIR.
   *.[aocsS])
    if ! test -f "$ARG"; then echo "fatal: missing source file: $ARG" >&2; exit 1; fi
    ARGS="$ARGS$NL$ARG"
    ;;
   *) echo "fatal: unsupported input file extension: $ARG" >&2; exit 1 ;;
  esac
done

if test "$TCC" && test "$TCCLD"; then  # $TCCLD should work with $GCC
  if test "$TCCLD" != "$TCC"; then
    echo "fatal: conflicting combination of --tcc=... and --tccld=..." >&2
    exit 1
  fi
  TCCLD=
fi
if test "$TCC" && test "$GCC"; then
  echo "fatal: conflicting compilers, both --tcc=... and --gcc=..." >&2
  exit 1
fi
if test -z "$TCC" && test -z "$GCC"; then
  echo "fatal: missing compiler, neither --tcc=... nor --gcc=..." >&2
  exit 1
fi
if test "$USE_UCLIBC" && test "$DO_ADD_LIB" && test -z "$TCCLD" && test "${TCC%/pts-tcc}" = "$TCC"; then
  # That's because ///tmp///LIBTCC1.a is embedded in the tools/pts-tcc executable.
  # TODO(pts): Extract it.
  echo "fatal: currently uClibc needs pts-tcc" >&2
  exit 1
fi
if test "$USE_UBLIBC" && test "$ARCH" = i386; then
  # In fact, it was compiled for -march=pentium3, which is newer than
  # -march=i686.
  # TODO(pts): Recompile at least parts of it for -march=i686.
  echo "fatal: the bundled uClibc doesn't work on i386" >&2
  exit 1
fi

if ! test "$GCC"; then
  :
elif test "$TCCLD"; then
  export MINICC_LD=
  export MINICC_TCCLD="$TCCLD"
  export MINICC_LDV="$HAD_V"
else
  export MINICC_TCCLD=
  # gcctooldir/collect2 (== gcctooldir/ld) uses it.
  export MINICC_LD="$("$GCC" -print-prog-name=ld)"
  if test -z "$MINICC_LD"; then
    echo "fatal: linker not found by gcc: $GCC" >&2
    exit 2
  fi
  # Sometimes it's not found, but still returned nonempty.
  export MINICC_LDV="$HAD_V"
fi

OFLAG_ARGS=
if test -z "$HAD_OFLAG"; then  # Add some size-optimizing flags.
  case "$GCC" in
   "") ;;
   *clang*) OFLAG_ARGS="-Os$NL-mstack-alignment=2" ;;
   *) OFLAG_ARGS="-Os$NL-falign-functions=1$NL-falign-jumps=1$NL-falign-loops=1$NL-mpreferred-stack-boundary=2" ;;
  esac
  test "$TCC" && OFLAG_ARGS="-Os"
  OFLAG_ARGS="$OFLAG_ARGS$NL$SFLAG"  # Use -O0 to prevent.
fi
INCLUDEDIR_ARG=
DEF_ARG=
if test "$DO_ADD_INCLUDEDIR"; then
  INCLUDEDIR_ARG="-I$MYDIR/include"
  if test "$USE_UCLIBC"; then
    DEF_ARG="-D__asm__(x)=$NL-D__UCLIBC__"   # Make it ignore __asm__("mini_printf") in stdio.h, so that the linker will find the uClibc printf(...).
  else
    DEF_ARG="-D__MINILIBC686__$NL-DCONFIG_INLINE_FILENO"
  fi
fi
if test "$TCC"; then
  # TODO(pts): Does TCC really generate i386-only code?
  ARGS="$TCC$NL-m32$NL-march=$ARCH$NL-static$NL-nostdlib$NL-nostdinc$NL$OFLAG_ARGS$NL$DEF_ARG$NL$ARGS$NL$INCLUDEDIR_ARG"
else
  # This also works with TCC, but it's too much cruft.
  # The `-B$MYDIR/gcctooldir' argument makes our gcctooldir/collect2 or gcctooldir/ld run.
  # Add $INCLUDEDIR_ARG last, so that -I... specified by the user takes precedence.
  # Specifying -fcommon since -fno-common is the default since GCC 10 and Clang 11: https://maskray.me/blog/2022-02-06-all-about-common-symbols
  # DYI dietlibc 0.34 adds: gcc -Os -fomit-frame-pointer -falign-functions=1 -falign-jumps=1 -falign-loops=1 -mpreferred-stack-boundary=4
  ARGS="$TCC$NL$GCC$NL-B$MYDIR/gcctooldir$NL-m32$NL-march=$ARCH$NL-static$NL-fno-pic$NL-U_FORTIFY_SOURCE$NL-fcommon$NL-fno-stack-protector$NL-fno-unwind-tables$NL-fno-asynchronous-unwind-tables$NL-fno-builtin$NL-fno-ident$NL-fsigned-char$NL-ffreestanding$NL-fno-lto$NL-nostdlib$NL-nostdinc$NL$OFLAG_ARGS$NL$DEF_ARG$NL$ARGS$NL$INCLUDEDIR_ARG"
fi
if test "$DO_ADD_LIB"; then
  LIBWL=
  if test "$USE_UCLIBC"; then
    test "$GCC" && LIBWL=-Wl,  # -Wl, is needed, otherwise GCC will complain that it is not able to find "$LIBFN" (which doesn't exist on the filesystem).
    LIBFN=///tmp///LIBTCC1.a  # Embedded in tools/pts-tcc.
  else
    LIBFN="$MYDIR/libmin$ARCH.a"
    if ! test -f "$LIBFN"; then
      if "$MYDIR/build.sh" && test -f "$LIBFN"; then :; else
        echo "fatal: failed to build libc .a: $LIBFN" >&2
        exit 3
      fi
    fi
  fi
  if test "$TCC" || test "$TCCLD"; then  # TCC needs an explicit start*.o in the command line -- or does it?
    OBJFN="$MYDIR/need_start.o"
    if ! test -f "$OBJFN"; then
      test "$HAD_V" && echo "info: compiling: $MYDIR/need_start.nasm" >&2
      if "$MYDIR/tools/nasm-0.98.39" -O0 -w+orphan-labels -f elf -o "$OBJFN" "$MYDIR/need_start.nasm" && test -f "$OBJFN"; then :; else
        echo "fatal: failed to build need-start .o: $OBJFN" >&2
        exit 3
      fi
    fi
    ARGS="$ARGS$NL$OBJFN"
    if test "$USE_UCLIBC"; then
      OBJFN="$MYDIR/need_uclibc_main.o"
      if ! test -f "$OBJFN"; then
        test "$HAD_V" && echo "info: compiling: $MYDIR/need_uclibc_main.nasm" >&2
        if "$MYDIR/tools/nasm-0.98.39" -O0 -w+orphan-labels -f elf -o "$OBJFN" "$MYDIR/need_uclibc_main.nasm" && test -f "$OBJFN"; then :; else
          echo "fatal: failed to build need-uclibc-main .o: $OBJFN" >&2
          exit 3
        fi
      fi
      ARGS="$ARGS$NL$OBJFN"
    fi
  fi
  ARGS="$ARGS$NL$LIBWL$LIBFN"
  if test "$TCC" && test -z "$USE_UCLIBC"; then
    LIBFN="$MYDIR/libminitcc1.a"
    if ! test -f "$LIBFN"; then
      if "$MYDIR/build.sh" && test -f "$LIBFN"; then :; else
       echo "fatal: failed to build libtcc1 .a: $LIBFN" >&2
        exit 3
      fi
    fi
    ARGS="$ARGS$NL$LIBFN"
  fi
  if test "$USE_UCLIBC"; then
    OBJFN="$MYDIR/start_uclibc_linux.o"
    if ! test -f "$OBJFN"; then
      test "$HAD_V" && echo "info: compiling: $MYDIR/start_uclibc_linux.nasm" >&2
      if "$MYDIR/tools/nasm-0.98.39" -O0 -w+orphan-labels -f elf -o "$OBJFN" "$MYDIR/start_uclibc_linux.nasm" && test -f "$OBJFN"; then :; else
        echo "fatal: failed to build uclibc start .o: $OBJFN" >&2
        exit 3
      fi
    fi
    ARGS="$ARGS$NL$LIBWL$OBJFN"
  fi
fi

test "$TMPDIR" || TMPDIR=/tmp
if test "${TMPDIR#/}" = "$TMPDIR"; then TMPDIR=".//////$TMPDIR"
else TMPDIR="/////$TMPDIR"
fi
export TMPDIR
# Now $TMPDIR contains ////// (at least 6 consecutive slashes), this is how
# we are going to detect temporary .o files in the linker.

IFS="$NL"  # Argument splitting will happen over newlines only.
export MINICC_TOOLS="$MYDIR/tools"
test "$HAD_V" && echo "info: running compiler:" $ARGS >&2  # !! TODO(pts): Write to stdout if GCC also writes there.
exec $ARGS
# TODO(pts): With `-s' and linking output, strip the executable properly.
