#! /bin/sh --
#
# minicc: compiler frontend for building with minilib686
# by pts@fazekas.hu at Sun May 21 02:21:27 CEST 2023
#

export LC_ALL=C  # To avoid surprises with localized error messages etc.

unset MYDIR
MYDIR="$(readlink "$0" 2>/dev/null)"
if test "$MYDIR"; then test "${MYDIR#/}" = "$MYDIR" && MYDIR="${0%/*}/$MYDIR"
else MYDIR="$0"
fi
MYDIR="${MYDIR%/*}"
test "${MYDIR#-}" = "$MYDIR" || MYDIR="./$MYDIR"
# Use BusyBox (if available) for consistent shell and coreutils.
test -z "$BUSYBOX_SH_SCRIPT" && test -f "$MYDIR/shbin/sh" &&
    export BUSYBOX_SH_SCRIPT=1 PATH="$MYDIR/shbin:$PATH" &&
    exec sh -- "$0" "$@"

# --noenv is for reproducible builds and testing: unset all environment
# variables, and use a short hardcoded $PATH (`$MYDIR/shbin'). Toolchain
# tools (e.g. pts-tcc and ld) are always run from `$MYDIR/tools', no matter
# the $PATH. System tools (such as with `--gcc=...') will be excplicitly
# looked up on the old $PATH.
test "$1" = --noenv && shift && exec env -i PATH="$MYDIR/shbin" BUSYBOX_SH_SCRIPT=1 TMPDIR="$TMPDIR" sh -- "$0" --boxed-path "$PATH" "$@"

# --boxed is a weaker version of --noenv for reproducible builds and
# testing: keep most environment variables, but use a short hardcoded
# $PATH (`$MYDIR/shbin').
OLD_PATH="$PATH"
IS_BOXED=
while test "$1" = --boxed-path && test "$2"; do OLD_PATH="$2"; shift; shift; export PATH="$MYDIR/shbin"; IS_BOXED=1; done
while test "$1" = --boxed; do export PATH="$MYDIR/shbin"; IS_BOXED=1; shift; done
# Now $OLD_PATH contains the initial $PATH, with system tools like `gcc'.

NL="
"

if test $# = 0 || test "$1" == --help; then
  test $# = 0 && exec >&2
  echo "minicc: C compiler fronted for building small Linux i386 executables$NL""Usage: $0 [<gcc-flag>...] <file.c>$NL""There are minicc flags, e.g. --gcc, --tcc, --utcc"
  test $# = 0 && exit 1
  exit 0
fi

if ! test -f "$MYDIR/gcctooldir/dummy"; then
  echo "fatal: missing tool: $MYDIR/gcctooldir/collect2" >&2
  exit 1
fi
if ! test -x "$MYDIR/gcctooldir/dummy"; then
  echo "fatal: tool not executable: $MYDIR/gcctooldir/collect2" >&2
  exit 1
fi

ARCH=i686
GCC=gcc
TCC=
TCCLD=
DO_ADD_LIB=1
DO_ADD_INCLUDEDIR=1
DO_LINK=1
DO_COMPILE_OR_LINK=1
SFLAG=
DO_STRIP=1
WFLAGS="-W$NL-Wall$NL-Werror=implicit-function-declaration"
HAD_OFLAG=
HAD_V=
ARCH=i686
USE_UTCC=
GCC_BARG=-pipe  # Harmless default.
LIBC=
DO_SMART=
ANSIFLAG=
OUTFILE=

case "$1" in
 "" | -* | *.[aocisS]) ;;  # A flag or a source file name is not a program name.
 *)
  BASENAME="${1##*/}"
  case "$BASENAME" in
   utcc) GCC=; TCC="$MYDIR"/tools/pts-tcc; USE_UTCC=1 ;;  # Same as: --utcc
   diet) LIBC=dietlibc ;;  # Same as: --dietlibc
   xstatic) LIBC=uclibc  ;;  # Same as: --uclibc. Please note that this is not perfect, some .a and .h files are missing from pts-xstatic.
   *tcc*) TCC="$1"; GCC= ;;
   *) GCC="$1"; TCC= ;;
  esac
  shift
  ;;
esac

SKIPARG=
ARGS=
for ARG in "$@"; do
  if test "$SKIPARG"; then
    test "$SKIPARG" = -o && OUTFILE="$ARG"
    SKIPARG=
    continue
  fi
  case "$ARG" in
   *"$NL"*) echo "fatal: unexpected newline in minicc argument" >&2; exit 1 ;;
   "") echo "fatal: empty minicc argument" >&2; exit 1 ;;
   --gcc) TCC=; GCC=gcc ;;  # Doesn't work with --boxed. TODO(pts): Look it up on old $PATH.
   --gcc=*/*) TCC=; GCC="${ARG#*=}"; test "$IS_BOXED" && GCC_BARG="-B${GCC%/*}" ;;
   --gcc=*) TCC=; GCC="${ARG#*=}" ;;
   --wcc | --wcc386 | --watcom) GCC="$MYDIR/tools/wcc386"; TCC= ;;  # Specify --gcc=.../wcc386 to use a specific OpenWatcom compiler.
   --tcc) GCC=; TCC="$MYDIR"/tools/pts-tcc ;;
   --tcc=*) GCC=; TCC="${ARG#*=}" ;;
   --utcc) GCC=; TCC="$MYDIR"/tools/pts-tcc; USE_UTCC=1 ;;
   --utcc=*) GCC=; TCC="${ARG#*=}"; USE_UTCC=1 ;;
   --tccld) TCCLD="$MYDIR"/tools/pts-tcc ;;
   --tccld=*) TCCLD="${ARG#*=}" ;;
   --uclibc) LIBC=uclibc ;;
   --dietlibc | --diet | --libc=diet) LIBC=dietlibc ;;
   --eglibc) LIBC=eglibc ;;
   --minilibc) LIBC=minilibc ;;
   --libc=?*) LIBC="${ARG#*=}" ;;
   -static | -m32 | -fno-pic | -fpic | -fno-pie | -pie | -no-pie | -flto | -fno-lto | -nostartfiles) ;;
   -march=i[36]86) ARCH="${ARG#*=}" ;;
   -march=*) echo "fatal: unsupported minicc arch flag: $ARG" >&2; exit 1 ;;
   -msmart) DO_SMART=1 ;;  # Enable smart linking.
   -mno-smart) DO_SMART=0 ;;
   -Wno-no) WFLAGS= ;;  # Disable warnings. GCC and Clang accept and ignore it.
   -W*) ARGS="$ARGS$NL$ARG"; WFLAGS= ;;
   -[fm]?* | -pedantic) ARGS="$ARGS$NL$ARG" ;;
   -ansi | -std=*) ANSIFLAG="$ARG" ;;
   -[DUI]*?) ARGS="$ARGS$NL$ARG" ;;
   -O*) ARGS="$ARGS$NL$ARG"; HAD_OFLAG=1 ;;
   -g0) DO_STRIP=0 ;;
   -g*) ARGS="$ARGS$NL$ARG"; DO_STRIP=0 ;;
   -nostdlib | -nodefaultlibs) DO_ADD_LIB= ;;
   -nostdinc) DO_ADD_INCLUDEDIR= ;;
   -c) ARGS="$ARGS$NL$ARG"; DO_ADD_LIB=; DO_LINK= ;;
   -[SE]) ARGS="$ARGS$NL$ARG"; DO_ADD_LIB=; DO_LINK=; DO_COMPILE_OR_LINK= ;;
   -s) SFLAG="$ARG" ;;
   -v) HAD_V=-v; ARGS="$ARGS$NL$ARG" ;;
   -o?*) echo "fatal: unsupported minicc -o flag: $ARG" >&2; exit 1 ;;
   -o) SKIPARG="$ARG" ;;
   -L*) echo "fatal: unsupported minicc library path flag: $ARG" >&2; exit 1 ;;
   -l*) echo "fatal: unsupported minicc library flag: $ARG" >&2; exit 1 ;;
   -*) echo "fatal: unsupported minicc flag: $ARG" >&2; exit 1 ;;
   *.[aocisS])
    if ! test -f "$ARG"; then echo "fatal: missing source file: $ARG" >&2; exit 1; fi
    ARGS="$ARGS$NL$ARG"
    ;;
   *) echo "fatal: unsupported input file extension: $ARG" >&2; exit 1 ;;
  esac
done
if test "$SKIPARG"; then
  echo "fatal: missing last flag argument: $SKIPARG" >&2
  exit 1
fi

if test "$TCC" && test "$TCCLD"; then  # $TCCLD should work with $GCC
  if test "$TCCLD" != "$TCC"; then
    echo "fatal: conflicting combination of --tcc=... and --tccld=..." >&2
    exit 1
  fi
  TCCLD=
fi
if test "$TCC" && test "$GCC"; then
  echo "fatal: conflicting compilers, both --tcc=... and --gcc=..." >&2
  exit 1
fi
if test -z "$TCC" && test -z "$GCC"; then
  echo "fatal: missing compiler, neither --tcc=... nor --gcc=..." >&2
  exit 1
fi
if test "$USE_UTCC" && test "$DO_ADD_LIB" && test -z "$TCCLD" && test "${TCC%/pts-tcc}" = "$TCC"; then
  # That's because ///tmp///LIBTCC1.a is embedded in the tools/pts-tcc executable.
  # TODO(pts): Extract it.
  echo "fatal: currently uClibc with --utcc needs pts-tcc; try --uclibc instead" >&2
  exit 1
fi
if test "$USE_UTCC" && test "$ARCH" = i386; then
  echo "fatal: the --utcc bundled uClibc doesn't work on i386, it needs -march=i686" >&2
  exit 1
fi

case "$GCC" in "") ;; */*) ;; *)  # Resolve $GCC on $OLD_PATH. Useful for --noenv and --boxed.
  LOOKUP="$(PATH="$OLD_PATH"; type "$GCC" 2>/dev/null)"
  case "$LOOKUP" in
   *\ is\ /*)  LOOKUP="/${LOOKUP#*\ is\ /}"  ;;
   *\ for\ /*) LOOKUP="/${LOOKUP#*\ for\ /}" ;;  # ksh(1).
   *) echo "fatal: gcc command not found: $GCC" >&2; exit 6 ;;
  esac
  test "$IS_BOXED" && GCC="$LOOKUP" && GCC_BARG="-B${GCC%/*}"  # Don't mess with $GCC paths unless --noenv or --boxed is specified.
esac
case "$TCC" in "") ;; */*) ;; *)  # Resolve $TCCLD on $OLD_PATH. Useful for --noenv and --boxed.
  LOOKUP="$(PATH="$OLD_PATH"; type "$TCC" 2>/dev/null)"
  case "$LOOKUP" in
   *\ is\ /*)  LOOKUP="/${LOOKUP#*\ is\ /}"  ;;
   *\ for\ /*) LOOKUP="/${LOOKUP#*\ for\ /}" ;;  # ksh(1).
   *) echo "fatal: tcc command not found: $GCC" >&2; exit 6 ;;
  esac
  TCC="$LOOKUP"
esac
case "$TCCLD" in "") ;; */*) ;; *)  # Resolve $TCCLD on $OLD_PATH. Useful for --noenv and --boxed.
  LOOKUP="$(PATH="$OLD_PATH"; type "$TCCLD" 2>/dev/null)"
  case "$LOOKUP" in
   *\ is\ /*)  LOOKUP="/${LOOKUP#*\ is\ /}"  ;;
   *\ for\ /*) LOOKUP="/${LOOKUP#*\ for\ /}" ;;  # ksh(1).
   *) echo "fatal: --tccld command not found: $GCC" >&2; exit 6 ;;
  esac
  TCCLD="$LOOKUP"
esac
unset OLD_PATH

GCCBASE="/${GCC##*/}"

test "$DO_ADD_LIB" || DO_SMART=0

NEED_LIBC=
test "$DO_ADD_INCLUDEDIR" && NEED_LIBC=1
if test "$USE_UTCC"; then
  if test "$LIBC"; then
    echo "fatal: conflicting combination of --utcc and --libc=$LIBC" >&2
    exit 1
  fi
  LIBC=minilibc  # For -I... ($DO_ADD_INCLUDEDIR).
else
  test "$LIBC" || LIBC=minilibc
  test "$DO_ADD_LIB" && NEED_LIBC=1
fi
if test "$NEED_LIBC"; then
  if test -f "$MYDIR/libc/$LIBC/libc.defs"; then
    :
  elif test -d "$MYDIR/libc/$LIBC"; then
    echo "fatal: missing libc.defs file: $MYDIR/libc/$LIBC/libc.defs" >&2
    exit 4
  else
    for D in "$MYDIR/libc/$LIBC"-*; do
      if test -f "$D/libc.defs"; then
        LIBC="${D##*/}"; break  # Use the first one found. TODO(pts): Does the list get sorted?
      fi
    done
    if ! test -f "$MYDIR/libc/$LIBC/libc.defs"; then
      SFX=
      for D in "$MYDIR/libc/$LIBC"-*.sfx.7z; do
        if test -f "$D"; then
          SFX="$D"; LIBC="${D##*/}"; LIBC="${LIBC%.sfx.7z}"; break  # Use the first one found. TODO(pts): Does the list get sorted?
        fi
      done
      if test "$SFX" && test -f "$SFX"; then
        chmod +x "$SFX" 2>/dev/null
        rm -rf "$MYDIR/libc/$LIBC"
        echo "info: extracting libc sfx: $SFX" >&2
        (cd "${SFX%/*}" && ./"${SFX##*/}" -y >/dev/null)
        if ! test -f "$MYDIR/libc/$LIBC/libc.defs"; then
          echo "fatal: libc sfx extraction failed: $SFX" >&2
          exit 4
        fi
      else
        echo "fatal: libc directory not found: $MYDIR/libc/$LIBC" >&2
        exit 4
      fi
    fi
  fi
fi

if test "$DO_STRIP" = 0 || test -z "$DO_LINK"; then
  DO_STRIP=
else
  DO_STRIP=1
  SFLAG=-s
  test "$GCC" && SFLAG="-s"
fi

IS_WATCOM=
test "$GCC" && test "${GCCBASE#*[-/._]wcc386*}" != "$GCCBASE" && IS_WATCOM=1

MINICC_TCCLD=
if test -z "$DO_LINK"; then
  MINICC_LD=
elif test "$GCC"; then
  if test "$TCCLD"; then
    MINICC_LD="$TCCLD"
    MINICC_TCCLD=1
    if ! "$GCC" "$GCC_BARG" -print-search-dirs >/dev/null 2>&1; then  # Also works with Clang.
      echo "fatal: gcc not working: $GCC" >&2
      exit 2
    fi
  elif test "$IS_WATCOM"; then
    MINICC_LD=/usr/bin/ld  # !!! TODO(pts): Use bundled linker.
  else
    MINICC_LD="$(exec "$GCC" "$GCC_BARG" -print-prog-name=ld 2>/dev/null)"  # Also works with Clang.
    if test -z "$MINICC_LD"; then
      if ! "$GCC" "$GCC_BARG" -print-search-dirs >/dev/null 2>&1; then
        echo "fatal: gcc not working: $GCC" >&2; exit 2
      fi
      echo "fatal: linker not found by gcc: $GCC" >&2; exit 2
    elif test "${MINICC_LD#*$NL}" != "$MINICC_LD"; then  # Multiline report, e.g. from wcc386.
      echo "fatal: gcc failed to report linker: $GCC" >&2; exit 2
    elif test ! -f "$MINICC_LD"; then #test "${MINICC_LD#*/}" != "$MINICC_LD" && test ! -f "$MINICC_LD"
      echo "fatal: linker reported by gcc not found: $GCC" >&2; exit 2
    fi
    # Sometimes it's not found, but still returned nonempty.
  fi
else
  MINICC_LD="$TCC"
  MINICC_TCCLD=1
fi

test "$GCC_BARG" = -pipe && GCC_BARG=
case "$GCCBASE" in
 "") GCC_BARG= ;;
 *[-/._]clang* | *[-/._]wcc386*) GCC_BARG= ;;  # clang(1) and wcc386(1) (unlike gcc) don't need $GCC_BARG to find as(1).
 *) test "$DO_COMPILE_OR_LINK" || GCC_BARG= ;;  # For gcc to find as(1).
esac

OFLAG_ARGS=
if test -z "$HAD_OFLAG"; then  # Add some size-optimizing flags.
  case "$GCCBASE" in
   "") ;;
   *[-/._]clang*) OFLAG_ARGS="-Os$NL-mstack-alignment=2" ;;
   *) OFLAG_ARGS="-Os$NL-falign-functions=1$NL-falign-jumps=1$NL-falign-loops=1$NL-mpreferred-stack-boundary=2" ;;
  esac
  test "$TCC" && OFLAG_ARGS="-Os"
fi
INCLUDEDIR_ARG=
DEF_ARG=
if test "$DO_ADD_INCLUDEDIR"; then
  INCLUDEDIR_ARG="-I$MYDIR/libc/$LIBC/include"
  if test "$USE_UTCC"; then
    DEF_ARG="-D__UCLIBC__"
  else
    # TODO(pts): Ignore comments in lines starting with `#'.
    # This DEF_ARG must be valid for for nasm (for -msmart), do it should be contain only `-D...' and `-U...'.
    for F in $(cat "$MYDIR/libc/$LIBC/libc.defs"); do  # Split on any whitespace, $IFS hasn't been set yet.
      DEF_ARG="$DEF_ARG$NL$F"
    done
  fi
fi
OUTFILE_ARG=
test "$OUTFILE" && OUTFILE_ARG="-o$NL$OUTFILE"
if test "$TCC"; then
  # TODO(pts): Does TCC really generate i386-only code?
  # We don't pass $ANSIFLAG, because TCC 0.9.26 would fail for it.
  ARGS="$TCC$NL-m32$NL-march=$ARCH$NL-static$NL-nostdlib$NL-nostdinc$NL$SFLAG$NL$OFLAG_ARGS$NL$WFLAGS$NL$DEF_ARG$NL$ARGS$NL$INCLUDEDIR_ARG$NL$OUTFILE_ARG"
else
  # This also works with TCC, but it's too much cruft.
  # The `-B$MYDIR/gcctooldir' argument makes our gcctooldir/collect2 or gcctooldir/ld run.
  # Add $INCLUDEDIR_ARG last, so that -I... specified by the user takes precedence. !! TODO(pts): Does GCC do this or the opposite?
  # Specifying -fcommon since -fno-common is the default since GCC 10 and Clang 11: https://maskray.me/blog/2022-02-06-all-about-common-symbols
  # DYI dietlibc 0.34 adds: gcc -Os -fomit-frame-pointer -falign-functions=1 -falign-jumps=1 -falign-loops=1 -mpreferred-stack-boundary=4
  # !! TODO(pts): Try -mno-align-stringops. What happens with old GCC not supporting it, or Clang?
  # !! TODO(pts): Try -fno-unroll-loops -fmerge-all-constants -fno-math-errno. What happens with old GCC not supporting it, or Clang?
  # !! TODO(pts): Document -Wl,-N for merging sections .text and .data.
  ARGS="$TCC$NL$GCC$NL$GCC_BARG$NL-m32$NL-march=$ARCH$NL-static$NL-fno-pic$NL-U_FORTIFY_SOURCE$NL-fcommon$NL-fno-stack-protector$NL-fno-unwind-tables$NL-fno-asynchronous-unwind-tables$NL-fno-builtin$NL-fno-ident$NL-fsigned-char$NL-ffreestanding$NL-fno-lto$NL-nostdlib$NL-nostdinc$NL$SFLAG$NL$OFLAG_ARGS$NL$ANSIFLAG$NL$WFLAGS$NL$DEF_ARG$NL$ARGS$NL$INCLUDEDIR_ARG$NL$OUTFILE_ARG"
fi
if test "$DO_ADD_LIB"; then
  LIBWL=
  if test "$USE_UTCC"; then
    test "$GCC" && LIBWL=-Wl,  # -Wl, is needed, otherwise GCC will complain that it is not able to find "$LIBFN" (which doesn't exist on the filesystem).
    LIBFN=///tmp///LIBTCC1.a  # Embedded in tools/pts-tcc.
    if test "$DO_SMART" && test "$DO_SMART" != 0; then
      echo "fatal: --utcc doesn't support -msmart" >&2
      exit 3
    fi
  else
    LIBFN="$MYDIR/libc/$LIBC/libc.$ARCH.a"
    if ! test -f "$LIBFN"; then
      if test "$LIBC" = minilibc; then
        if "$MYDIR/build.sh" && test -f "$LIBFN"; then :; else
          echo "fatal: failed to build libc .a: $LIBFN" >&2
          exit 3
        fi
      else
        if test -f "$MYDIR/libc/$LIBC/libc.i686.a"; then
          echo "fatal: the libc wasn't compiled for -march=$ARCH, use -march=i686" >&2
          exit 3
        else
          echo "fatal: missing libc .a: $LIBFN" >&2
          exit 3
        fi
      fi
    fi
    if test -z "$DO_SMART"; then
      DO_SMART=0
      test -f "$MYDIR/libc/$LIBC/smart.nasm" && DO_SMART=1  # Use smart linking by default if available for libc.
    elif test "$DO_SMART" != 0; then
      if ! test -f "$MYDIR/libc/$LIBC/smart.nasm"; then
        echo "fatal: missing libc smart.nasm for -msmart: $MYDIR/libc/$LIBC/smart.nasm" >&2
        exit 3
      fi
    fi
  fi
  test "$DO_SMART" || DO_SMART=0  # Fallback.
  if test "$TCC" || test "$TCCLD"; then  # TCC needs an explicit start*.o in the command line -- or does it?
    OBJFN="$MYDIR/helper_lib/need_start.o"
    if ! test -f "$OBJFN"; then
      # !! TODO(pts): Let build.sh take care of this.
      test "$HAD_V" && echo "info: compiling: $MYDIR/helper_lib/need_start.nasm" >&2
      if "$MYDIR/tools/nasm-0.98.39" -O0 -w+orphan-labels -f elf -o "$OBJFN" "$MYDIR/helper_lib/need_start.nasm" && test -f "$OBJFN"; then :; else
        echo "fatal: failed to build need-start .o: $OBJFN" >&2
        exit 3
      fi
    fi
    ARGS="$ARGS$NL$OBJFN"
    if test "$USE_UTCC"; then
      OBJFN="$MYDIR/helper_lib/need_uclibc_main.o"
      if ! test -f "$OBJFN"; then
        # !! TODO(pts): Let build.sh take care of this.
        test "$HAD_V" && echo "info: compiling: $MYDIR/helper_lib/need_uclibc_main.nasm" >&2
        if "$MYDIR/tools/nasm-0.98.39" -O0 -w+orphan-labels -f elf -o "$OBJFN" "$MYDIR/helper_lib/need_uclibc_main.nasm" && test -f "$OBJFN"; then :; else
          echo "fatal: failed to build need-uclibc-main .o: $OBJFN" >&2
          exit 3
        fi
      fi
      ARGS="$ARGS$NL$OBJFN"
    fi
  fi
  test "$DO_SMART" = 0 && ARGS="$ARGS$NL$LIBWL$LIBFN"
  if test "$TCC" && test -z "$USE_UTCC"; then
    LIBFN="$MYDIR/helper_lib/libminitcc1.a"
    if ! test -f "$LIBFN"; then
      if "$MYDIR/build.sh" && test -f "$LIBFN"; then :; else
       echo "fatal: failed to build libtcc1 .a: $LIBFN" >&2
        exit 3
      fi
    fi
    test "$DO_SMART" = 0 && ARGS="$ARGS$NL$LIBFN"
  fi
  if test "$USE_UTCC"; then
    # OBJFN="$MYDIR/helper_lib/start_uclibc_linux.o"  # Not needed.
    OBJFN="///tmp///crt1.o"  # Embedded in the tools/pts-tcc executable, same functionality as start_uclibc_linux.o.
    ARGS="$ARGS$NL$LIBWL$OBJFN"
  fi
fi
test "$DO_SMART" || DO_SMART=0  # Fallback.

test "$TMPDIR" || TMPDIR=/tmp
test "${TMPDIR#/}" = "$TMPDIR" && TMPDIR="./$TMPDIR"  # Make it not a command-line flag (-...).
export TMPDIR

IFS="$NL"  # Argument splitting will happen over newlines only.
if test "$DO_LINK"; then
  test "$OUTFILE" || OUTFILE=a.out
  test "${OUTFILE#-?}" = "$OUTFILE" || OUTFILE="./$OUTFILE"  # Make it not a command-line flag (-...).
fi

if test "$GCC"; then
  # TCC accepts all these flags (and ignores `-m elf_i386' if passed).
  LDARGS="${MINICC_LD:-ld}$NL-nostdlib$NL-static"
  if test -z "$MINICC_TCCLD"; then
    # `-e _start' is needed, because without it GNU gold(1) wouldn't fail to link if _start is not defined.
    # `--fatal-warnings' is needed, because without it GNU ld(1) would happily create an executable without _start.
    LDARGS="$LDARGS$NL-m${NL}elf_i386$NL-z${NL}norelro$NL-e${NL}_start$NL--fatal-warnings"
  fi
  CCARGS="$GCC"
  test "$DO_LINK" && CCARGS="$CCARGS$NL-c"
  FILEARGS=
  SKIPARG=
  CCMODE=
  for ARG in --skiparg $ARGS; do
    if test "$SKIPARG"; then SKIPARG=; continue; fi
    case "$ARG" in
     *"$NL"*) echo "fatal: unexpected newline in minicc generated argument" >&2; exit 7 ;;
     "") echo "fatal: empty minicc generated argument" >&2; exit 7 ;;
     --skiparg) SKIPARG=1 ;;
     -o) SKIPARG="$ARG" ;;
     -Wl,) ;;
     -Wl,-*) LDARGS="$LDARGS$NL${ARG#-Wl,}" ;;  # TODO(pts): Replace comma with $NL.
     -Wl,*) FILEARGS="$FILEARGS$NL--ldfile=$ARG" ;;
     -s) LDARGS="$LDARGS$NL$ARG" ;;
     -[cSE])
       if test "$DO_LINK"; then echo "fatal: output mode not supported when linking: $ARG" >&2; exit 7; fi
       CCMODE="$ARG"
       CCARGS="$CCARGS$NL$ARG"
       ;;
     -*) CCARGS="$CCARGS$NL$ARG" ;;
     *.[ao]) FILEARGS="$FILEARGS$NL--ldfile=$ARG" ;;
     *.c) FILEARGS="$FILEARGS$NL--srcfile=$ARG" ;;
     *.[cisS])
       if test "$IS_WATCOM"; then
         echo "fatal: unsupported minicc wcc386 source file type: $ARG" >&2; exit 5;  # !! TODO(pts): Does wcc386 support *.i?
       fi
       FILEARGS="$FILEARGS$NL--srcfile=$ARG"
       ;;
     *) echo "fatal: unsupported input file extension: $ARG" >&2; exit 7 ;;
    esac
  done
  if test "$SKIPARG"; then
    echo "fatal: missing last flag argument for minicc wcc386: $SKIPARG" >&2
    exit 7
  fi
  if test -z "$FILEARGS"; then
    echo "fatal: no source files specified" >&2
    exit 7
  fi
  LDARGS="$LDARGS$NL$OUTFILE_ARG"
  # echo "CCARGS: $CCARGS" >&2; echo "LDARGS: $LDARGS" >&2; echo "FILEARGS: $FILEARGS" >&2

  # If $IS_WATCOM, convert $CCARGS for wcc386.
  if test "$IS_WATCOM"; then
    if test "$DO_ADD_INCLUDEDIR"; then
      if ! test -f "$MYDIR/libc/$LIBC/include/_preincl.h"; then
        echo "fatal: libc not prepared for wcc386, file missing: $MYDIR/libc/$LIBC/include/_preincl.h" >&2
        exit 5
      fi
    fi
    WSFLAG=
    WJFLAG=-j  # `signed char' is GCC default.
    WARGS=
    test "$HAD_V" || WARGS="$WARGS$NL-q"
    WARGS="$WARGS$NL-bt=linux$NL-fr"
    unset INCLUDE  # Don't let wcc386 find any system #include etc. file.
    unset WATCOM  # Don't let wcc386 find any system #include etc. file.
    SKIPARG=
    for ARG in --skiparg $CCARGS; do
      if test "$SKIPARG"; then SKIPARG=; continue; fi
      case "$ARG" in
       *"$NL"*) echo "fatal: unexpected newline in minicc wcc386 argument" >&2; exit 5 ;;
       "") echo "fatal: empty minicc wcc386 argument" >&2; exit 5 ;;
       --skiparg) SKIPARG=1 ;;
       -B?*) ;;  # Just to be sure. minicc doesn't add it for wcc386.
       -v) ;;  # Already processed as $HAD_V.
       -ansi | -std=c89) WARGS="$WARGS$NL-za" ;;
       -std=c99) WARGS="$WARGS$NL-za99" ;;
       -std=ow) WARGS="$WARGS$NL-ze" ;;
       -pedantic) ;;
       -m32 | -static | -fno-pic | -fcommon | -fno-unwind-tables | -fno-asynchronous-unwind-tables | -fno-builtin | -fno-ident | -ffreestanding | -fno-lto | -nostdinc | -falign-functions=* | -falign-jumps=* | -falign-loops=* | -mpreferred-stack-boundary=* | -g0 | -Wno-no) ;;
       -U_FORTIFY_SOURCE) ;;
       -fno-stack-protector) WSFLAG=-s ;;
       -fsigned-char | -fno-unsigned-char) WJFLAG=-j ;;
       -fno-signed-char | -funsigned-char) WJFLAG= ;;
       -finline-fp-rounding) WARGS="$WARGS$NL-zri" ;;  # To prevent the call to __CHP.
       -fstack-protector) WSFLAG= ;;
       -march=i386) WARGS="$WARGS$NL-3r" ;;
       -march=i686) WARGS="$WARGS$NL-6r" ;;  # !! TODO(pts): Does it generate larger code? Then change the default with -Os.
       -mno-80387 | -msoft-float) WARGS="$WARGS$NL-fpc" ;;  # Useful for string merging in .rodata.str1.1.
       -m80387 | -mhard-float | -mhard-emu-float) WARGS="$WARGS$NL-fpi" ;;  # Default.  # -mhard-float would be `-fpi87'.
       -nostdlib) WARGS="$WARGS$NL-zl$NL-zld$NL-zls" ;;  # minicc always has it.
       -W | -Wextra) WARGS="$WARGS$NL-wx" ;;
       -Wall) WARGS="$WARGS$NL-w4" ;;
       -Werror) WARGS="$WARGS$NL-we" ;;
       -Werror=*) ;;  # No per-warning control, just ignore for simplicity.
       -w) WARGS="$WARGS$NL-w0" ;;
       -Wlevel[0-9]*) WARGS="$WARGS$NL-w${ARG#-Wlevel}" ;;
       -Wno-n[0-9]*) WARGS="$WARGS$NL-wcd=${ARG#-Wno-n}" ;;
       -Wn[0-9]*) WARGS="$WARGS$NL-wce=${ARG#-Wn}" ;;
       -H) WARGS="$WARGS$NL-fti" ;;
       -O0) WARGS="$WARGS$NL-od" ;;
       -O1) WARGS="$WARGS$NL-oil" ;;
       -O2) WARGS="$WARGS$NL-onatx" ;;
       -O3) WARGS="$WARGS$NL-onatxl+" ;;
       -Os) WARGS="$WARGS$NL-os" ;;
       -Ot) WARGS="$WARGS$NL-ot" ;;
       -O)  WARGS="$WARGS$NL-oil" ;;
       # !! TODO(pts): Copy more flag translations from owcc.c.
       -c) ;;
       -S) echo "fatal: assembly generation not supported by minicc wcc386" >&2; exit 5 ;;
       -E) echo "fatal: preprocessing not supported by minicc wcc386" >&2; exit 5 ;;  # !! TODO(pts): There is `wcc386 -pl' for this.
       -[DUI]?*) WARGS="$WARGS$NL$ARG" ;;
       -g) echo "fatal: debug generation not supported by minicc wcc386" >&2; exit 5 ;;  # !! TODO(pts): Add flags like owcc.c.
       -*) echo "fatal: unsupported minicc wcc386 flag: $ARG" >&2; exit 5 ;;
       *) echo "fatal: assert: input file not allowed: $ARG" >&2; exit 5 ;;
      esac
    done
    CCARGS="$GCC$NL$WSFLAG$NL$WJFLAG$NL$WARGS"
    # TODO(pts): Add -m... flag for string optimizations (like in minilibc32).
  fi

  # Now create all the temporary .o files which will be written to $GCC.
  TMPOFILES=
  CCFILEARGS=
  OEXT=o
  test "$IS_WATCOM" && OEXT=obj
  for ARG in $FILEARGS; do
    case "$ARG" in
     --srcfile=?*)
      if test "$DO_LINK"; then
        TMPOFILE="$("$MYDIR"/tools/mktmpf "$TMPDIR"/minicc.@@@@@@."$OEXT")"  # Already creates the file.
        if test -z "$TMPOFILE"; then
          echo "fatal: error creating temporary .o file" >&2
          rm -f $TMPOFILES
          exit 7
        fi
        TMPOFILES="$TMPOFILES$NL$TMPOFILE"
        test "$IS_WATCOM" && TMPOFILES="$TMPOFILES$NL${TMPOFILE%.*}.o"
        LDARGS="$LDARGS$NL${TMPOFILE%.*}.o"
      else
        TMPOFILE="${ARG#--*=}"
        if test "$CCMODE" = -c; then TMPOFILE="${TMPOFILE%.*}"."$OEXT"  # !! TODO(pts): Create it in $TMPDIR for $IS_WATCOM.
        elif test "$CCMODE" = -S; then TMPOFILE="${TMPOFILE%.*}".S
        else TMPOFILE=-  # For -E.
        fi
      fi
      CCFILEARGS="$CCFILEARGS$NL--tmpofile=$TMPOFILE$NL--srcfile=${ARG#--*=}"
      ;;
     --ldfile=?*) LDARGS="$LDARGS$NL${ARG#--*=}" ;;
     *) echo "fatal: assert: bad filearg: $ARG" >&2; exit 7 ;;
    esac
  done
  # echo "CCARGS: $CCARGS" >&2; echo "LDARGS: $LDARGS" >&2; echo "FILEARGS: $FILEARGS" >&2; echo "CCFILEARGS:$CCFILEARGS" >&2; rm -f $TMPOFILES; exit 7

  # Now run `$GCC -c -o ... ...' for each file in $CCFILEARGS.
  TMPOFILE=
  FOFLAG="-o$NL"
  test "$IS_WATCOM" && FOFLAG=-fo=
  for ARG in $CCFILEARGS; do
    case "$ARG" in
     --tmpofile=?*)
      if test "$TMPOFILE"; then
        echo "fatal: assert: duplicate --tmpofile=..." >&2; rm -f $TMPOFILES; exit 7;
      fi
      TMPOFILE="${ARG#--*=}"
      ;;
     --srcfile=?*)
      if test -z "$TMPOFILE"; then
        echo "fatal: assert: missing --tmpofile=..." >&2; rm -f $TMPOFILES; exit 7;
      fi
      OFLAG=
      if test "$TMPOFILE" = -; then
        test "$HAD_V" && echo "info: running compiler:" $CCARGS "${ARG#--*=}" >&2  # GCC also writes to stderr.
        $CCARGS "${ARG#--*=}"; EC="$?"
      else
        if test "$IS_WATCOM" && test "${TMPOFILE#.}" != "$TMPOFILE"; then
          # Otherwise wcc386 would prepend a basename from $WGSRC.
          echo "fatal: object filename for minicc wcc386 must not start with a dot: $TMPOFILE" >&2; rm -f $TMPOFILES; exit 7;
        fi
        test "$HAD_V" && echo "info: running compiler:" $CCARGS $FOFLAG"$TMPOFILE" "${ARG#--*=}" >&2  # GCC also writes to stderr.
        $CCARGS $FOFLAG"$TMPOFILE" "${ARG#--*=}"; EC="$?"
      fi
      if test "$EC" != 0; then rm -f $TMPOFILES; exit "$EC"; fi
      if test "$IS_WATCOM"; then
        EFARGS="$MYDIR/tools/omf2elf$NL-h$NL$HAD_$V$NL-o$NL${TMPOFILE%.*}.o$NL$TMPOFILE"
        test "$HAD_V" && echo "info: running OMF converter:" $EFARGS >&2
        $EFARGS; EC="$?"
        if test "$EC" != 0; then rm -f $TMPOFILES; exit "$EC"; fi
      elif test "$DO_LINK"; then
        # GCC adds the .note.GNU-stack ELF section header to the .o file, adding
        # 0x20 bytes unnecessary. We remove it, so ld(1) won't generate the
        # PT_GNU_STACK program header in the executable. To get it, specify
        # -Wl,-z,execstack or -Wl,-z,noexecstack.
        #
        # !! TODO(pts): Also remove from .o files explicitly specified, they
        #    may have been created by a previous `minicc -c'.
        test "$HAD_V" && echo "info: removing .note.GNU-stack from: $TMPOFILE" >&2
        "$MYDIR/tools/elfnostack" "$TMPOFILE"; EC="$?"
        if test "$EC" != 0; then rm -f $TMPOFILES; exit "$EC"; fi
      fi
      TMPOFILE=
      ;;
     *) echo "fatal: assert: bad ccfilearg: $ARG" >&2; rm -f $TMPOFILES; exit 7 ;;
    esac
  done
  if test "$TMPOFILE"; then
    echo "fatal: assert: unused --tmpofile=..." >&2; rm -f $TMPOFILES; exit 7;
  fi
  if test -z "$DO_LINK"; then
    rm -f $TMPOFILES; exit "$EC"
  fi
  ARGS="$LDARGS"
  WHAT=linker
  unset LDARGS CCARGS CCFILEARGS FILEARGS TMPOFILE FOFLAG CCMODE OEXT
  # Don't forget: rm -f $TMPOFILES
else
  TMPOFILES=
  WHAT=compiler
fi

if test "$DO_SMART" != 0; then  # Smart linking.
  LIBMINITCC1=
  test "$TCC" && LIBMINITCC1="$MYDIR/helper_lib/libminitcc1.a"
  test "$HAD_V" && echo "info: running $WHAT:" $ARGS >&2  # GCC also writes to stderr.
  $ARGS $LIBMINITCC1 2>"$OUTFILE.err"; EC="$?"  # TODO(pts): Write a C program to extract undefined references and display errors in a streaming way. (Some errors like `In ...' need to be buffered.)
  if test "$EC" = 0; then
    cat "$OUTFILE.err"
    rm -f "$OUTFILE.err" $TMPOFILES
  else
    # The regexps below work for $TCCLD, ld of $GCC, ld of $GCC (Binutils), gold of $GCC (Binutils). TODO(pts): Make it work with lld (Clang).
    # Examples for GNU ld(1) and GNU gold(1):
    # : warning: cannot find entry symbol '_start'
    # : warning: cannot find entry symbol _start; defaulting to 0000000008048074
    # : warning: entry symbol '_start' exists but is not defined
    UNDEFSYMS="$(awk '{if((((/: undefined reference to [`'\''].+'\''$/&&sub(/^.*?: undefined reference to [`'\'']/, "")||sub(/^tcc: error: undefined symbol '\''/,""))&&sub(/'\''$/,""))||(/: warning: /&&sub(/^.*: warning: (cannot find )?entry symbol '\''?/,"")&&sub(/['\'';].*/,"")&&!/ /))&&!h[$0]){h[$0]=1;printf"%s%s",c,$0;c=","}}' <"$OUTFILE.err")"
    if test -z "$UNDEFSYMS"; then
      cat "$OUTFILE.err"
      rm -f "$OUTFILE.err" $TMPOFILES
      exit "$EC"  # No undefined symbols found, this means there is another reason for the $TCC failure.
    fi
    rm -f "$OUTFILE.err" "$OUTFILE.smart.o"
    NASMARCHARG=
    test "$ARCH" = i686 || NASMARCHARG=-DCONFIG_I386
    DEF_ARG=
    for F in $(cat "$MYDIR/libc/$LIBC/libc.defs"); do  # Split on any whitespace, $IFS hasn't been set yet.
      DEF_ARG="$DEF_ARG$NL$F"
    done
    NASMCMD="$MYDIR/tools/nasm-0.98.39$NL-O0$NL-w+orphan-labels$NL-f${NL}elf$NL$NASMARCHARG$NL-DUNDEFSYMS=$UNDEFSYMS$NL$DEF_ARG$NL-o$NL$OUTFILE.smart.o$NL$MYDIR/libc/$LIBC/smart.nasm"; EC="$?"
    test "$HAD_V" && echo "info: running smart nasm:" $NASMCMD >&2
    $NASMCMD; EC="$?"
    if test "$EC" = 0 && test -f "$OUTFILE.smart.o"; then :; else
      rm -f "$OUTFILE.smart.o" $TMPOFILES
      test "$EC" = 0 && EC=1
      exit "$EC"
    fi
    # /usr/bin/objdump -d "$OUTFILE.smart.o"
    # /usr/bin/nm "$OUTFILE.smart.o"
    # ---
    ARGS="$ARGS$NL$OUTFILE.smart.o$NL$MYDIR/libc/$LIBC/libc.$ARCH.a$NL$LIBMINITCC1"
    test "$HAD_V" && echo "info: running $WHAT again:" $ARGS >&2  # GCC also writes to stderr.
    $ARGS >&2; EC="$?"  # Redirect linker stdout to stderr.
    rm -f "$OUTFILE.smart.o" $TMPOFILES
    test "$EC" = 0 || exit "$EC"
  fi
else
  test "$HAD_V" && echo "info: running $WHAT:" $ARGS >&2  # GCC also writes to stderr.
  $ARGS >&2; EC="$?"  # Redirect linker stdout to stderr.
  rm -f $TMPOFILES
  test "$EC" = 0 || exit "$EC"
fi

if test "$DO_STRIP"; then
  FIX_O_FN=
  if ! test "$MINICC_TCCLD"; then
    FIX_O_FN="$("$MYDIR"/tools/mktmpf "$TMPDIR"/elfxfix.@@@@@@.o)"  # Already creates the file.
    if test -z "$FIX_O_FN"; then
      echo "fatal: error creating temporary .o file" >&2; exit 7
    fi
  fi
  PARGS=
  test "$FIX_O_FN" && PARGS="-p$NL$FIX_O_FN"
  EFARGS="$MYDIR/tools/elfxfix$NL-l$NL-a$NL-s$NL$PARGS$NL$HAD_V$NL--$NL$OUTFILE"
  test "$HAD_V" && echo "info: running extra strip:" $EFARGS >&2
  if test "$FIX_O_FN"; then
    $EFARGS >&2; EC="$?"
    if test "$EC" != 0; then
      rm -f -- "$FIX_O_FN"
      test "$DO_SMART" && rm -f "$OUTFILE.smart.o"
      exit "$EC"
    fi
    if test -s "$FIX_O_FN"; then  # elfxfix has written to it.
      ARGS="$ARGS$NL$FIX_O_FN"  # Make .bss larger by the size recommended by tools/elfxfix.
      test "$HAD_V" && echo "info: running linker after elfxfix:" $ARGS >&2
      $ARGS >&2; EC="$?"
      if test "$EC" = 0; then
        PARGS="-r$NL$FIX_O_FN"
        EFARGS="$MYDIR/tools/elfxfix$NL-l$NL-a$NL-s$NL$PARGS$NL$HAD_V$NL--$NL$OUTFILE"
        test "$HAD_V" && echo "info: running extra strip again:" $EFARGS >&2
        $EFARGS >&2; EC="$?"
      fi
    fi
    rm -f -- "$FIX_O_FN"
    test "$DO_SMART" && rm -f "$OUTFILE.smart.o"
    test "$EC" = 0 || exit "$EC"
  else
    $EFARGS || exit "$?"
  fi
fi
