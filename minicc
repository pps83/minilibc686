#! /bin/sh --
#
# minicc: compiler frontend for building with minilib686
# by pts@fazekas.hu at Sun May 21 02:21:27 CEST 2023
#
# !! Enable -fomit-frame-pointer by default, see how smaller it gets with GCC. OpenWatcom definitely benefits.
#

export LC_ALL=C  # To avoid surprises with localized error messages etc.

unset MYDIR
MYDIR="$(readlink "$0" 2>/dev/null)"
if test "$MYDIR"; then test "${MYDIR#/}" = "$MYDIR" && MYDIR="${0%/*}/$MYDIR"
else MYDIR="$0"
fi
MYDIR="${MYDIR%/*}"
test "${MYDIR#-}" = "$MYDIR" || MYDIR="./$MYDIR"
# Use BusyBox (if available) for consistent shell and coreutils.
test -z "$BUSYBOX_SH_SCRIPT" && test -f "$MYDIR/shbin/sh" &&
    export BUSYBOX_SH_SCRIPT=1 PATH="$MYDIR/shbin:$PATH" &&
    exec sh -- "$0" "$@"

# --noenv is for reproducible builds and testing: unset all environment
# variables, and use a short hardcoded $PATH (`$MYDIR/shbin'). Toolchain
# tools (e.g. pts-tcc and ld) are always run from `$MYDIR/tools', no matter
# the $PATH. System tools (such as with `--gcc=...') will be excplicitly
# looked up on the old $PATH.
test "$1" = --noenv && shift && exec env -i PATH="$MYDIR/shbin" BUSYBOX_SH_SCRIPT=1 TMPDIR="$TMPDIR" sh -- "$0" --boxed-path "$PATH" "$@"

# --boxed is a weaker version of --noenv for reproducible builds and
# testing: keep most environment variables, but use a short hardcoded
# $PATH (`$MYDIR/shbin').
OLD_PATH="$PATH"
IS_BOXED=
while test "$1" = --boxed-path && test "$2"; do OLD_PATH="$2"; shift; shift; export PATH="$MYDIR/shbin"; IS_BOXED=1; done
while test "$1" = --boxed; do export PATH="$MYDIR/shbin"; IS_BOXED=1; shift; done
# Now $OLD_PATH contains the initial $PATH, with system tools like `gcc'.

NL="
"

if test $# = 0 || test "$1" == --help; then
  test $# = 0 && exec >&2
  echo "minicc: C compiler fronted for building small Linux i386 executables$NL""Usage: $0 [<gcc-flag>...] <file.c>$NL""There are minicc flags, e.g. --watcom, --gcc, --tcc, --utcc"
  test $# = 0 && exit 1
  exit 0
fi

if ! test -f "$MYDIR/gcctooldir/dummy"; then
  echo "fatal: missing tool: $MYDIR/gcctooldir/collect2" >&2
  exit 1
fi
if ! test -x "$MYDIR/gcctooldir/dummy"; then
  echo "fatal: tool not executable: $MYDIR/gcctooldir/collect2" >&2
  exit 1
fi

ARCH=i686
GCC="$MYDIR/tools/wcc386"  # Use the OpenWatcom C compiler by default.
TCC=
DO_ADD_LIB=1
DO_ADD_INCLUDEDIR=1
DO_LINK=1
DO_COMPILE_OR_LINK=1
SFLAG=
DO_STRIP=1
WFLAGS="-W$NL-Wall$NL-Werror-implicit-function-declaration"
HAD_OFLAG=
HAD_V=
HAD_OFILE=
ARCH=i686
USE_UTCC=
GCC_BARG=-pipe  # Harmless default.
LIBC=
DO_SMART=
ANSIFLAG=
OUTFILE=
MINICC_LD=  # The default will be "$MYDIR"/tools/ld, using --minild.
DO_ARGC=  # Argument 1 of main(...).
DO_ARGV=  # Argument 2 of main(...).
DO_ENVP=  # Argument 3 of main(...).
HAD_TRADITIONAL=

case "$1" in
 "" | -* | *.[aocisS]) ;;  # A flag or a source file name is not a program name.
 *)
  BASENAME="${1##*/}"
  case "$BASENAME" in
   utcc) GCC=; TCC="$MYDIR"/tools/pts-tcc; USE_UTCC=1 ;;  # Same as: --utcc
   diet) LIBC=dietlibc ;;  # Same as: --dietlibc
   xstatic) LIBC=uclibc  ;;  # Same as: --uclibc. Please note that this is not perfect, some .a and .h files are missing from pts-xstatic.
   *tcc*) TCC="$1"; GCC= ;;
   owcc) GCC="$MYDIR/tools/wcc386"; TCC= ;;
   *) GCC="$1"; TCC= ;;
  esac
  shift
  ;;
esac

SKIPARG=
ARGS=
for ARG in "$@"; do
  if test "$SKIPARG"; then
    test "$SKIPARG" = -o && OUTFILE="$ARG"
    SKIPARG=
    continue
  fi
  case "$ARG" in
   *"$NL"*) echo "fatal: unexpected newline in minicc argument" >&2; exit 1 ;;
   "") echo "fatal: empty minicc argument" >&2; exit 1 ;;
   --gcc) TCC=; GCC=gcc ;;  # Doesn't work with --boxed. TODO(pts): Look it up on old $PATH.
   --gcc=*/*) TCC=; GCC="${ARG#*=}"; test "$IS_BOXED" && GCC_BARG="-B${GCC%/*}" ;;
   --gcc=*) TCC=; GCC="${ARG#*=}" ;;
   --wcc | --wcc386 | --watcom) GCC="$MYDIR/tools/wcc386"; TCC= ;;  # Specify --gcc=.../wcc386 to use a specific OpenWatcom compiler.
   --tcc) GCC=; TCC="$MYDIR"/tools/pts-tcc ;;
   --tcc=*) GCC=; TCC="${ARG#*=}" ;;
   --utcc) GCC=; TCC="$MYDIR"/tools/pts-tcc; USE_UTCC=1 ;;
   --utcc=*) GCC=; TCC="${ARG#*=}"; USE_UTCC=1 ;;
   --tccld) MINICC_LD="$MYDIR"/tools/pts-tcc ;;
   --ld=* | --tccld=*) MINICC_LD="${ARG#*=}" ;;
   --minild) MINICC_LD="$MYDIR"/tools/ld ;;
   --gccld) MINICC_LD=///gcc ;;
   --uclibc) LIBC=uclibc ;;
   --dietlibc | --diet | --libc=diet) LIBC=dietlibc ;;
   --eglibc) LIBC=eglibc ;;
   --minilibc) LIBC=minilibc ;;
   --libc=?*) LIBC="${ARG#*=}" ;;
   -traditional*) HAD_TRADITIONAL="$ARG"; ARGS="$ARGS$NL$ARG" ;;  # Includes -traditional-cpp.
   -static | -m32 | -fno-pic | -fno-PIC | -fno-pie | -fno-PIE | -no-pie | -nostartfiles | -Bstatic | -dn | -non_shared | -static-libgcc | -fplt | -fno-plt | -fno-use-linker-plugin | -no-cacnonical-prefixes | --no-sysroot-suffix) ;;
   -fno-lto) ;;  # Passing it to compiling gcc(1) or GCC cc1 doesn't seem to make a difference in the output .s file. So we just omit it for simplicity.
   -flto | -fuse-linker-plugin) echo "fatal: unsupported LTO flag: $ARG" >&2; exit 1 ;;  # LTO is link-time optimization.
   -fno-rtti | -fno-exceptions | -nostdinc++) ;;  # Ignore some C++ flags. minicc otherwise doesn't support C++.
   -shared | -dynamic | -Bshared | -Bdynamic | -Bshareable | -rpath* | -dy | -call-shared | -shared-libgcc | -rdynamic) echo "fatal: unsupported shared library flag: $ARG" >&2; exit 1 ;;
   --sysroot | --sysroot= | -B | -B* | --gcc-toolchain | --gcc-toolchain | -target | -target=* | -sysld*) echo "fatal: unsupported toolchain flag: $ARG" >&2; exit 1 ;; # These are GCC and/or clang flags.
   -p | -pg | --profile) echo "fatal: unsupported profiling flag: $ARG" >&2; exit 1 ;;
   -m64 | -march=x86_64 | -imultiarch) echo "fatal: unsupported 64-bit flag: $ARG" >&2; exit 1 ;;
   -pie | -fpic | -fPIC | -fpie | -fPIE) echo "fatal: unsupported position-independent code flag: $ARG" >&2; exit 1 ;;  # TODO(pts): Add support. It is not useful anyway for static linking, it just adds bloat.
   -idirafter | -imultilib | -iplugindir* | -iquote | -isysroot | -system | -iwithprefix | -iwithprefixbefore) echo "fatal: unsupported include dir flag, use -I instead: $ARG" >&2; exit 1 ;;
   -include | -imacros | -iprefix) echo "fatal: unsupported include file flag: $ARG" >&2; exit 1 ;;  # TODO(pts): Adding support is relatively easy, we just have to pass these to GCC.
   -mregparm=0) ;;  # Default GCC cdecl calling convention.
   -mregparm=* | -msseregparm | -mrtd | -mno-rtd) echo "fatal: unsupported calling convention flag: $ARG" >&2; exit 1 ;;  # FYI owcc -mregparm=1 ... -mregparm=3 activate __watcall rather than __regparm__(3).
   # TODO(pts): Try to adjust -malign-data=type and -mlarge-data-threshold=threshold to avoid alignment of some arrays to 0x20 bytes.
   -march=i[36]86) ARCH="${ARG#*=}" ;;
   -march=*) echo "fatal: unsupported minicc arch flag: $ARG" >&2; exit 1 ;;
   -msmart) DO_SMART=1 ;;  # Enable smart linking.
   -mforce-smart) DO_SMART=2 ;;  # Force smart linking even for self-contained programs without undefined symbols. Most users need -msmart instead, that's faster.
   -mno-smart) DO_SMART=0 ;;
   -margc) DO_ARGC=1 ;;
   -mno-argc) DO_ARGC=0 ;;
   -margv) DO_ARGV=1 ;;
   -mno-argv) DO_ARGV=0 ;;
   -menvp) DO_ENVP=1 ;;
   -mno-envp) DO_ENVP=0 ;;
   -Wno-no) WFLAGS= ;;  # Disable warnings. GCC and Clang accept and ignore it.
   -Werror[-=]implicit-function-declaration) ARGS="$ARGS$NL-Werror-implicit-function-declaration"; WFLAGS= ;;  # GCC 4.1 supports only -Werror-implicit-function-declaration, GCC >=4.2 supports it and also -Werror=implicit-function-declaration.
   -W*) ARGS="$ARGS$NL$ARG"; WFLAGS= ;;
   -[fm]?* | -pedantic) ARGS="$ARGS$NL$ARG" ;;
   -ansi | -std=*) ANSIFLAG="$ARG" ;;
   -[DUI]*?) ARGS="$ARGS$NL$ARG" ;;
   -O*) ARGS="$ARGS$NL$ARG"; HAD_OFLAG=1 ;;
   -g0) DO_STRIP=0 ;;
   -g*) ARGS="$ARGS$NL$ARG"; DO_STRIP=0 ;;
   -nostdlib | -nodefaultlibs) DO_ADD_LIB= ;;
   -nostdinc) DO_ADD_INCLUDEDIR= ;;
   -c) ARGS="$ARGS$NL$ARG"; DO_ADD_LIB=; DO_LINK= ;;
   -[SE]) ARGS="$ARGS$NL$ARG"; DO_ADD_LIB=; DO_LINK=; DO_COMPILE_OR_LINK= ;;
   -s) SFLAG="$ARG" ;;
   -v) HAD_V=-v; ARGS="$ARGS$NL$ARG" ;;
   -o?*) echo "fatal: unsupported minicc -o flag: $ARG" >&2; exit 1 ;;
   -o) SKIPARG="$ARG" ;;
   -L*) echo "fatal: unsupported minicc library path flag: $ARG" >&2; exit 1 ;;
   -l*) echo "fatal: unsupported minicc library flag: $ARG" >&2; exit 1 ;;
   -*) echo "fatal: unsupported minicc flag: $ARG" >&2; exit 1 ;;
   *.[aocisS])
    if ! test -f "$ARG"; then echo "fatal: missing source file: $ARG" >&2; exit 1; fi
    test "${ARG%.o}" = "$ARG" || HAD_OFILE=1
    ARGS="$ARGS$NL$ARG"
    ;;
   *) echo "fatal: unsupported input file extension: $ARG" >&2; exit 1 ;;
  esac
done
if test "$SKIPARG"; then
  echo "fatal: missing last flag argument: $SKIPARG" >&2
  exit 1
fi


if test "$HAD_TRADITIONAL" && test "$DO_ADD_INCLUDEDIR"; then  # libcs supported by minicc don't support -traditional.
  echo "fatal: $HAD_TRADITIONAL needs -nostdinc in minicc" >&2
fi

GCCBASE="/${GCC##*/}"
IS_WATCOM=
test "$GCC" && test "${GCCBASE#*[-/._]wcc386*}" != "$GCCBASE" && IS_WATCOM=1
if test "$MINICC_LD" = ///gcc; then
  if test "$TCC"; then  # TODO(pts): Allow this.
    echo "fatal: conflicting combination of --tcc=... and --gccld" >&2
    exit 1
  elif test "$IS_WATCOM"; then
    echo "fatal: conflicting combination of --watcom and --gccld" >&2
    exit 1
  elif test -z "$GCC"; then
    echo "fatal: -gcc=... needed by --gccld" >&2
    exit 1
  fi
fi
LDBASE="/${MINICC_LD##*/}"
case "$LDBASE" in *[-/._]tcc*) IS_TCCLD=1 ;; *) IS_TCCLD= ;; esac
if test "$TCC" && test "$IS_TCCLD"; then  # $TCCLD should work with $GCC
  if test "$MINICC_LD" != "$TCC"; then
    echo "fatal: conflicting combination of --tcc=... and --tccld=..." >&2
    exit 1
  fi
  MINICC_LD=  # Don't do $PATH lookup below.
fi
if test "$TCC" && test "$GCC"; then
  echo "fatal: conflicting compilers, both --tcc=... and --gcc=..." >&2
  exit 1
fi
if test -z "$TCC" && test -z "$GCC"; then
  echo "fatal: missing compiler, neither --tcc=... nor --gcc=..." >&2
  exit 1
fi
if test "$USE_UTCC" && test "$DO_ADD_LIB"; then
  if test -z "$IS_TCCLD" && test -z "$MINICC_LD"; then
    MINICC_LD="$TCC"
    IS_TCCLD=1
  fi
  if test "${MINICC_LD%/pts-tcc}" = "$MINICC_LD"; then
    # That's because ///tmp///LIBTCC1.a is embedded in the tools/pts-tcc executable.
    echo "fatal: currently uClibc with --utcc needs --tccld; try --uclibc instead" >&2
    exit 1
  fi
fi
if test "$USE_UTCC" && test "$ARCH" = i386; then
  echo "fatal: the --utcc bundled uClibc doesn't work on i386, it needs -march=i686" >&2
  exit 1
fi

DO_MAIN_AUTO=1
test "$DO_ARGC" && DO_MAIN_AUTO=0
test "$DO_ARGV" && DO_MAIN_AUTO=0
test "$DO_ENVP" && DO_MAIN_AUTO=0
test "$DO_ARGC" = 0 && test -z "$DO_ENVP" && DO_ENVP=0
test "$DO_ARGC" = 0 && test -z "$DO_ARGV" && DO_ARGV=0
test "$DO_ARGV" = 0 && test -z "$DO_ENVP" && DO_ENVP=0
test "$DO_ENVP" || DO_ENVP=1  # Play it safe by default, the program may use it.
test "$DO_ARGV" || DO_ARGV=1  # Play it safe by default, the program may use it.
test "$DO_ARGC" || DO_ARGC=1  # Play it safe by default, the program may use it.
if test "$DO_ENVP" = 1 && test "$DO_ARGV" = 0; then echo "fatal: -menvp needs -margv" >&2; exit 1; fi
if test "$DO_ENVP" = 1 && test "$DO_ARGC" = 0; then echo "fatal: -menvp needs -margc" >&2; exit 1; fi
if test "$DO_ARGV" = 1 && test "$DO_ARGC" = 0; then echo "fatal: -margv needs -margc" >&2; exit 1; fi

case "$GCC" in "") ;; */*) ;; *)  # Resolve $GCC on $OLD_PATH. Useful for --noenv and --boxed.
  LOOKUP="$(PATH="$OLD_PATH"; type "$GCC" 2>/dev/null)"
  case "$LOOKUP" in
   *\ is\ /*)  LOOKUP="/${LOOKUP#*\ is\ /}"  ;;
   *\ for\ /*) LOOKUP="/${LOOKUP#*\ for\ /}" ;;  # ksh(1).
   *) echo "fatal: gcc command not found: $GCC" >&2; exit 6 ;;
  esac
  test "$IS_BOXED" && GCC="$LOOKUP" && GCC_BARG="-B${GCC%/*}"  # Don't mess with $GCC paths unless --noenv or --boxed is specified.
esac
case "$TCC" in "") ;; */*) ;; *)  # Resolve $TCC on $OLD_PATH. Useful for --noenv and --boxed.
  LOOKUP="$(PATH="$OLD_PATH"; type "$TCC" 2>/dev/null)"
  case "$LOOKUP" in
   *\ is\ /*)  LOOKUP="/${LOOKUP#*\ is\ /}"  ;;
   *\ for\ /*) LOOKUP="/${LOOKUP#*\ for\ /}" ;;  # ksh(1).
   *) echo "fatal: tcc command not found: $GCC" >&2; exit 6 ;;
  esac
  TCC="$LOOKUP"
esac
case "$MINICC_LD" in "") ;; */*) ;; *)  # Resolve $MINICC_LD on $OLD_PATH. Useful for --noenv and --boxed.
  LOOKUP="$(PATH="$OLD_PATH"; type "$MINICC_LD" 2>/dev/null)"
  case "$LOOKUP" in
   *\ is\ /*)  LOOKUP="/${LOOKUP#*\ is\ /}"  ;;
   *\ for\ /*) LOOKUP="/${LOOKUP#*\ for\ /}" ;;  # ksh(1).
   *) echo "fatal: --tccld command not found: $GCC" >&2; exit 6 ;;
  esac
  MINICC_LD="$LOOKUP"
esac
unset OLD_PATH

test "$DO_ADD_LIB" || DO_SMART=0

if test -z "$DO_LINK"; then
  MINICC_LD=
  IS_TCCLD=
elif test "$TCC" && test -z "$MINICC_LD"; then  # !! Move earlier.
  MINICC_LD="$TCC"
  IS_TCCLD=1
fi

NEED_LIBC=
test "$DO_ADD_INCLUDEDIR" && NEED_LIBC=1
if test "$USE_UTCC"; then
  if test "$LIBC"; then
    echo "fatal: conflicting combination of --utcc and --libc=$LIBC" >&2
    exit 1
  fi
  LIBC=minilibc  # For -I... ($DO_ADD_INCLUDEDIR).
else
  test "$LIBC" || LIBC=minilibc
  test "$DO_ADD_LIB" && NEED_LIBC=1
fi
if test "$NEED_LIBC"; then
  if test -f "$MYDIR/libc/$LIBC/libc.defs"; then
    :
  elif test -d "$MYDIR/libc/$LIBC"; then
    echo "fatal: missing libc.defs file: $MYDIR/libc/$LIBC/libc.defs" >&2
    exit 4
  else
    for D in "$MYDIR/libc/$LIBC"-*; do
      if test -f "$D/libc.defs"; then
        LIBC="${D##*/}"; break  # Use the first one found. TODO(pts): Does the list get sorted?
      fi
    done
    if ! test -f "$MYDIR/libc/$LIBC/libc.defs"; then
      SFX=
      for D in "$MYDIR/libc/$LIBC"-*.sfx.7z; do
        if test -f "$D"; then
          SFX="$D"; LIBC="${D##*/}"; LIBC="${LIBC%.sfx.7z}"; break  # Use the first one found. TODO(pts): Does the list get sorted?
        fi
      done
      if test "$SFX" && test -f "$SFX"; then
        chmod +x "$SFX" 2>/dev/null
        rm -rf "$MYDIR/libc/$LIBC"
        echo "info: extracting libc sfx: $SFX" >&2
        (cd "${SFX%/*}" && ./"${SFX##*/}" -y >/dev/null)
        if ! test -f "$MYDIR/libc/$LIBC/libc.defs"; then
          echo "fatal: libc sfx extraction failed: $SFX" >&2
          exit 4
        fi
      else
        echo "fatal: libc directory not found: $MYDIR/libc/$LIBC" >&2
        exit 4
      fi
    fi
    if test "$DO_ADD_LIB" && test "$IS_TCCLD" && test -f "$MYDIR/libc/$LIBC/libc.notccld"; then  # Example: EGLIBC.
      echo "fatal: $(cat "$MYDIR/libc/$LIBC/libc.notccld")" >&2
      exit 4
    fi
  fi
fi

if test "$DO_STRIP" = 0 || test -z "$DO_LINK"; then
  DO_STRIP=
else
  DO_STRIP=1
  SFLAG=-s
  test "$GCC" && SFLAG="-s"
fi

#if ! "$GCC" "$GCC_BARG" -print-search-dirs >/dev/null 2>&1; then  # Also works with Clang.
#  echo "fatal: gcc not working: $GCC" >&2; exit 2
#fi
if test "$MINICC_LD" = ///gcc; then
  MINICC_LD="$(exec "$GCC" "$GCC_BARG" -print-prog-name=ld 2>/dev/null)"  # Also works with Clang.
  if test -z "$MINICC_LD"; then
    if ! "$GCC" "$GCC_BARG" -print-search-dirs >/dev/null 2>&1; then
      echo "fatal: gcc not working: $GCC" >&2; exit 2
    fi
    echo "fatal: linker not found by gcc: $GCC" >&2; exit 2
  elif test "${MINICC_LD#*$NL}" != "$MINICC_LD"; then  # Multiline report, e.g. from wcc386.
    echo "fatal: gcc failed to report linker: $GCC" >&2; exit 2
  fi
  # Sometimes it's not found, but still returned nonempty.
elif test "$DO_LINK" && test -z "$MINICC_LD"; then
  MINICC_LD="$MYDIR"/tools/ld  # Used by default (like --minild), unless --gccld, --tccld etc. is specified.
fi
if test "$DO_LINK"; then
  if test -z "$MINICC_LD"; then
    echo "fatal: linker not found" >&2; exit 2
  fi
  if test "${MINICC_LD#*/}" != "$MINICC_LD" && test ! -f "$MINICC_LD"; then
    echo "fatal: linker program file not found: $MINICC_LD" >&2; exit 2
  fi
fi

test "$GCC_BARG" = -pipe && GCC_BARG=
case "$GCCBASE" in
 "") GCC_BARG= ;;
 *[-/._]clang* | *[-/._]wcc386*) GCC_BARG= ;;  # clang(1) and wcc386(1) (unlike gcc) don't need $GCC_BARG to find as(1).
 *) test "$DO_COMPILE_OR_LINK" || GCC_BARG= ;;  # For gcc to find as(1).
esac

OFLAG_ARGS=
if test -z "$HAD_OFLAG"; then  # Add some size-optimizing flags.
  case "$GCCBASE" in
   "") ;;
   *[-/._]clang*) OFLAG_ARGS="-Os$NL-mstack-alignment=2" ;;
   *) OFLAG_ARGS="-Os$NL-falign-functions=1$NL-falign-jumps=1$NL-falign-loops=1$NL-mpreferred-stack-boundary=2" ;;
  esac
  test "$TCC" && OFLAG_ARGS="-Os"
fi
INCLUDEDIR_ARG=
DEF_ARG=
if test "$DO_ADD_INCLUDEDIR"; then
  INCLUDEDIR_ARG="-I$MYDIR/libc/$LIBC/include"
  if test "$USE_UTCC"; then
    DEF_ARG="-D__UCLIBC__"
  else
    # TODO(pts): Ignore comments in lines starting with `#'.
    # This DEF_ARG must be valid for for nasm (for -msmart), do it should be contain only `-D...' and `-U...'.
    for F in $(cat "$MYDIR/libc/$LIBC/libc.defs"); do  # Split on any whitespace, $IFS hasn't been set yet.
      DEF_ARG="$DEF_ARG$NL$F"
    done
  fi
fi
test "$DO_MAIN_AUTO" && DEF_ARG="$DEF_ARG$NL-DCONFIG_MAIN_ARGS_AUTO"
if test "$DO_ARGC" = 0; then DEF_ARG="$DEF_ARG$NL-DCONFIG_MAIN_NO_ARGC_ARGV_ENVP"
elif test "$DO_ARGV" = 0; then DEF_ARG="$DEF_ARG$NL-DCONFIG_MAIN_NO_ARGV_ENVP"
elif test "$DO_ENVP" = 0; then DEF_ARG="$DEF_ARG$NL-DCONFIG_MAIN_NO_ENVP"
fi
OUTFILE_ARG=
test "$OUTFILE" && OUTFILE_ARG="-o$NL$OUTFILE"
if test "$TCC"; then
  # TODO(pts): Does TCC really generate i386-only code?
  # We don't pass $ANSIFLAG, because TCC 0.9.26 would fail for it.
  ARGS="$TCC$NL-m32$NL-march=$ARCH$NL-static$NL-nostdlib$NL-nostdinc$NL$SFLAG$NL$OFLAG_ARGS$NL$WFLAGS$NL$DEF_ARG$NL$ARGS$NL$INCLUDEDIR_ARG$NL$OUTFILE_ARG"
else
  # This also works with TCC, but it's too much cruft.
  # The `-B$MYDIR/gcctooldir' argument makes our gcctooldir/collect2 or gcctooldir/ld run.
  # Add $INCLUDEDIR_ARG last, so that -I... specified by the user takes precedence. !! TODO(pts): Does GCC do this or the opposite?
  # Specifying -fcommon since -fno-common is the default since GCC 10 and Clang 11: https://maskray.me/blog/2022-02-06-all-about-common-symbols
  # DYI dietlibc 0.34 adds: gcc -Os -fomit-frame-pointer -falign-functions=1 -falign-jumps=1 -falign-loops=1 -mpreferred-stack-boundary=4
  # !! TODO(pts): Try -fomit-frame-pointer. Sometimes it makes the code larger.
  # !! TODO(pts): Try -mno-align-stringops. What happens with old GCC not supporting it, or Clang?
  # !! TODO(pts): Try -fno-unroll-loops -fmerge-all-constants -fno-math-errno. What happens with old GCC not supporting it, or Clang?
  # !! TODO(pts): Document -Wl,-N for merging sections .text and .data.
  ARGS="$TCC$NL$GCC$NL$GCC_BARG$NL-m32$NL-march=$ARCH$NL-static$NL-fno-pic$NL-U_FORTIFY_SOURCE$NL-fcommon$NL-fno-stack-protector$NL-fno-unwind-tables$NL-fno-asynchronous-unwind-tables$NL-fno-builtin$NL-fno-ident$NL-fsigned-char$NL-ffreestanding$NL-fno-lto$NL-nostdlib$NL-nostdinc$NL$SFLAG$NL$OFLAG_ARGS$NL$ANSIFLAG$NL$WFLAGS$NL$DEF_ARG$NL$ARGS$NL$INCLUDEDIR_ARG$NL$OUTFILE_ARG"
fi
NEED_LIBMINITCC1=
if test "$DO_ADD_LIB"; then
  LIBWL=
  if test "$USE_UTCC"; then
    LIBFN=///tmp///LIBTCC1.a  # Embedded in tools/pts-tcc.
    if test "$DO_SMART" && test "$DO_SMART" != 0; then
      echo "fatal: --utcc doesn't support -msmart" >&2
      exit 3
    fi
  else
    LIBFN="$MYDIR/libc/$LIBC/libc.$ARCH.a"
    if ! test -f "$LIBFN"; then
      if test "$LIBC" = minilibc; then
        if "$MYDIR/build.sh" && test -f "$LIBFN"; then :; else
          echo "fatal: failed to build libc .a: $LIBFN" >&2
          exit 3
        fi
      else
        if test -f "$MYDIR/libc/$LIBC/libc.i686.a"; then
          echo "fatal: the libc wasn't compiled for -march=$ARCH, use -march=i686" >&2
          exit 3
        else
          echo "fatal: missing libc .a: $LIBFN" >&2
          exit 3
        fi
      fi
    fi
    if test -z "$DO_SMART"; then
      DO_SMART=0
      test -f "$MYDIR/libc/$LIBC/smart.nasm" && DO_SMART=1  # Use smart linking by default if available for libc.
    elif test "$DO_SMART" != 0; then
      if ! test -f "$MYDIR/libc/$LIBC/smart.nasm"; then
        echo "fatal: missing libc smart.nasm for -msmart: $MYDIR/libc/$LIBC/smart.nasm" >&2
        exit 3
      fi
    fi
  fi
  test "$DO_SMART" || DO_SMART=0  # Fallback.
  if test "$TCC" || test "$IS_TCCLD"; then  # TCC needs an explicit start*.o in the command line -- or does it?
    OBJFN="$MYDIR/helper_lib/need_start.o"
    if ! test -f "$OBJFN"; then
      # !! TODO(pts): Let build.sh take care of this.
      test "$HAD_V" && echo "info: compiling: $MYDIR/helper_lib/need_start.nasm" >&2
      if "$MYDIR/tools/nasm-0.98.39" -O0 -w+orphan-labels -f elf -o "$OBJFN" "$MYDIR/helper_lib/need_start.nasm" && test -f "$OBJFN"; then :; else
        echo "fatal: failed to build need-start .o: $OBJFN" >&2
        exit 3
      fi
    fi
    ARGS="$ARGS$NL$OBJFN"
    if test "$USE_UTCC"; then
      OBJFN="$MYDIR/helper_lib/need_uclibc_main.o"
      if ! test -f "$OBJFN"; then
        # !! TODO(pts): Let build.sh take care of this.
        test "$HAD_V" && echo "info: compiling: $MYDIR/helper_lib/need_uclibc_main.nasm" >&2
        if "$MYDIR/tools/nasm-0.98.39" -O0 -w+orphan-labels -f elf -o "$OBJFN" "$MYDIR/helper_lib/need_uclibc_main.nasm" && test -f "$OBJFN"; then :; else
          echo "fatal: failed to build need-uclibc-main .o: $OBJFN" >&2
          exit 3
        fi
      fi
      ARGS="$ARGS$NL$OBJFN"
    fi
  fi
  test "$DO_SMART" = 0 && ARGS="$ARGS$NL$LIBWL$LIBFN"
  if test "$TCC" && test -z "$USE_UTCC"; then NEED_LIBMINITCC1=1
  elif test "$IS_TCCLD" && test "$IS_WATCOM"; then NEED_LIBMINITCC1=1  # We need it for dummy symbols cstart_ and _argc.
  elif test "$IS_TCCLD" && test "$HAD_OFILE"; then NEED_LIBMINITCC1=1  # We need it for dummy symbols cstart_ and _argc.
  else NEED_LIBMINITCC1=
  fi
  if test "$NEED_LIBMINITCC1"; then
    LIBFN="$MYDIR/helper_lib/libminitcc1.a"
    if ! test -f "$LIBFN"; then
      if "$MYDIR/build.sh" && test -f "$LIBFN"; then :; else
       echo "fatal: failed to build libtcc1 .a: $LIBFN" >&2
        exit 3
      fi
    fi
    test "$DO_SMART" = 0 && ARGS="$ARGS$NL$LIBFN"
  fi
  if test "$USE_UTCC"; then
    # OBJFN="$MYDIR/helper_lib/start_uclibc_linux.o"  # Not needed.
    OBJFN="///tmp///crt1.o"  # Embedded in the tools/pts-tcc executable, same functionality as start_uclibc_linux.o.
    ARGS="$ARGS$NL$LIBWL$OBJFN"
  fi
fi
test "$DO_SMART" || DO_SMART=0  # Fallback.

test "$TMPDIR" || TMPDIR=/tmp
test "${TMPDIR#/}" = "$TMPDIR" && TMPDIR="./$TMPDIR"  # Make it not a command-line flag (-...).
export TMPDIR

IFS="$NL"  # Argument splitting will happen over newlines only.
if test "$DO_LINK"; then
  test "$OUTFILE" || OUTFILE=a.out
  test "${OUTFILE#-?}" = "$OUTFILE" || OUTFILE="./$OUTFILE"  # Make it not a command-line flag (-...).
fi

TMPOFILES=
if test "$GCC" || test -z "$IS_TCCLD"; then
  # TCC accepts all these flags (and ignores `-m elf_i386' if passed).
  LDARGS="$MINICC_LD$NL-nostdlib$NL-static"
  if test -z "$IS_TCCLD"; then
    # `-e _start' is needed, because without it GNU gold(1) wouldn't fail to link if _start is not defined.
    # `--fatal-warnings' is needed, because without it GNU ld(1) would happily create an executable without _start.
    LDARGS="$LDARGS$NL-m${NL}elf_i386$NL-z${NL}norelro$NL-e${NL}_start$NL--fatal-warnings"
  fi
  CCARGS="$GCC"
  test "$TCC" && CCARGS="$TCC"
  test "$DO_LINK" && CCARGS="$CCARGS$NL-c"
  FILEARGS=
  SKIPARG=
  CCMODE=
  for ARG in --skiparg $ARGS; do
    if test "$SKIPARG"; then SKIPARG=; continue; fi
    case "$ARG" in
     *"$NL"*) echo "fatal: unexpected newline in minicc generated argument" >&2; exit 7 ;;
     "") echo "fatal: empty minicc generated argument" >&2; exit 7 ;;
     --skiparg) SKIPARG=1 ;;
     -o) SKIPARG="$ARG" ;;
     -Wl,) ;;
     -Wl,-*)
       ARG="${ARG#-Wl,}"
       IFS=,  # Split on comma.
       for ARG in $ARG; do
         LDARGS="$LDARGS$NL$ARG"
       done
       IFS="$NL"
       ;;
     -Wl,?*) FILEARGS="$FILEARGS$NL--ldfile=$ARG" ;;  # This shouldn't happen.
     -s) LDARGS="$LDARGS$NL$ARG" ;;
     -[cSE])
       if test "$DO_LINK"; then echo "fatal: output mode not supported when linking: $ARG" >&2; exit 7; fi
       CCMODE="$ARG"
       CCARGS="$CCARGS$NL$ARG"
       ;;
     -*) CCARGS="$CCARGS$NL$ARG" ;;
     *.[ao]) FILEARGS="$FILEARGS$NL--ldfile=$ARG" ;;
     *.[ci]) FILEARGS="$FILEARGS$NL--srcfile=$ARG" ;;  # owcc386 treats .i files just like .c, but gcc doesn't allow `#' in .i files, because they are apready preprocesed.
     *.[sS])
       if test "$IS_WATCOM"; then
         echo "fatal: unsupported minicc wcc386 assembly source file type: $ARG" >&2; exit 5;
       fi
       FILEARGS="$FILEARGS$NL--srcfile=$ARG"
       ;;
     *) echo "fatal: unsupported input file extension: $ARG" >&2; exit 7 ;;
    esac
  done
  if test "$SKIPARG"; then
    echo "fatal: missing last flag argument for minicc wcc386: $SKIPARG" >&2
    exit 7
  fi
  if test -z "$FILEARGS"; then
    echo "fatal: no source files specified" >&2
    exit 7
  fi
  LDARGS="$LDARGS$NL$OUTFILE_ARG"
  # echo "CCARGS: $CCARGS" >&2; echo "LDARGS: $LDARGS" >&2; echo "FILEARGS: $FILEARGS" >&2

  # If $IS_WATCOM, convert $CCARGS for wcc386.
  if test "$IS_WATCOM"; then
    if test "$DO_ADD_INCLUDEDIR"; then
      if ! test -f "$MYDIR/libc/$LIBC/include/_preincl.h"; then
        echo "fatal: libc not prepared for wcc386, file missing: $MYDIR/libc/$LIBC/include/_preincl.h" >&2
        exit 5
      fi
    fi
    WFFLAG=-of+  # GCC -fno-omit-frame-pointer default.
    WSFLAG=
    WJFLAG=-j  # `signed char' is GCC default.
    # Not specifying -zls makes wcc386 insert these extern symbols:
    # * _cstart_: if main is defined.
    # * __argc: if main has at least 1 argument. There is no distinction between argc, argc+argv and argc+argv+envp.
    WAUTOSYMFLAG=
    WARGS=
    WISOMF=
    WISOBJ=1
    WHADWEXTRA=
    test "$HAD_V" || WARGS="$WARGS$NL-q"
    WARGS="$WARGS$NL-bt=linux$NL-fr$NL-zl$NL-zld"
    unset INCLUDE  # Don't let wcc386 find any system #include etc. file.
    unset WATCOM  # Don't let wcc386 find any system #include etc. file.
    SKIPARG=
    for ARG in --skiparg $CCARGS; do
      if test "$SKIPARG"; then SKIPARG=; continue; fi
      case "$ARG" in
       *"$NL"*) echo "fatal: unexpected newline in minicc wcc386 argument" >&2; exit 5 ;;
       "") echo "fatal: empty minicc wcc386 argument" >&2; exit 5 ;;
       --skiparg) SKIPARG=1 ;;
       -B?*) ;;  # Just to be sure. minicc doesn't add it for wcc386.
       -v) ;;  # Already processed as $HAD_V.
       -ansi | -std=c89) WARGS="$WARGS$NL-za" ;;
       -std=c99) WARGS="$WARGS$NL-za99" ;;
       -std=ow) WARGS="$WARGS$NL-ze" ;;
       -pedantic) ;;
       -m32 | -static | -fno-pic | -fcommon | -fno-unwind-tables | -fno-asynchronous-unwind-tables | -fno-builtin | -fno-ident | -ffreestanding | -fno-lto | -nostdinc | -falign-functions=* | -falign-jumps=* | -falign-loops=* | -mpreferred-stack-boundary=*) ;;
       -fno-unroll-loops | -fmerge-all-constants | -fno-math-errno | -g0 | -Wno-no) ;;
       -fomit-frame-pointer) WFFLAG= ;;
       -fomit-leaf-frame-pointer) WFFLAG=-of ;;
       -fno-omit-frame-pointer) WFFLAG=-of ;;
       -fno-omit-leaf-frame-pointer) WFFLAG=-of+ ;;
       -U_FORTIFY_SOURCE) ;;
       -fno-stack-protector) WSFLAG=-s ;;
       -fstack-protector) WSFLAG= ;;
       -mno-autosym) WAUTOSYMFLAG=-zls ;;  # minicc-specific.
       -mautosym) WAUTOSYMFLAG= ;;  # minicc-specific.
       -fsigned-char | -fno-unsigned-char) WJFLAG=-j ;;
       -fno-signed-char | -funsigned-char) WJFLAG= ;;
       -finline-fp-rounding) WARGS="$WARGS$NL-zri" ;;  # To prevent the call to __CHP.
       -march=i386) WARGS="$WARGS$NL-3r" ;;
       -march=i686) WARGS="$WARGS$NL-6r" ;;  # !! TODO(pts): Does it generate larger code? Then change the default with -Os.
       -mno-80387 | -msoft-float) WARGS="$WARGS$NL-fpc" ;;  # Useful for string merging in .rodata.str1.1.
       -m80387 | -mhard-float | -mhard-emu-float) WARGS="$WARGS$NL-fpi" ;;  # Default.  # -mhard-float would be `-fpi87'.
       -nostdlib) ;;  # minicc $CCARGS always contains -nostdlib.
       -W | -Wextra) WARGS="$WARGS$NL-wx"; WHADWEXTRA=1 ;;
       -Wimplicit-function-declaration) WARGS="$WARGS$NL-wce=308" ;;
       -Werror[-=]implicit-function-declaration) WARGS="$WARGS$NL-wce=308" ;;  # Unfortunately it still remains a warning, there is no per-warning control of errors.
       -Wall) test "$WHADWEXTRA" || WARGS="$WARGS$NL-w4" ;;
       -Werror) WARGS="$WARGS$NL-we" ;;
       -Werror=*) ;;  # No per-warning control, just ignore for simplicity.
       -w) WARGS="$WARGS$NL-w0" ;;
       -Wlevel[0-9]*) WARGS="$WARGS$NL-w${ARG#-Wlevel}" ;;
       -Wno-n[0-9]*) WARGS="$WARGS$NL-wcd=${ARG#-Wno-n}" ;;
       -Wn[0-9]*) WARGS="$WARGS$NL-wce=${ARG#-Wn}" ;;
       -Wstop-after-errors=[0-9]*) WARGS="$WARGS$NL-e${ARG#*=}" ;;  # owcc(1)-specific.
       -H) WARGS="$WARGS$NL-fti" ;;
       -O0) WARGS="$WARGS$NL-od" ;;  # TODO(pts): Try -oh (expensive optimizations). Does it reduce size?
       -O1) WARGS="$WARGS$NL-oil" ;;
       -O2) WARGS="$WARGS$NL-onatx" ;;
       -O3) WARGS="$WARGS$NL-onatxl+" ;;
       -Os) WARGS="$WARGS$NL-os" ;;
       -Ot) WARGS="$WARGS$NL-ot" ;;
       -O)  WARGS="$WARGS$NL-oil" ;;
       # !! TODO(pts): Copy more flag translations from owcc.c.
       -c) ;;
       -S) echo "fatal: assembly generation not supported by minicc wcc386" >&2; exit 5 ;;
       -E) WARGS="$WARGS$NL-pl"; WISOBJ= ;;
       -momf) WISOMF=1 ;;  # minicc-specific. Generate the object file in OMF format (OpenWatcom native) rather than ELF-32.
       -[DUI]?*) WARGS="$WARGS$NL$ARG" ;;
       -g*) echo "fatal: debug generation not supported by minicc wcc386" >&2; exit 5 ;;
       -*) echo "fatal: unsupported minicc wcc386 flag (try it with --gcc?): $ARG" >&2; exit 5 ;;
       *) echo "fatal: assert: input file not allowed: $ARG" >&2; exit 5 ;;
      esac
    done
    CCARGS="$GCC$NL$WSFLAG$NL$WJFLAG$NL$WFFLAG$NL$WAUTOSYMFLAG$NL$WARGS"
    # TODO(pts): Add -m... flag for string optimizations (like in minilibc32).
  fi

  if test "$IS_WATCOM" && test "$WISOMF"; then
    if test -z "$WISOBJ" || test "$DO_LINK" || test "$CCMODE" != -c; then  # Checking $CCMODE should be enough.
      echo "fatal: -momf needs -c" >&2; exit 5
    fi
  fi

  # Now create all the temporary .o files which will be written to $GCC or $TCC.
  TMPOFILES=
  CCFILEARGS=
  OEXT=o
  test "$IS_WATCOM" && OEXT=obj
  for ARG in $FILEARGS; do
    case "$ARG" in
     --srcfile=?*)
      if test "$DO_LINK"; then
        TMPOFILE="$("$MYDIR"/tools/mktmpf "$TMPDIR"/minicc.@@@@@@."$OEXT")"  # Already creates the file.
        if test -z "$TMPOFILE"; then
          echo "fatal: error creating temporary .o file" >&2; rm -f $TMPOFILES; exit 7
        fi
        TMPOFILES="$TMPOFILES$NL$TMPOFILE"
        test "$IS_WATCOM" && TMPOFILES="$TMPOFILES$NL${TMPOFILE%.*}.o"
        LDARGS="$LDARGS$NL${TMPOFILE%.*}.o"
      else
        TMPOFILE="${ARG#--*=}"
        if test "$CCMODE" = -c; then
          if test "$IS_WATCOM" && test -z "$WISOMF"; then
            TMPOFILE="$("$MYDIR"/tools/mktmpf "$TMPDIR"/minicc.@@@@@@."$OEXT")"  # Already creates the file.
            if test -z "$TMPOFILE"; then
              echo "fatal: error creating temporary .o file" >&2; rm -f $TMPOFILES; exit 7
            fi
            TMPOFILES="$TMPOFILES$NL$TMPOFILE"
          elif test "$OUTFILE"; then
            TMPOFILE="$OUTFILE"
          else
            TMPOFILE="${TMPOFILE%.*}"."$OEXT"; TMPOFILE="${TMPOFILE##*/}"  # GCC also strips the dirname.
          fi
        elif test "$CCMODE" = -S; then
          if test "$OUTFILE"; then TMPOFILE="$OUTFILE"
          else TMPOFILE="${TMPOFILE%.*}".s; TMPOFILE="${TMPOFILE##*/}"  # GCC also strips the dirname.
          fi
        else
          TMPOFILE=-  # For -E.
        fi
      fi
      CCFILEARGS="$CCFILEARGS$NL--tmpofile=$TMPOFILE$NL--srcfile=${ARG#--*=}"
      ;;
     --ldfile=?*) LDARGS="$LDARGS$NL${ARG#--*=}" ;;
     *) echo "fatal: assert: bad filearg: $ARG" >&2; exit 7 ;;
    esac
  done
  # echo "CCARGS: $CCARGS" >&2; echo "LDARGS: $LDARGS" >&2; echo "FILEARGS: $FILEARGS" >&2; echo "CCFILEARGS:$CCFILEARGS" >&2; rm -f $TMPOFILES; exit 7

  # Now run `CC -c -o ... ...' for each file in $CCFILEARGS.
  TMPOFILE=
  FOFLAG="-o$NL"
  test "$IS_WATCOM" && FOFLAG=-fo=
  for ARG in $CCFILEARGS; do
    case "$ARG" in
     --tmpofile=?*)
      if test "$TMPOFILE"; then
        echo "fatal: assert: duplicate --tmpofile=..." >&2; rm -f $TMPOFILES; exit 7;
      fi
      TMPOFILE="${ARG#--*=}"
      ;;
     --srcfile=?*)
      if test -z "$TMPOFILE"; then
        echo "fatal: assert: missing --tmpofile=..." >&2; rm -f $TMPOFILES; exit 7;
      fi
      OFLAG=
      if test "$TMPOFILE" = -; then
        test "$HAD_V" && echo "info: running compiler:" $CCARGS "${ARG#--*=}" >&2  # GCC also writes to stderr.
        $CCARGS "${ARG#--*=}"; EC="$?"
      else
        if test "$IS_WATCOM" && test "${TMPOFILE#.}" != "$TMPOFILE"; then
          # Otherwise wcc386 would prepend a basename of the source file.
          echo "fatal: object filename for minicc wcc386 must not start with a dot: $TMPOFILE" >&2; rm -f $TMPOFILES; exit 7;
        fi
        test "$HAD_V" && echo "info: running compiler:" $CCARGS $FOFLAG"$TMPOFILE" "${ARG#--*=}" >&2  # GCC also writes to stderr.
        $CCARGS $FOFLAG"$TMPOFILE" "${ARG#--*=}"; EC="$?"
      fi
      if test "$EC" != 0; then
        if test "$IS_WATCOM" && test "$WISOBJ" && test -z "$WISOMF"; then
          TMPOFILE2="${ARG#--*=}"; TMPOFILE2="${TMPOFILE2%.*}.o"; rm -f "$TMPOFILE2"
        fi
        rm -f $TMPOFILES "$TMPOFILE"; exit "$EC"
      fi
      if test "$IS_WATCOM"; then
        if test "$WISOBJ" && test -z "$WISOMF"; then
          if test "$CCMODE" = -c; then
            if test "$OUTFILE"; then TMPOFILE2="$OUTFILE" 
            else TMPOFILE2="${ARG#--*=}"; TMPOFILE2="${TMPOFILE2%.*}.o"; TMPOFILE2="${TMPOFILE2##*/}"
            fi
          else TMPOFILE2="${TMPOFILE%.*}.o"
          fi
          EFARGS="$MYDIR/tools/omf2elf$NL-h$NL$HAD_$V$NL-o$NL$TMPOFILE2$NL$TMPOFILE"
          test "$HAD_V" && echo "info: running OMF converter:" $EFARGS >&2
          $EFARGS; EC="$?"
          if test "$EC" != 0; then rm -f $TMPOFILES $TMPOFILE2; exit "$EC"; fi
        fi
      elif test "$DO_LINK" && test -z "$TCC"; then
        # GCC adds the .note.GNU-stack ELF section header to the .o file, adding
        # 0x20 bytes unnecessary. We remove it, so ld(1) won't generate the
        # PT_GNU_STACK program header in the executable. To get it, specify
        # -Wl,-z,execstack or -Wl,-z,noexecstack.
        #
        # !! TODO(pts): Also remove from .o files explicitly specified, they
        #    may have been created by a previous `minicc -c'.
        test "$HAD_V" && echo "info: removing .note.GNU-stack from: $TMPOFILE" >&2
        "$MYDIR/tools/elfnostack" "$TMPOFILE"; EC="$?"
        if test "$EC" != 0; then rm -f $TMPOFILES; exit "$EC"; fi
      fi
      TMPOFILE=
      ;;
     *) echo "fatal: assert: bad ccfilearg: $ARG" >&2; rm -f $TMPOFILES; exit 7 ;;
    esac
  done
  if test "$TMPOFILE"; then
    echo "fatal: assert: unused --tmpofile=..." >&2; rm -f $TMPOFILES; exit 7;
  fi
  if test -z "$DO_LINK"; then
    rm -f $TMPOFILES; exit
  fi
  ARGS="$LDARGS"
  WHAT=linker
  unset LDARGS CCARGS CCFILEARGS FILEARGS TMPOFILE TMPOFILE2 FOFLAG CCMODE OEXT
  # Don't forget: rm -f $TMPOFILES
else
  TMPOFILES=
  WHAT=compiler
fi

if test "$DO_SMART" != 0; then  # Smart linking.
  LIBMINITCC1=
  test "$NEED_LIBMINITCC1" && LIBMINITCC1="$MYDIR/helper_lib/libminitcc1.a"
  test "$HAD_V" && echo "info: running $WHAT:" $ARGS >&2  # GCC also writes to stderr.
  $ARGS $LIBMINITCC1 2>"$OUTFILE.err"; EC="$?"  # TODO(pts): Write a C program to extract undefined references and display errors in a streaming way. (Some errors like `In ...' need to be buffered.)
  if test "$EC" = 0 && test "$DO_SMART" != 2; then
    cat "$OUTFILE.err" >&2
    if test "$DO_STRIP"; then rm -f "$OUTFILE.err"
    else rm -f "$OUTFILE.err" $TMPOFILES
    fi
  else
    # The regexps below work for built-in ld of $TCC, ld of $GCC, ld of $GCC (Binutils), gold of $GCC (Binutils). TODO(pts): Make it work with lld (Clang).
    # Examples for GNU ld(1) and GNU gold(1):
    # : warning: cannot find entry symbol '_start'
    # : warning: cannot find entry symbol _start; defaulting to 0000000008048074
    # : warning: entry symbol '_start' exists but is not defined
    UNDEFSYMS="$(awk '{if((((/: undefined reference to [`'\''].+'\''$/&&sub(/^.*?: undefined reference to [`'\'']/, "")||sub(/^tcc: error: undefined symbol '\''/,""))&&sub(/'\''$/,""))||(/: warning: /&&sub(/^.*: warning: (cannot find )?entry symbol '\''?/,"")&&sub(/['\'';].*/,"")&&!/ /))&&!h[$0]){h[$0]=1;printf"%s%s",c,$0;c=","}}' <"$OUTFILE.err")"
    if test -z "$UNDEFSYMS" && test "$EC" != 0; then  # We can read this only if $EC != 0 (i.e. linker failure).
      cat "$OUTFILE.err" >&2
      rm -f "$OUTFILE.err" $TMPOFILES
      exit "$EC"  # No undefined symbols found, this means there is another reason for the $TCC failure.
    fi
    rm -f "$OUTFILE.err" "$OUTFILE.smart.o"  # !! Generate temporary filename.
    NASMARCHARG=
    test "$ARCH" = i686 || NASMARCHARG=-DCONFIG_I386
    DEF_ARG=
    for F in $(cat "$MYDIR/libc/$LIBC/libc.defs"); do  # Split on any whitespace, $IFS hasn't been set yet.
      DEF_ARG="$DEF_ARG$NL$F"
    done
    if test "$DO_MAIN_AUTO" = 1; then
      case ",$UNDEFSYMS," in ,_start*,)  # Search for cstart_ and _argc manually in the specified .o files.
        SKIPARG=
        for ARG in --skiparg $ARGS; do
          if test "$SKIPARG"; then SKIPARG=; continue; fi
          case "$ARG" in
           --skiparg | -[zmeo]) SKIPARG=1 ;;
           -*) ;;
           *.o)
            if grep -q main 2>/dev/null <"$ARG" && grep -q cstart_ 2>/dev/null <"$ARG" && ! grep -q _argc 2>/dev/null <"$ARG"; then  # !! Write a tool to properly check for undefined symbols.
              DEF_ARG="$DEF_ARG$NL-DCONFIG_MAIN_NO_ARGC_ARGV_ENVP"; break  # smart.nasm recognizes it.
            fi
            ;;
          esac
        done
      esac
    else
      if test "$DO_ARGC" = 0; then DEF_ARG="$DEF_ARG$NL-DCONFIG_MAIN_NO_ARGC_ARGV_ENVP"
      elif test "$DO_ARGV" = 0; then DEF_ARG="$DEF_ARG$NL-DCONFIG_MAIN_NO_ARGV_ENVP"
      elif test "$DO_ENVP" = 0; then DEF_ARG="$DEF_ARG$NL-DCONFIG_MAIN_NO_ENVP"
      fi
    fi
    NASMCMD="$MYDIR/tools/nasm-0.98.39$NL-O0$NL-w+orphan-labels$NL-f${NL}elf$NL$NASMARCHARG$NL-DUNDEFSYMS=$UNDEFSYMS$NL$DEF_ARG$NL-o$NL$OUTFILE.smart.o$NL$MYDIR/libc/$LIBC/smart.nasm"; EC="$?"
    test "$HAD_V" && echo "info: running smart nasm:" $NASMCMD >&2
    $NASMCMD; EC="$?"
    if test "$EC" = 0 && test -f "$OUTFILE.smart.o"; then :; else
      rm -f "$OUTFILE.smart.o" $TMPOFILES
      test "$EC" = 0 && EC=1
      exit "$EC"
    fi
    # /usr/bin/objdump -d "$OUTFILE.smart.o"
    # /usr/bin/nm "$OUTFILE.smart.o"
    ARGS="$ARGS$NL$OUTFILE.smart.o$NL$MYDIR/libc/$LIBC/libc.$ARCH.a$NL$LIBMINITCC1"
    test "$HAD_V" && echo "info: running $WHAT again:" $ARGS >&2  # GCC also writes to stderr.
    $ARGS >&2; EC="$?"  # Redirect linker stdout to stderr.
    if test "$DO_STRIP" && test "$EC" = 0; then :
    else rm -f "$OUTFILE.smart.o" $TMPOFILES
    fi
    test "$EC" = 0 || exit "$EC"
  fi
else
  test "$HAD_V" && echo "info: running $WHAT:" $ARGS >&2  # GCC also writes to stderr.
  $ARGS >&2; EC="$?"  # Redirect linker stdout to stderr.
  if test -z "$DO_STRIP" || test "$EC" != 0; then
    rm -f $TMPOFILES
  fi
  test "$EC" = 0 || exit "$EC"
fi

if test "$DO_STRIP"; then
  FIX_O_FN=
  if ! test "$IS_TCCLD"; then
    FIX_O_FN="$("$MYDIR"/tools/mktmpf "$TMPDIR"/elfxfix.@@@@@@.o)"  # Already creates the file.
    if test -z "$FIX_O_FN"; then
      echo "fatal: error creating temporary .o file" >&2; exit 7
    fi
  fi
  PARGS=
  test "$FIX_O_FN" && PARGS="-p$NL$FIX_O_FN"
  EFARGS="$MYDIR/tools/elfxfix$NL-l$NL-a$NL-s$NL$PARGS$NL$HAD_V$NL--$NL$OUTFILE"
  test "$HAD_V" && echo "info: running extra strip:" $EFARGS >&2
  if test "$FIX_O_FN"; then
    $EFARGS >&2; EC="$?"
    if test "$EC" != 0; then
      rm -f -- "$FIX_O_FN"
      test "$DO_SMART" != 0 && rm -f "$OUTFILE.smart.o"
      exit "$EC"
    fi
    if test -s "$FIX_O_FN"; then  # elfxfix has written to it.
      ARGS="$ARGS$NL$FIX_O_FN"  # Make .bss larger by the size recommended by tools/elfxfix.
      test "$HAD_V" && echo "info: running linker after elfxfix:" $ARGS >&2
      $ARGS >&2; EC="$?"
      if test "$EC" = 0; then
        PARGS="-r$NL$FIX_O_FN"
        EFARGS="$MYDIR/tools/elfxfix$NL-l$NL-a$NL-s$NL$PARGS$NL$HAD_V$NL--$NL$OUTFILE"
        test "$HAD_V" && echo "info: running extra strip again:" $EFARGS >&2
        $EFARGS >&2; EC="$?"
      fi
    fi
    rm -f -- "$FIX_O_FN" $TMPOFILES
  else
    $EFARGS >&2; EC="$?"
    rm -f -- $TMPOFILES
  fi
  test "$DO_SMART" != 0 && rm -f "$OUTFILE.smart.o"
  test "$EC" = 0 || exit "$EC"
fi
