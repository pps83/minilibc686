#! /bin/sh --
#
# minicc: compiler frontend for building with minilib686
# by pts@fazekas.hu at Sun May 21 02:21:27 CEST 2023
#

export LC_ALL=C  # To avoid surprises with localized error messages etc.

unset MYDIR
MYDIR="$(readlink "$0" 2>/dev/null)"
if test "$MYDIR"; then test "${MYDIR#/}" = "$MYDIR" && MYDIR="${0%/*}/$MYDIR"
else MYDIR="$0"
fi
MYDIR="${MYDIR%/*}"
# Use BusyBox (if available) for consistent shell and coreutils.
test -z "$BUSYBOX_SH_SCRIPT" && test -f "$MYDIR/shbin/sh" &&
    export BUSYBOX_SH_SCRIPT=1 PATH="$MYDIR/shbin:$PATH" &&
    exec sh -- "$0" "$@"

# For very hardcore users and reproducible builds: unset all environment
# variables, and use a hardcoded --boxed $PATH.
test "$1" = --noenv && shift && exec env -i PATH="$MYDIR/shbin" BUSYBOX_SH_SCRIPT=1 sh -- "$0" --boxed "$@"

# For hardcore users and testing: --boxed will use only the included shell
# and coreutils programs. Toolchain tools (e.g. pts-tcc and ld) are not
# affected by $PATH, they will be run explictly from "$MYDIR/tools". --gcc
# is affected, --boxed effectively breaks --gcc, so the user has to specify
# --gcc=/usr/bin/gcc instead.
IS_BOXED=
while test "$1" = --boxed; do export PATH="$MYDIR/shbin"; IS_BOXED=1; shift; done

NL="
"

if test $# = 0 || test "$1" == --help; then
  test $# = 0 && exec >&2
  echo "minicc: C compiler fronted for building small Linux i386 executables$NL""Usage: $0 [<gcc-flag>...] <file.c>$NL""There are minicc flags, e.g. --gcc, --tcc, --utcc"
  test $# = 0 && exit 1
  exit 0
fi 

if ! test -f "$MYDIR/gcctooldir/collect2"; then
  echo "fatal: missing tool: $MYDIR/gcctooldir/collect2" >&2
  exit 1
fi
if ! test -x "$MYDIR/gcctooldir/collect2"; then
  echo "fatal: tool not executable: $MYDIR/gcctooldir/collect2" >&2
  exit 1
fi

ARCH=i686
GCC=gcc
TCC=
TCCLD=
DO_ADD_LIB=1
DO_ADD_INCLUDEDIR=1
DO_LINK=1
SFLAG=
DO_STRIP=1
WFLAGS="-W$NL-Wall$NL-Werror=implicit-function-declaration"
HAD_OFLAG=
HAD_V=
ARCH=i686
USE_UCLIBC=
GCC_BARG=-pipe  # Harmless default.

case "$1" in
 "" | -* | *.[aocisS]) ;;  # A flag or a source file name is not a program name.
 *)
  BASENAME="${1##*/}"
  case "$BASENAME" in
   utcc) GCC=; TCC="$MYDIR"/tools/pts-tcc; USE_UCLIBC=1 ;;  # Same as: --utcc
   *tcc*) TCC="$1"; GCC= ;;
   *) GCC="$1"; TCC= ;;
  esac
  shift
  ;;
esac

SKIPARG=
APPENDARG=
ARGS=""
OUTFILE=a.out
for ARG in "$@"; do
  if test "$SKIPARG"; then
    SKIPARG=
    continue
  elif test "$APPENDARG"; then
    test "$APPENDARG" = -o && OUTFILE="$ARG"
    ARGS="$ARGS$NL$APPENDARG$NL$ARG"
    APPENDARG=
    continue
  fi
  case "$ARG" in
   *"$NL"*) echo "fatal: unexpected newline in arg" >&2; exit 1 ;;
   --gcc) TCC=; GCC=gcc ;;  # Doesn't work with --boxed. TODO(pts): Look it up on old $PATH.
   --gcc=*/*) TCC=; GCC="${ARG#*=}"; test "$IS_BOXED" && GCC_BARG="-B${GCC%/*}" ;;
   --gcc=*) TCC=; GCC="${ARG#*=}" ;;
   --tcc) GCC=; TCC="$MYDIR"/tools/pts-tcc ;;
   --tcc=*) GCC=; TCC="${ARG#*=}" ;;
   --utcc) GCC=; TCC="$MYDIR"/tools/pts-tcc; USE_UCLIBC=1 ;;
   --utcc=*) GCC=; TCC="${ARG#*=}"; USE_UCLIBC=1 ;;
   --tccld) TCCLD="$MYDIR"/tools/pts-tcc ;;
   --tccld=*) TCCLD="${ARG#*=}" ;;
   -static | -m32 | -fno-pic | -fpic | -fno-pie | -pie | -no-pie | -flto | -fno-lto | -nostartfiles) ;;
   -march=i[36]86) ARCH="${ARG#*=}" ;;
   -march=*) echo "fatal: unsupported minicc arch flag: $ARG" >&2; exit 1 ;;
   -Wno-no) WFLAGS= ;;  # Disable warnings. GCC and Clang accept and ignore it.
   -W*) ARGS="$ARGS$NL$ARG"; WFLAGS= ;;
   -[fm]*) ARGS="$ARGS$NL$ARG" ;;
   -[DUI]*?) ARGS="$ARGS$NL$ARG" ;;
   -O*) ARGS="$ARGS$NL$ARG"; HAD_OFLAG=1 ;;
   -g*) ARGS="$ARGS$NL$ARG"; DO_STRIP=0 ;;
   -nostdlib | -nodefaultlibs) DO_ADD_LIB= ;;
   -nostdinc) DO_ADD_INCLUDEDIR= ;;
   -[cSE]) ARGS="$ARGS$NL$ARG"; DO_ADD_LIB=; DO_LINK= ;;
   -s) SFLAG="$ARG" ;;
   -v) HAD_V=1; ARGS="$ARGS$NL$ARG" ;;
   -o) APPENDARG="$ARG" ;;
   -L*) echo "fatal: unsupported minicc library path flag: $ARG" >&2; exit 1 ;;
   -l*) echo "fatal: unsupported minicc library flag: $ARG" >&2; exit 1 ;;
   -*) echo "fatal: unsupported minicc flag: $ARG" >&2; exit 1 ;;
   *//////*)
    echo "fatal: too many slashes in input file name: $ARG" >&2; exit 1 ;;  # We use this to detect TMPDIR.
   *.[aocisS])
    if ! test -f "$ARG"; then echo "fatal: missing source file: $ARG" >&2; exit 1; fi
    ARGS="$ARGS$NL$ARG"
    ;;
   *) echo "fatal: unsupported input file extension: $ARG" >&2; exit 1 ;;
  esac
done

if test "$DO_STRIP" = 0; then
  DO_STRIP=
else
  DO_STRIP=1
  SFLAG=-s
  test "$GCC" && SFLAG="-s$NL-Wl,-sss"
fi

if test "$TCC" && test "$TCCLD"; then  # $TCCLD should work with $GCC
  if test "$TCCLD" != "$TCC"; then
    echo "fatal: conflicting combination of --tcc=... and --tccld=..." >&2
    exit 1
  fi
  TCCLD=
fi
if test "$TCC" && test "$GCC"; then
  echo "fatal: conflicting compilers, both --tcc=... and --gcc=..." >&2
  exit 1
fi
if test -z "$TCC" && test -z "$GCC"; then
  echo "fatal: missing compiler, neither --tcc=... nor --gcc=..." >&2
  exit 1
fi
if test "$USE_UCLIBC" && test "$DO_ADD_LIB" && test -z "$TCCLD" && test "${TCC%/pts-tcc}" = "$TCC"; then
  # That's because ///tmp///LIBTCC1.a is embedded in the tools/pts-tcc executable.
  # TODO(pts): Extract it.
  echo "fatal: currently uClibc needs pts-tcc" >&2
  exit 1
fi
if test "$USE_UBLIBC" && test "$ARCH" = i386; then
  # In fact, it was compiled for -march=pentium3, which is newer than
  # -march=i686.
  # TODO(pts): Recompile at least parts of it for -march=i686.
  echo "fatal: the bundled uClibc doesn't work on i386" >&2
  exit 1
fi

if test "$GCC"; then
  if test "$TCCLD"; then
    export MINICC_LD=
    export MINICC_TCCLD="$TCCLD"
    export MINICC_LDV="$HAD_V"
    if ! "$GCC" "$GCC_BARG" -print-search-dirs >/dev/null 2>&1; then  # Also works with Clang.
      echo "fatal: gcc not working: $GCC" >&2
      exit 2
    fi
  else
    export MINICC_TCCLD=
    # gcctooldir/collect2 (== gcctooldir/ld) uses it.
    export MINICC_LD="$("$GCC" "$GCC_BARG" -print-prog-name=ld 2>/dev/null)"  # Also works with Clang.
    if test -z "$MINICC_LD"; then
      if ! "$GCC" "$GCC_BARG" -print-search-dirs >/dev/null 2>&1; then
        echo "fatal: gcc not working: $GCC" >&2
        exit 2
      fi
      echo "fatal: linker not found by gcc: $GCC" >&2
      exit 2
    fi
    # Sometimes it's not found, but still returned nonempty.
    export MINICC_LDV="$HAD_V"
  fi
fi
test "$GCC_BARG" = -pipe && GCC_BARG=

OFLAG_ARGS=
if test -z "$HAD_OFLAG"; then  # Add some size-optimizing flags.
  case "$GCC" in
   "") ;;
   *clang*)
    OFLAG_ARGS="-Os$NL-mstack-alignment=2";
    # If we have multiple -B... flags, clang(1) will fail to find our
    # gcctooldir/ld. And clang(1) (unlike gcc) doesn't need $GCC_BARG to
    # find as(1).
    GCC_BARG= ;;
   *) OFLAG_ARGS="-Os$NL-falign-functions=1$NL-falign-jumps=1$NL-falign-loops=1$NL-mpreferred-stack-boundary=2" ;;
  esac
  test "$TCC" && OFLAG_ARGS="-Os"
fi
INCLUDEDIR_ARG=
DEF_ARG=
if test "$DO_ADD_INCLUDEDIR"; then
  INCLUDEDIR_ARG="-I$MYDIR/libc/minilibc/include"
  if test "$USE_UCLIBC"; then
    DEF_ARG="-D__asm__(x)=$NL-D__UCLIBC__"   # Make it ignore __asm__("mini_printf") in stdio.h, so that the linker will find the uClibc printf(...).
  else
    DEF_ARG="-D__MINILIBC686__$NL-DCONFIG_INLINE_FILENO"
  fi
fi
if test "$TCC"; then
  # TODO(pts): Does TCC really generate i386-only code?
  ARGS="$TCC$NL-m32$NL-march=$ARCH$NL-static$NL-nostdlib$NL-nostdinc$NL$SFLAG$NL$OFLAG_ARGS$NL$WFLAGS$NL$DEF_ARG$NL$ARGS$NL$INCLUDEDIR_ARG"
else
  # This also works with TCC, but it's too much cruft.
  # The `-B$MYDIR/gcctooldir' argument makes our gcctooldir/collect2 or gcctooldir/ld run.
  # Add $INCLUDEDIR_ARG last, so that -I... specified by the user takes precedence.
  # Specifying -fcommon since -fno-common is the default since GCC 10 and Clang 11: https://maskray.me/blog/2022-02-06-all-about-common-symbols
  # DYI dietlibc 0.34 adds: gcc -Os -fomit-frame-pointer -falign-functions=1 -falign-jumps=1 -falign-loops=1 -mpreferred-stack-boundary=4
  ARGS="$TCC$NL$GCC$NL$GCC_BARG$NL-B$MYDIR/gcctooldir$NL-m32$NL-march=$ARCH$NL-static$NL-fno-pic$NL-U_FORTIFY_SOURCE$NL-fcommon$NL-fno-stack-protector$NL-fno-unwind-tables$NL-fno-asynchronous-unwind-tables$NL-fno-builtin$NL-fno-ident$NL-fsigned-char$NL-ffreestanding$NL-fno-lto$NL-nostdlib$NL-nostdinc$NL$SFLAG$NL$OFLAG_ARGS$NL$WFLAGS$NL$DEF_ARG$NL$ARGS$NL$INCLUDEDIR_ARG"
fi
if test "$DO_ADD_LIB"; then
  LIBWL=
  if test "$USE_UCLIBC"; then
    test "$GCC" && LIBWL=-Wl,  # -Wl, is needed, otherwise GCC will complain that it is not able to find "$LIBFN" (which doesn't exist on the filesystem).
    LIBFN=///tmp///LIBTCC1.a  # Embedded in tools/pts-tcc.
  else
    LIBFN="$MYDIR/libc/minilibc/libc.$ARCH.a"
    if ! test -f "$LIBFN"; then
      if "$MYDIR/build.sh" && test -f "$LIBFN"; then :; else
        echo "fatal: failed to build libc .a: $LIBFN" >&2
        exit 3
      fi
    fi
  fi
  if test "$TCC" || test "$TCCLD"; then  # TCC needs an explicit start*.o in the command line -- or does it?
    OBJFN="$MYDIR/helper_lib/need_start.o"
    if ! test -f "$OBJFN"; then
      # !! TODO(pts): Let build.sh take care of this.
      test "$HAD_V" && echo "info: compiling: $MYDIR/helper_lib/need_start.nasm" >&2
      if "$MYDIR/tools/nasm-0.98.39" -O0 -w+orphan-labels -f elf -o "$OBJFN" "$MYDIR/helper_lib/need_start.nasm" && test -f "$OBJFN"; then :; else
        echo "fatal: failed to build need-start .o: $OBJFN" >&2
        exit 3
      fi
    fi
    ARGS="$ARGS$NL$OBJFN"
    if test "$USE_UCLIBC"; then
      OBJFN="$MYDIR/helper_lib/need_uclibc_main.o"
      if ! test -f "$OBJFN"; then
        # !! TODO(pts): Let build.sh take care of this.
        test "$HAD_V" && echo "info: compiling: $MYDIR/helper_lib/need_uclibc_main.nasm" >&2
        if "$MYDIR/tools/nasm-0.98.39" -O0 -w+orphan-labels -f elf -o "$OBJFN" "$MYDIR/helper_lib/need_uclibc_main.nasm" && test -f "$OBJFN"; then :; else
          echo "fatal: failed to build need-uclibc-main .o: $OBJFN" >&2
          exit 3
        fi
      fi
      ARGS="$ARGS$NL$OBJFN"
    fi
  fi
  ARGS="$ARGS$NL$LIBWL$LIBFN"
  if test "$TCC" && test -z "$USE_UCLIBC"; then
    LIBFN="$MYDIR/helper_lib/libminitcc1.a"
    if ! test -f "$LIBFN"; then
      if "$MYDIR/build.sh" && test -f "$LIBFN"; then :; else
       echo "fatal: failed to build libtcc1 .a: $LIBFN" >&2
        exit 3
      fi
    fi
    ARGS="$ARGS$NL$LIBFN"
  fi
  if test "$USE_UCLIBC"; then
    OBJFN="$MYDIR/helper_lib/start_uclibc_linux.o"
    if ! test -f "$OBJFN"; then
      # !! TODO(pts): Let build.sh take care of this.
      test "$HAD_V" && echo "info: compiling: $MYDIR/helper_lib/start_uclibc_linux.nasm" >&2
      if "$MYDIR/tools/nasm-0.98.39" -O0 -w+orphan-labels -f elf -o "$OBJFN" "$MYDIR/helper_lib/start_uclibc_linux.nasm" && test -f "$OBJFN"; then :; else
        echo "fatal: failed to build uclibc start .o: $OBJFN" >&2
        exit 3
      fi
    fi
    ARGS="$ARGS$NL$LIBWL$OBJFN"
  fi
fi

test "$TMPDIR" || TMPDIR=/tmp
if test "${TMPDIR#/}" = "$TMPDIR"; then TMPDIR=".//////$TMPDIR"
else TMPDIR="/////$TMPDIR"
fi
export TMPDIR
# Now $TMPDIR contains ////// (at least 6 consecutive slashes), this is how
# we are going to detect temporary .o files in the linker.

IFS="$NL"  # Argument splitting will happen over newlines only.
export MINICC_TOOLS="$MYDIR/tools"
test "$HAD_V" && echo "info: running compiler:" $ARGS >&2  # !! TODO(pts): Write to stdout if GCC also writes there.
if test "$TCC" && test "$DO_LINK" && test "$DO_STRIP"; then
  $ARGS || exit "$?"
  # Same functionality as in gcctooldir/ld.
  MINICC_LDV=
  test "$HAD_V" && MINICC_LDV=-v
  EFARGS="$MINICC_TOOLS/elfxfix$NL-l$NL-a$NL-s$NL$MINICC_LDV$NL--$NL$OUTFILE"
  test "$MINICC_LDV" && echo "info: running extra strip:" $EFARGS >&2
  ARGS="$EFARGS"
fi
exec $ARGS
