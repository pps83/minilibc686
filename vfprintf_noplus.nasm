;
; It supports format flags '-', '0', and length modifiers. It doesn't support format flag '+'.
; .nasm source file generated by soptcc.pl from c_vfprintf_noplus.c
; Compile to i386 ELF .o object: nasm -O999999999 -w+orphan-labels -f elf -o vfprintf_noplus.o vfprintf_noplus.nasm

bits 32
cpu 386
section .text align=1
section .rodata align=4
section .data align=4
section .bss align=4

global mini_vfprintf
%ifidn __OUTPUT_FORMAT__, bin
section .text align=1
section .rodata align=1
section .data align=1
section .bss align=1
mini_fputc equ +0x12345678
%else
section .text align=1
section .rodata align=4
section .data align=4
section .bss align=4
extern mini_fputc
%endif

section .text  ; _TEXT
mini_vfprintf:
		push ebx
		push esi
		push edi
		push ebp
		sub esp, 0x24
		mov ebx, [esp+0x3c]
		xor ebp, ebp
$L$1:
		mov al, [ebx]
		test al, al
		je $L$33
		cmp al, 0x25
		jne $L$30
		xor eax, eax
		mov [esp+0x14], eax
		xor edi, edi
		inc ebx
		mov al, [ebx]
		test al, al
		je $L$33
		cmp al, 0x25
		je $L$30
		cmp al, 0x2d
		jne $L$2
		mov eax, 0x1
		mov [esp+0x14], eax
		add ebx, eax
$L$2:
		cmp byte [ebx], 0x30
		jne $L$3
		or byte [esp+0x14], 0x2
		inc ebx
		jmp $L$2
$L$3:
		mov al, [ebx]
		cmp al, 0x30
		jl $L$4
		cmp al, 0x39
		jg $L$4
		imul edi, 0xa
		movsx eax, al
		sub eax, 0x30
		add edi, eax
		inc ebx
		jmp $L$3
$L$4:
		mov al, [ebx]
		mov esi, esp
		mov ecx, [esp+0x40]
		add ecx, 0x4
		cmp al, 0x73
		jne $L$14
		mov [esp+0x40], ecx
		mov esi, [ecx-0x4]
		test esi, esi
		jne $L$5
		mov esi, $L$34
$L$5:
		mov byte [esp+0x1c], 0x20
		test edi, edi
		jbe $L$10
		xor eax, eax
		mov ecx, esi
$L$6:
		cmp byte [ecx], 0x0
		je $L$7
		inc eax
		inc ecx
		jmp $L$6
$L$7:
		cmp eax, edi
		jb $L$8
		xor edi, edi
		jmp $L$9
$L$8:
		sub edi, eax
$L$9:
		test byte [esp+0x14], 0x2
		je $L$10
		mov byte [esp+0x1c], 0x30
$L$10:
		test byte [esp+0x14], 0x1
		jne $L$12
$L$11:
		test edi, edi
		jbe $L$12
		push dword [esp+0x38]
		movsx eax, byte [esp+0x20]
		push eax
		call mini_fputc
		add esp, 0x8
		inc ebp
		dec edi
		jmp $L$11
$L$12:
		mov al, [esi]
		test al, al
		je $L$13
		push dword [esp+0x38]
		movsx eax, al
		push eax
		call mini_fputc
		add esp, 0x8
		inc ebp
		inc esi
		jmp $L$12
$L$13:
		test edi, edi
		jbe $L$32
		push dword [esp+0x38]
		movsx eax, byte [esp+0x20]
		push eax
		call mini_fputc
		add esp, 0x8
		inc ebp
		dec edi
		jmp $L$13
$L$14:
		cmp al, 0x63
		jne $L$15
		mov [esp+0x40], ecx
		mov al, [ecx-0x4]
		mov [esp], al
		test edi, edi
		je $L$29
		jmp $L$17
$L$15:
		mov [esp+0x40], ecx
		mov ecx, [ecx-0x4]
		cmp al, 0x64
		je $L$16
		cmp al, 0x75
		je $L$16
		mov ah, al
		or ah, 0x20
		cmp ah, 0x78
		jne $L$33
$L$16:
		test ecx, ecx
		jne $L$18
		mov byte [esi], 0x30
$L$17:
		mov byte [esi+0x1], 0x0
		jmp $L$5
$L$18:
		mov ah, al
		or ah, 0x20
		cmp ah, 0x78
		jne $L$19
		mov esi, 0x10
		jmp $L$20
$L$19:
		mov esi, 0xa
$L$20:
		mov [esp+0xc], esi
		cmp al, 0x58
		jne $L$21
		mov esi, 0x41
		jmp $L$22
$L$21:
		mov esi, 0x61
$L$22:
		sub esi, 0x3a
		mov [esp+0x10], esi
		mov ah, [esp+0x10]
		mov [esp+0x20], ah
		cmp al, 0x64
		jne $L$23
		cmp dword [esp+0xc], 0xa
		jne $L$23
		test ecx, ecx
		jge $L$23
		mov byte [esp+0x18], 0x1
		neg ecx
		jmp $L$24
$L$23:
		mov byte [esp+0x18], 0x0
$L$24:
		lea esi, [esp+0xa]
		mov byte [esp+0xa], 0x0
$L$25:
		test ecx, ecx
		je $L$27
		xor edx, edx
		mov eax, ecx
		div dword [esp+0xc]
		mov eax, edx
		cmp dl, 0xa
		jb $L$26
		add al, [esp+0x20]
$L$26:
		add al, 0x30
		dec esi
		mov [esi], al
		xor edx, edx
		mov eax, ecx
		div dword [esp+0xc]
		mov ecx, eax
		jmp $L$25
$L$27:
		cmp byte [esp+0x18], 0x0
		je $L$5
		test edi, edi
		je $L$28
		test byte [esp+0x14], 0x2
		je $L$28
		push dword [esp+0x38]
		push 0x2d
		call mini_fputc
		add esp, 0x8
		inc ebp
		dec edi
		jmp $L$5
$L$28:
		dec esi
		mov byte [esi], 0x2d
		jmp $L$5
$L$29:
		push dword [esp+0x38]
		movsx eax, al
		jmp $L$31
$L$30:
		push dword [esp+0x38]
		movsx eax, byte [ebx]
$L$31:
		push eax
		call mini_fputc
		add esp, 0x8
		inc ebp
$L$32:
		inc ebx
		jmp $L$1
$L$33:
		mov eax, ebp
		add esp, 0x24
		pop ebp
		pop edi
		pop esi
		pop ebx
		ret

section .rodata  ; CONST

section .rodata  ; CONST2

section .data  ; _DATA

section .rodata
__strs:
$L$34:
		db '(null)', 0

; __END__
