;
; based on .nasm source file generated by soptcc.pl from c_stdio_medium_fopen.c
; Compile to i386 ELF .o object: nasm -O999999999 -w+orphan-labels -f elf -o stdio_medium_fopen.o stdio_medium_fopen.nasm
;
; Uses: %ifdef CONFIG_PIC
;

bits 32
cpu 386

global mini_fopen
%ifdef CONFIG_SECTIONS_DEFINED
%elifidn __OUTPUT_FORMAT__, bin
section .text align=1
section .rodata align=1
section .data align=1
section .bss align=1
mini___M_jmp_freopen_low equ +0x12345678
mini___M_jmp_freopen_low.error equ +0x12345679
mini___M_global_file_bufs equ +0x1234567a
mini___M_global_files equ +0x1234567b
mini___M_global_files_end equ +0x1234567c
%else
extern mini___M_jmp_freopen_low
extern mini___M_jmp_freopen_low.error
extern mini___M_global_file_bufs
extern mini___M_global_files
extern mini___M_global_files_end
section .text align=1
section .rodata align=1
section .data align=1
section .bss align=1
%endif

section .text
mini_fopen:  ; FILE *mini_fopen(const char *pathname, const char *mode);
		push edi
		push esi
		push ebx
		mov edi, mini___M_global_file_bufs
		mov esi, mini___M_global_files
.next:		cmp esi, mini___M_global_files_end
		je strict near mini___M_jmp_freopen_low.error  ; TODO(pts): With smart linking, make this a short jump.
		cmp byte [esi+0x14], 0x0  ; FD_CLOSED.
		je .found
		add esi, byte 0x24  ; sizeof(struct _SMS_FILE).
		add edi, 0x1000  ; BUF_SIZE.
		jmp short .next
.found:		mov [esi+0x18], edi  ; .buf_start := EDI.
		add edi, 0x1000  ; EDI := .buf_start + BUF_SIZE.
		mov [esi+0x4], edi  ; .buf_end := .buf_start + BUF_SIZE;
		mov [esi+0x1c], edi  ; .buf_capacity_end := .buf_start + BUF_SIZE;
		jmp strict near mini___M_jmp_freopen_low  ; TODO(ps): With smart linking, make this fall through.

%ifdef CONFIG_PIC
%error Not PIC because it uses global variables.
times 1/0 nop
%endif

; __END__
