;
; based on .nasm source file generated by soptcc.pl from c_stdio_medium_fopen.c
; Compile to i386 ELF .o object: nasm -O999999999 -w+orphan-labels -f elf -o c_stdio_medium_fopen.o c_stdio_medium_fopen.nasm
;

bits 32
%ifdef CONFIG_I386
cpu 386
%else
cpu 686  ; cmovne.
%endif

global mini_fopen
%ifdef CONFIG_SECTIONS_DEFINED
%elifidn __OUTPUT_FORMAT__, bin
section .text align=1
section .rodata align=1
section .data align=1
section .bss align=1
mini_open equ +0x12345678
mini___M_discard_buf equ +0x12345679
mini___M_global_file_bufs equ +0x1234567a
mini___M_global_files equ +0x1234567b
mini___M_global_files_end equ +0x1234567c
mini___M_start_flush_opened equ +0x1234567d
%else
extern mini_open
extern mini___M_discard_buf
extern mini___M_global_file_bufs
extern mini___M_global_files
extern mini___M_global_files_end
extern mini___M_start_flush_opened
section .text align=1
section .rodata align=1
section .data align=1
section .bss align=1
%endif

section .text
mini_fopen:  ; FILE *fopen(const char *pathname, const char *mode);
		push edi
		push esi
		push ebx
		mov edi, mini___M_global_file_bufs
		mov esi, mini___M_global_files
.next:		cmp esi, mini___M_global_files_end
		je mini___M_jmp_freopen_low.error
		cmp byte [esi+0x14], 0x0  ; FD_CLOSED.
		je mini___M_jmp_freopen_low
		add esi, byte 0x24  ; sizeof(struct _SMS_FILE).
		add edi, 0x1000  ; BUF_SIZE.
		jmp short .next

; Input: EAX == junk, EBX == junk, ECX == junk, EDX == junk, ESI == FILE* pointer, EDI == buffer pointer (of BUF_SIZE), EBP == anything.
; Input stack: [esp] == saved EBX, [esp+1*4]: saved ESI, [esp+2*4]: saved EDI, [esp+3*4]: return address, [esp+4*4]: argument pathname, [esp+5*5]: argument mode.
; Output: EAX == result FILE* pointer (or NULL), EBX == restored, ECX == junk, EDX == junk, ESI == restored, EDI == restored, EBP == unchanged.
; Output stack: poped up to and including the return address.
mini___M_jmp_freopen_low:
		mov edx, [esp+5*4]  ; Argument mode.
		mov dl, [edx]
		cmp dl, 'w'
		sete bl  ; is_write?
		xor eax, eax  ; EAX := O_RDONLY.
		cmp dl, 'a'
		sete cl
		or bl, cl
		je .have_flags
		cmp dl, 'a'
		; We may add O_LARGEFILE for opening files >= 2 GiB, but in a different stdio implementation. Without O_LARGEFILE, open(2) fails with EOVERFLOW.
		mov eax, 3101o  ; EAX := O_TRUNC | O_CREAT | O_WRONLY | O_APPEND.
		mov edx, 1101o  ; EAX := O_TRUNC | O_CREAT | O_WRONLY. 
%ifdef CONFIG_I386
		je .have_flags
		mov eax, edx
%else
		cmovne eax, edx
%endif
.have_flags:	; File open flags is now in EAX.
		push dword 666o
		push eax  ; File open flags.
		push dword [esp+6*4]  ; Argument pathname.
		call mini_open
		add esp, byte 0xc  ; Clean up arguments of mini_open(...) from the stack.
		test eax, eax
		jns .open_ok
.error:		xor eax, eax  ; EAX := NULL (return value, indicating error).
		jmp short .done
.open_ok:	cmp bl, 0x1
		sbb edx, edx
		and dl, -0x3
		mov [esi+0x18], edi
		add dl, 0x4
		add edi, 0x1000
		mov [esi+0x10], eax
		mov [esi+0x14], dl
		mov dword [esi+0x20], 0x0
		mov [esi+0x4], edi
		mov [esi+0x1c], edi
		push esi
		call mini___M_discard_buf
		pop eax  ; Clean up argument of mini___M_discard_buf from the stack.
		xchg eax, esi  ; EAX := ESI (return value); ESI := junk.
.done:		pop ebx
		pop esi
		pop edi
		ret

%ifdef CONFIG_PIC  ; Already position-independent code.
%endif

; __END__
