;
; realloc.nasm: malloc+free+realloc implemented as a bucket-pool allocator
; written by pts@fazekas.hu at Sun Jun 25 23:29:13 CEST 2023
; based on .nasm source file generated by soptcc.pl from fyi/c_malloc_bucketed.c
; Compile to i386 ELF .o object: nasm -O999999999 -w+orphan-labels -f elf -o realloc.o realloc.nasm
;
; Code size: 0x104 bytes.
;
; Uses: %ifdef CONFIG_PIC
;
; This is a short and fast (O(1) per operation) allocator, but it wastes
; memory (less than 50%).
;
; It returns pointer aligned to a multiple of 4 bytes (or size_t, whichever
; is larger). Each malloc(...), free(...) and realloc(...) call takes O(1)
; time. Less than 50% of the allocated memory is wasted because of
; occasional rounding up to the next power of 2. If there is no free(...)
; or reallocating realloc(...) call, then the overhead per block is just 4
; bytes + alignment (0..3 bytes).
;
; New memory blocks are requested from the system using
; mini_malloc_simple_unaligned(...), which eventually calls sys_brk(...).
; There are 30 buckets (corresponding to block sizes 1<<2 .. 1<<31), each
; containing a signly linked list of free()d blocks. When a new block is
; allocated, the corresponding bucket size is tried. Blocks remain in their
; respective buckets, they are never joined or split. The rounding up to
; the next power of 2 happens in realloc(...) only, thus free()d blocks in
; the buckets don't have a power-of-2 size. To combat fragmentation (in a
; limited way), a best fit match of up to BEST_FIT_LIMIT (16) free()d
; blocks is tried in the previous (1 smaller) bucket, so a malloc(n) after
; a recent free(n) would assign the same block, without fragmentation.
;
; Other allocators considered:
;
; * uClibc
; * diet libc
; * newlib
; * picolibc
; * https://moss.cs.iit.edu/cs351/slides/slides-malloc.pdf
; * https://github.com/jterrazz/42-malloc
;   https://medium.com/a-42-journey/how-to-create-your-own-malloc-library-b86fedd39b96
; * https://codereview.stackexchange.com/questions/209981/simple-malloc-implementation
; * https://www.math.uni-bielefeld.de/~rehmann/Ckurs-f/b04/alloc.h
; * https://stackoverflow.com/questions/3752604/simple-c-malloc
; * https://github.com/sonugiri1043/Malloc-Free
; * https://gist.github.com/mshr-h/9636fa0adcf834103b1b
; * http://ccodearchive.net/info/antithread/alloc.html
;
; The allocators aober were either too long or too slow (O(n) for each
; operation).
;

bits 32
cpu 386

global mini_realloc
%ifidn __OUTPUT_FORMAT__, bin
section .text align=1
section .rodata align=1
section .data align=1
section .bss align=4
mini_malloc_simple_unaligned equ +0x12345678
%else
extern mini_malloc_simple_unaligned
section .text align=1
section .rodata align=1
section .data align=1
section .bss align=4
%endif

BEST_FIT_LIMIT equ 16

section .text
mini_realloc:  ; void *mini_realloc(void *ptr, size_t size);
		push ebp
		push edi
		push esi
		push ebx
		push ecx
		mov edi, [esp+0x18]
		mov ebx, [esp+0x1c]
		test ebx, ebx
		js near .2
		test edi, edi
		jne near .3
		test ebx, ebx
		jne .4
		mov ebx, 1
.4:		add ebx, byte 3
		and ebx, byte -4
		mov edx, free_bucket_heads
		xor eax, eax
		mov al, 4
.5:		cmp ebx, eax
		jbe .39
		add eax, eax
		add edx, byte 4
		jmp short .5
.39:		lea eax, [ebx-1]
		test eax, ebx
		je .7
		lea edi, [edx-4]
		mov eax, [edx-4]
		mov byte [esp+3], BEST_FIT_LIMIT  ; best_fit_limit.
		xor esi, esi
		or ebp, byte -1
.8:		test eax, eax
		je .10
		mov ecx, [eax-4]
		cmp ebx, ecx
		ja .9
		sub ecx, ebx
		cmp ecx, ebp
		jnb .9
		mov esi, edi
		mov ebp, ecx
.9:		mov ecx, [eax]
		mov edi, eax
		dec byte [esp+3]  ; best_fit_limit.
		je .10
		mov eax, ecx
		jmp short .8
.10:		test esi, esi
		je .7
		mov edi, [esi]
		mov eax, [edi]
		mov [esi], eax
		jmp short .12
.7:		mov edi, [edx]
		test edi, edi
		je .13
		mov eax, [edi]
		mov [edx], eax
		jmp short .12
.13:		lea eax, [ebx+4]
		push eax
		call mini_malloc_simple_unaligned
		pop edx
		test eax, eax
		je .2
		mov [eax], ebx
		lea edi, [eax+4]
		jmp short .12
.3:		test ebx, ebx
		jne .14
.do_free:	mov ecx, [edi-4]
		mov eax, free_bucket_heads
		xor edx, edx
		mov dl, 4
.16:		cmp edx, ecx
		ja .40
		add edx, edx
		add eax, byte 4
		jmp short .16
.40:		mov edx, [eax-4]
		mov [edi], edx
		mov [eax-4], edi
		mov edi, ebx
		jmp short .12
.14:		mov esi, [edi-4]
		xor eax, eax
		mov al, 4
		cmp ebx, esi
		jbe .12
.18:		cmp eax, ebx
		jnb .41
		add eax, eax
		jmp short .18
.41:		push eax
		push byte 0
		call mini_realloc
		mov ebx, eax
		pop ecx
		pop ebp
		test eax, eax
		je .2
		; memcpy ESI bytes from EDI to EAX, may ruin EAX, ECX and ESI.
		push edi
		xchg eax, edi
		xchg eax, esi
		xchg eax, ecx  ; ECX := byte count; EAX := junk.
		rep movsb
		pop edi
		jmp short .do_free
.2:		xor edi, edi
.12:		mov eax, edi
		pop edx
		pop ebx
		pop esi
		pop edi
		pop ebp
		ret

section .bss
free_bucket_heads: resd 0x20-2

%ifdef CONFIG_PIC
%error Not PIC because of read-write variables.
%endif

; __END__
