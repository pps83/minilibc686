;
; manually optimized based on .nasm source file generated by soptcc.pl from fyi/c_getopt.c
; Compile to i386 ELF .o object: nasm -O999999999 -w+orphan-labels -f elf -o getopt.o getopt.nasm
;
; Code+data size: 0x19b bytes for i686, 0x19c bytes for i386.
;
; Uses: %ifdef CONFIG_PIC
; Uses: %ifdef CONFIG_I386
; Uses: %ifdef CONFIG_GETOPT_ASSUME_OPTERR_TRUE
;

bits 32
%ifdef CONFIG_I386
cpu 386
%else
cpu 686
%endif

global mini_getopt
global mini_optind
global mini_optarg
global mini_optopt
%ifndef CONFIG_GETOPT_ASSUME_OPTERR_TRUE
  global mini_opterr
%endif
%ifdef CONFIG_SECTIONS_DEFINED
%elifidn __OUTPUT_FORMAT__, bin
section .text align=1
section .rodata align=1
section .data align=1  ; For .bin size measurements.
section .bss align=1  ; For .bin size measurements.
mini_write equ +0x12345678
%else
extern mini_write
section .text align=1
section .rodata align=1
section .data align=4
section .bss align=4
%endif

section .text
mini_getopt:  ; int mini_getopt(int argc, char * const argv[], const char *optstring);
		mov ecx, [mini_optind]
		test ecx, ecx
		jnz .2
		mov dword [getopt.lastidx], ecx  ; 0.
		inc ecx
		mov dword [mini_optind], ecx  ; 1.
.2:		push ebp
		mov ebp, esp
		push ebx
		push edi
		push esi
		cmp ecx, [ebp+8]
		jng .3
.error.jmp:	jmp near .error  ; Group short jumps together.
.3:		mov eax, [ebp+0xc]
.4:		mov edi, [eax+ecx*4]
		test edi, edi
		je near .error.jmp
		cmp byte [edi], '-'
		jne near .error.jmp
		mov al, [edi+1]
		cmp al, '-'
		je .11
		test al, al
		jne .9
		jmp near .error.jmp
.11:		cmp byte [edi+2], 0
		je near .12
.9:		cmp [getopt.lastidx], ecx
		jne .13
		mov esi, [getopt.lastofs]
		jmp short .14
.13:		mov [getopt.lastidx], ecx
		xor esi, esi
		mov dword [getopt.lastofs], esi  ; 0.
.14:		mov bl, [edi+esi+1]
		movsx eax, bl
		mov [mini_optopt], eax
		mov edx, [ebp+0x10]
		mov bh, [edx]
		cmp bh, bl
		je .18
		mov edx, [ebp+0x10]
.16:		test bh, bh
		je .28
		mov bh, [edx+1]
		inc edx
		cmp bh, bl
		jne .16
.18:		test bl, bl
		jne .20
		inc ecx
		mov [mini_optind], ecx
		mov eax, [ebp+0xc]
		cmp ecx, [ebp+8]
		jle .4
		jmp short .error
.28:		inc ecx
		mov [mini_optind], ecx
		mov bh, '?'
		mov eax, getopt.error1
.29:		; Now BH == '?'.
%ifndef CONFIG_GETOPT_ASSUME_OPTERR_TRUE
		cmp dword [mini_opterr], byte 0
		je .33
%endif
		lea ecx, [eax-1]
.31:		inc ecx
		cmp byte [ecx], 0
		jne .31
		mov [ecx-4], bl  ; Modify the 'x' to the flag byte.
		sub ecx, eax
		push ecx
		push eax
		push byte 2  ; STDERR_FILENO.
		call mini_write  ; Write modified error message.
		add esp, byte 0xc  ; Clean up arguments of mini_write from the stack.
.33:		movsx eax, bh
		jmp short .done
.20:		cmp byte [edx+1], ':'
		jne .27
		cmp byte [edx+2], ':'
		je .23
		cmp byte [edi+esi+2], 0
		je .25
.23:		lea edx, [edi+esi+2]
		mov [mini_optarg], edx
		xor esi, esi
		cmp byte [edx], 0
%ifdef CONFIG_I386
		je .after_cmovne
		mov esi, edx
.after_cmovne:
%else
		cmovne esi, edx
%endif
		mov [mini_optarg], esi
.24:		inc ecx
		mov [mini_optind], ecx
		jmp short .done
.12:		inc ecx
		mov [mini_optind], ecx
.error:		or eax, byte -1  ; EAX := -1.
.done:		pop esi
		pop edi
		pop ebx
		pop ebp
		ret
.27:		inc esi
		mov [getopt.lastofs], esi
		jmp short .done
.25:		mov edx, [ebp+0xc]
		mov edx, [edx+ecx*4+4]
		inc ecx
		mov [mini_optarg], edx
		test edx, edx
		mov [mini_optind], ecx
		jne .24
		mov bh, ':'
		mov eax, getopt.error2
		mov ecx, [ebp+0x10]
		cmp [ecx], bh
		je .29
		jmp short .33

section .data
mini_optind:	dd 1
%ifndef CONFIG_GETOPT_ASSUME_OPTERR_TRUE
  mini_opterr:	dd 1
%endif
getopt.error1:	db 'Unknown option `-x', 39, '.', 10, 0  ; The 'x' will be modified.
getopt.error2:	db 'Missing argument for `-x', 39, '.', 10, 0  ; The 'x' will be modified.

section .bss
getopt.lastidx:	resb 4
getopt.lastofs:	resb 4
mini_optarg:	resb 4
mini_optopt:	resb 4

%ifdef CONFIG_PIC
%error Not PIC because of read-write global variables.
times 1/0 nop
%endif

; __END__
