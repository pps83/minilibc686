;
; based on .nasm source file generated by soptcc.pl from fyi/c_mkstemp_linux.c
; Compile to i386 ELF .o object: nasm -O999999999 -w+orphan-labels -f elf -o src/mkstemp_linux.o src/mkstemp_linux.nasm
;
; Code size: 0xaa bytes.
;
; TODO(pts): Optimize this.
;

bits 32
cpu 386

global mini_mkstemp
%ifdef CONFIG_SECTIONS_DEFINED
%elifidn __OUTPUT_FORMAT__, bin
section .text align=1
section .rodata align=1
section .data align=1
section .bss align=1
mini_open equ +0x12345678
mini_errno equ +0x12345679
mini_rand equ +0x1234567a
%else
extern mini_open
extern mini_errno
extern mini_rand
section .text align=1
section .rodata align=1
section .data align=1
section .bss align=1
%endif

%define EEXIST 17
%define EINVAL 22

%define O_CREAT 0100
%define O_RDWR   2
%define O_EXCL  0200
%define O_NOFOLLOW 0400000

section .text
mini_mkstemp:  ; int mini_mkstemp(char *template);
		push ebp
		push edi
		push esi
		push ebx
		mov esi, [esp+0x14]
		mov eax, esi
.2:		cmp byte [eax], 0x0
		je .15
		inc eax
		jmp short .2
.15:		lea ebx, [eax-0x6]
		cmp esi, ebx
		ja .4
		mov edi, ebx
.7:		cmp byte [edi], 0x58
		je .5
.4:		mov dword [mini_errno], EINVAL
		or eax, byte -1
		jmp short .1
.5:		inc edi
		cmp edi, eax
		jne .7
.9:		call mini_rand
		mov edx, eax
		sal edx, 13
		xor eax, edx
		mov edx, eax
		shr edx, 17
		xor eax, edx
		mov ebp, eax
		sal ebp, 5
		xor ebp, eax
		xor eax, eax
		mov al, 20  ; __NR_getpid.
		int 0x80  ; Linux i386 syscall. EAX := getpid().
		add ebp, eax
		mov eax, ebp
		sal eax, 13
		xor eax, ebp
		mov edx, eax
		shr edx, 17
		xor eax, edx
		mov edx, eax
		sal edx, 5
		xor eax, edx
		mov edx, ebx
.8:		mov ecx, eax  ; ECX := random (EAX).
		and eax, byte 0x1f  ; 5 bits.
		cmp al, 9
		jna .10
		add al, 'a'-10-'0'
.10		add al, '0'
		mov [edx], eax
		xchg ecx, eax  ; EAX := random; ECX := junk.
		shr eax, 5
		inc edx
		cmp edx, edi
		jne .8
		push dword 600o
		push dword O_CREAT|O_RDWR|O_EXCL|O_NOFOLLOW
		push esi
		call mini_open
		add esp, byte 3*4  ; Clean up arguments of mini_open from the stack.
		test eax, eax
		jns .1
		cmp dword [mini_errno], byte EEXIST
		je .9
.1:		pop ebx
		pop esi
		pop edi
		pop ebp
		ret

%ifdef CONFIG_PIC
%error Not PIC because it uses global variable errno.
times 1/0 nop
%endif

; __END__
